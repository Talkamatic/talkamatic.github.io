{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"A number of concepts need to be known to the developer when creating TDM Dialogue Domain Descriptions (DDDs). We recommend new developers to start by reading the introductory presentation by Alexander and studying the basic concepts below. After that, work through the tutorial for hands on practice, or skip straight to the example DDDs Actions An action is requested by the user and performed by the system. It may or may not require a number of answers in order to be performed. Example: U> Call. or U> Call John. Queries A query is asked by the user or the system, when they want a piece of information. It can be formulated as a question, or as a request. Similar to an action, it may or may not require a number of answers in order to be answered. U> What is John's number? or U> Tell me John's number. Answers An answer is provided by the user or the system, providing information that is relevant for a question or request. When provided by the user, it can be resolving or not. If the question is about a contact, the following would be an answer: U> John Feedback Feedback is given by the system to inform the user. For example that actions have been performed, that the system did not hear what the user said, etc. S> Calling John. or S> I did not hear.","title":"Introduction"},{"location":"index.html#actions","text":"An action is requested by the user and performed by the system. It may or may not require a number of answers in order to be performed. Example: U> Call. or U> Call John.","title":"Actions"},{"location":"index.html#queries","text":"A query is asked by the user or the system, when they want a piece of information. It can be formulated as a question, or as a request. Similar to an action, it may or may not require a number of answers in order to be answered. U> What is John's number? or U> Tell me John's number.","title":"Queries"},{"location":"index.html#answers","text":"An answer is provided by the user or the system, providing information that is relevant for a question or request. When provided by the user, it can be resolving or not. If the question is about a contact, the following would be an answer: U> John","title":"Answers"},{"location":"index.html#feedback","text":"Feedback is given by the system to inform the user. For example that actions have been performed, that the system did not hear what the user said, etc. S> Calling John. or S> I did not hear.","title":"Feedback"},{"location":"examples.html","text":"Below are examples for you to imitate. Find one that matches your desired functionality and start stealing ideas. Remember to work test driven, adding one test at a time, then making it work, according to the tutorial . Basic action This example is featured in the tutorial . Let your user do an action, using an entity recognizer for its findout . In this case, call a contact where the contact name is the recognized entity. U> Call John S> Calling John. This is an example of the basic action , answer and feedback concepts in TDM. It shows what is needed in order to perform an action that you implement yourself in the python service interface . In addition, it uses an entity recognizer to recognize contacts during run time. The source code is available on Github . Basic query Let your user ask a question. While similar to the basic action example, a query lets the system speak an answer to a question rather than performing an action. In this case, it answers what phone number a contact has. U> What is John's number? S> John's number is 0701234567. This is an example of the basic query and answer concepts in TDM. It shows what is needed in order to ask a query that is answered by the system. You implement the answer logic yourself in the python service interface . The source code is available on Github . Parameter validation Should some actions or questions be unavailable, disallowed or prohibited for your user? Parameter validation makes it easy to decide at run-time. This example is based on the basic action example , disallowing phone calls to contacts with no phone number. U> Call Andy S> Andy has no phone number. When a service is queried for parameters to actions and queries, the parameter is validated against all matching validators. If invalid, a specific grammar entry is used to provide system feedback and the answer is neglected. The source code is available on Github . Incremental search Is your user looking for a single item in a set of many? Make sure your application asks just the perfect amount of questions to find one and only one match. In this case, contacts to call are searched with first and last names. U> Call John S> What's his last name? U> Johnson S> Calling John Johnson at 0702446698. Incremental search utilizes predicate features, which are declared in the ontology of the DDD. When a service is queried for individuals of the predicate, the features need to match. By asking the user to specify more features, the search can be narrowed down to finally match a single individual. The source code is available on Github . Android Is your Android device placing the calls for your users? Forward your actions to the Android frontend and do the job there. U> Call John S> Calling John. This example combines the examples of action, query, parameter validation and entity recognition into one DDD and forwards the 'Call' action to the frontend. It can be used together with the android-example , an Android app to showcase how your frontend hears, speaks and thinks. The source code is available on Github .","title":"Examples"},{"location":"examples.html#basic-action","text":"This example is featured in the tutorial . Let your user do an action, using an entity recognizer for its findout . In this case, call a contact where the contact name is the recognized entity. U> Call John S> Calling John. This is an example of the basic action , answer and feedback concepts in TDM. It shows what is needed in order to perform an action that you implement yourself in the python service interface . In addition, it uses an entity recognizer to recognize contacts during run time. The source code is available on Github .","title":"Basic action"},{"location":"examples.html#basic-query","text":"Let your user ask a question. While similar to the basic action example, a query lets the system speak an answer to a question rather than performing an action. In this case, it answers what phone number a contact has. U> What is John's number? S> John's number is 0701234567. This is an example of the basic query and answer concepts in TDM. It shows what is needed in order to ask a query that is answered by the system. You implement the answer logic yourself in the python service interface . The source code is available on Github .","title":"Basic query"},{"location":"examples.html#parameter-validation","text":"Should some actions or questions be unavailable, disallowed or prohibited for your user? Parameter validation makes it easy to decide at run-time. This example is based on the basic action example , disallowing phone calls to contacts with no phone number. U> Call Andy S> Andy has no phone number. When a service is queried for parameters to actions and queries, the parameter is validated against all matching validators. If invalid, a specific grammar entry is used to provide system feedback and the answer is neglected. The source code is available on Github .","title":"Parameter validation"},{"location":"examples.html#incremental-search","text":"Is your user looking for a single item in a set of many? Make sure your application asks just the perfect amount of questions to find one and only one match. In this case, contacts to call are searched with first and last names. U> Call John S> What's his last name? U> Johnson S> Calling John Johnson at 0702446698. Incremental search utilizes predicate features, which are declared in the ontology of the DDD. When a service is queried for individuals of the predicate, the features need to match. By asking the user to specify more features, the search can be narrowed down to finally match a single individual. The source code is available on Github .","title":"Incremental search"},{"location":"examples.html#android","text":"Is your Android device placing the calls for your users? Forward your actions to the Android frontend and do the job there. U> Call John S> Calling John. This example combines the examples of action, query, parameter validation and entity recognition into one DDD and forwards the 'Call' action to the frontend. It can be used together with the android-example , an Android app to showcase how your frontend hears, speaks and thinks. The source code is available on Github .","title":"Android"},{"location":"formalism.html","text":"The Dialog Formalism is a formal language for expressing semantics and domain knowledge within the framework of issue-based dialog management (Larsson, 2002) 1 based on the information state approach (Larsson, Traum, 2000) 2 , (Traum, Larsson, 2003) 3 , which is the foundation of TDM. For readers familiar with logic, the Dialog Formalism is closely related to first-order predicate logic. Some of the constructs of the Dialog Formalism are described below, with corresponding example expressions. Predicates Predicates are used to formalise the meanings of nouns, verbs and adjectives. They typically correspond to slots in form-based (slot-filling) dialog management. Example: selected_contact Individuals Individuals can be arguments of predicates, which corresponds to being values of slots in form-based dialog management. It also aligns with the term \"entity\" used in many other contexts. In TDM, yes and no are modelled as individuals, even if they are not individuals in the concrete sense, but this allows them to be used in answers. Examples: contact_john , which would correspond to John in natural language. yes no Actions An action is something that can be performed. Example: call Questions A question is something that can be asked, answered and resolved. Its expression begins with the question operator ? . Yes-no questions A yes-no question is a question that can be answered with a yes or no. Examples: ?need_visa expresses a question regarding whether a visa is needed. ?selected_contact(contact_john) expresses a question regarding whether the selected contact is John. WH questions A WH question is a question about what, when, where etc. It is expressed as a lambda abstraction. Example: ?X.selected_contact(X) expresses a question about which contact to select. Alternative questions An alternative question is a question containing multiple alternative answers expressed as a set of propositions. Example: ?set([number_to_call(home), number_to_call(mobile)]) expresses a question about whether to call the home or mobile number. Goals A goal expresses an action to perform or a question to resolve, as elaborated below. Perform goals A perform goal has the form perform(A) where A is an action . Example: perform(call) expresses the goal of performing the action call . Resolve goals A resolve goal has the form resolve(Q) where Q is a question . Example: resolve(?X.phone_number(X)) expresses the goal of resolving the question ?X.phone_number(X) . Propositions A proposition expresses something that can be true or false, can be believed to be true, or can be taken as a fact. Propositions have a predicate , a polarity (positive or negative), an arity (nullary or unary) and optionally an argument (an individual , typically). Negative polarity is expressed using the negation operator ~ as prefix. Nullary proposition A nullary proposition has no argument. Examples: need_visa expresses that a visa is needed. ~need_visa expresses that a visa is not needed. Unary propositions A unary proposition takes an individual as an argument. Examples: selected_contact(contact_john) expresses that the selected contact is John. ~selected_contact(contact_john) expresses that the selected contact is not John. Goal propositions A goal proposition expresses that a particular goal should be targeted. It has the form goal(G) where G is a goal . Examples: goal(perform(call)) expresses that the goal of performing call should be targeted. goal(resolve(?X.phone_number(X))) expresses that the goal of resolving ?X.phone_number(X) should be targeted. Plans TBD Plan items A plan item is contained within a dialog plan and expresses an instruction to the dialog manager. TDM supports many different kinds of plan items, the most common of which are described below. Findout A findout item expresses an instruction to find the answer to a question, e.g. by asking the user or asking a service. Example: findout(?X.selected_contact(X)) Invoke service action An invoke_service_action expresses an action to be performed by a service. Example: invoke_service_action(Call, {preconfirm=interrogative, postconfirm=True, downdate_plan=False}) Invoke service query An invoke_service_query expresses an instruction to find the answer to a question by asking a service. Example: invoke_service_query(?X.phone_number(X)) Moves (Dialog) moves reflect the meaning and function of something that is communicated in a dialog. Utterances spoken by the user or system correspond to sequences of moves. TDM supports many different kinds of dialog moves, the most common of which are described below. Ask moves An ask move represents the function of an utterance to get the hearer to answer a question. Example: ask(?X.selected_contact(X)) Request moves A request move represents the function of an utterance to get the hearer to perform an action. Example: request(call) Answer moves An answer move represents the function of an utterance to provide an answer to a question, and to commit the speaker to the truth of that answer. The content of an answer can be a proposition (in a so called propositional answer), or an individual (in a so called sortal answer). The individual of a sortal answer combines with a question to form a proposition; for example, the question ?x.selected_name(x) combined with the individual contact_john forms the proposition selected_name(contact_john) . Examples: answer(contact_john) answer(selected_contact(contact_john)) answer(yes) answer(no) Larsson, S. (2002). Issue-based dialogue management. Department of Linguistics, G\u00f6teborg University. \u21a9 Larsson, S., & Traum, D. R. (2000). Information state and dialogue management in the TRINDI dialogue move engine toolkit. Natural language engineering, 6(3-4), 323-340. \u21a9 Traum, D. R., & Larsson, S. (2003). The information state approach to dialogue management. In Current and new directions in discourse and dialogue (pp. 325-353). Springer, Dordrecht. \u21a9","title":"Dialog Formalism"},{"location":"formalism.html#predicates","text":"Predicates are used to formalise the meanings of nouns, verbs and adjectives. They typically correspond to slots in form-based (slot-filling) dialog management. Example: selected_contact","title":"Predicates"},{"location":"formalism.html#individuals","text":"Individuals can be arguments of predicates, which corresponds to being values of slots in form-based dialog management. It also aligns with the term \"entity\" used in many other contexts. In TDM, yes and no are modelled as individuals, even if they are not individuals in the concrete sense, but this allows them to be used in answers. Examples: contact_john , which would correspond to John in natural language. yes no","title":"Individuals"},{"location":"formalism.html#actions","text":"An action is something that can be performed. Example: call","title":"Actions"},{"location":"formalism.html#questions","text":"A question is something that can be asked, answered and resolved. Its expression begins with the question operator ? . Yes-no questions A yes-no question is a question that can be answered with a yes or no. Examples: ?need_visa expresses a question regarding whether a visa is needed. ?selected_contact(contact_john) expresses a question regarding whether the selected contact is John. WH questions A WH question is a question about what, when, where etc. It is expressed as a lambda abstraction. Example: ?X.selected_contact(X) expresses a question about which contact to select. Alternative questions An alternative question is a question containing multiple alternative answers expressed as a set of propositions. Example: ?set([number_to_call(home), number_to_call(mobile)]) expresses a question about whether to call the home or mobile number.","title":"Questions"},{"location":"formalism.html#goals","text":"A goal expresses an action to perform or a question to resolve, as elaborated below. Perform goals A perform goal has the form perform(A) where A is an action . Example: perform(call) expresses the goal of performing the action call . Resolve goals A resolve goal has the form resolve(Q) where Q is a question . Example: resolve(?X.phone_number(X)) expresses the goal of resolving the question ?X.phone_number(X) .","title":"Goals"},{"location":"formalism.html#propositions","text":"A proposition expresses something that can be true or false, can be believed to be true, or can be taken as a fact. Propositions have a predicate , a polarity (positive or negative), an arity (nullary or unary) and optionally an argument (an individual , typically). Negative polarity is expressed using the negation operator ~ as prefix. Nullary proposition A nullary proposition has no argument. Examples: need_visa expresses that a visa is needed. ~need_visa expresses that a visa is not needed. Unary propositions A unary proposition takes an individual as an argument. Examples: selected_contact(contact_john) expresses that the selected contact is John. ~selected_contact(contact_john) expresses that the selected contact is not John. Goal propositions A goal proposition expresses that a particular goal should be targeted. It has the form goal(G) where G is a goal . Examples: goal(perform(call)) expresses that the goal of performing call should be targeted. goal(resolve(?X.phone_number(X))) expresses that the goal of resolving ?X.phone_number(X) should be targeted.","title":"Propositions"},{"location":"formalism.html#plans","text":"TBD","title":"Plans"},{"location":"formalism.html#plan-items","text":"A plan item is contained within a dialog plan and expresses an instruction to the dialog manager. TDM supports many different kinds of plan items, the most common of which are described below. Findout A findout item expresses an instruction to find the answer to a question, e.g. by asking the user or asking a service. Example: findout(?X.selected_contact(X)) Invoke service action An invoke_service_action expresses an action to be performed by a service. Example: invoke_service_action(Call, {preconfirm=interrogative, postconfirm=True, downdate_plan=False}) Invoke service query An invoke_service_query expresses an instruction to find the answer to a question by asking a service. Example: invoke_service_query(?X.phone_number(X))","title":"Plan items"},{"location":"formalism.html#moves","text":"(Dialog) moves reflect the meaning and function of something that is communicated in a dialog. Utterances spoken by the user or system correspond to sequences of moves. TDM supports many different kinds of dialog moves, the most common of which are described below. Ask moves An ask move represents the function of an utterance to get the hearer to answer a question. Example: ask(?X.selected_contact(X)) Request moves A request move represents the function of an utterance to get the hearer to perform an action. Example: request(call) Answer moves An answer move represents the function of an utterance to provide an answer to a question, and to commit the speaker to the truth of that answer. The content of an answer can be a proposition (in a so called propositional answer), or an individual (in a so called sortal answer). The individual of a sortal answer combines with a question to form a proposition; for example, the question ?x.selected_name(x) combined with the individual contact_john forms the proposition selected_name(contact_john) . Examples: answer(contact_john) answer(selected_contact(contact_john)) answer(yes) answer(no) Larsson, S. (2002). Issue-based dialogue management. Department of Linguistics, G\u00f6teborg University. \u21a9 Larsson, S., & Traum, D. R. (2000). Information state and dialogue management in the TRINDI dialogue move engine toolkit. Natural language engineering, 6(3-4), 323-340. \u21a9 Traum, D. R., & Larsson, S. (2003). The information state approach to dialogue management. In Current and new directions in discourse and dialogue (pp. 325-353). Springer, Dordrecht. \u21a9","title":"Moves"},{"location":"rasa_nlu.html","text":"For better language coverage of your DDDs, you may want to enable the machine-learning based Rasa NLU. This guide is written for version 0.14.6 of Rasa NLU. Before getting started, make sure to use hosted a Rasa NLU with the necessary dependencies installed. For instance, if you plan on using a Spacy pipeline, ensure that it has the appropriate language models and Spacy itself installed. For more information, read up on the Rasa NLU documentation . We recommend running it in Docker . Generate training data In order to use Rasa NLU with TDM, we need to train the model. The Tala SDK can be used to generate training data for your DDD: tala generate rasa my-ddd eng > training_data.yml . Configure the pipeline The generated training data comes with the spacy_sklearn pipeline by default. At the head of the training data we find: language: \"en\" pipeline: \"spacy_sklearn\" data: | ... Here, the pre-configured spacy_sklearn pipeline will be used, but there are others to choose from too . It's also possible to configure the pipeline oneself, by listing the components explicitly. For instance, this is the spacy_sklearn pipeline: pipeline: - name: \"SpacyNLP\" - name: \"SpacyTokenizer\" - name: \"RegexFeaturizer\" - name: \"SpacyFeaturizer\" - name: \"CRFEntityExtractor\" - name: \"EntitySynonymMapper\" - name: \"SklearnIntentClassifier\" Add pre-trained named entity recognizers (NERs) Rasa NLU supports pre-trained NERs to be part of the pipeline, for instance the NERs from Duckling and Spacy which can be used together with TDM. Duckling In this version of TDM, the following Duckling entities are supported: - number : maps to the integer sort. - time : maps to the datetime sort. To enable Duckling, make sure it's available to the Rasa server and add its component to an explicit pipeline: - name: \"DucklingHTTPExtractor\" url: \"http://duckling:8000\" Here, Duckling is available to the Rasa server at http://duckling:8000 . The spacy_sklearn pipeline with the addition of Duckling then becomes: pipeline: - name: \"SpacyNLP\" - name: \"SpacyTokenizer\" - name: \"RegexFeaturizer\" - name: \"SpacyFeaturizer\" - name: \"CRFEntityExtractor\" - name: \"EntitySynonymMapper\" - name: \"SklearnIntentClassifier\" - name: \"DucklingHTTPExtractor\" url: \"http://duckling:8000\" Spacy In this version of TDM, the following Spacy entity types are supported: - PERSON and PER : map to the person_name sort. To enable Spacy, make sure it's available to the Rasa server and use a pipeline that contains SpacyEntityExtractor , e.g. pipeline: - name: \"SpacyNLP\" - name: \"SpacyTokenizer\" - name: \"RegexFeaturizer\" - name: \"SpacyFeaturizer\" - name: \"CRFEntityExtractor\" - name: \"EntitySynonymMapper\" - name: \"SklearnIntentClassifier\" - name: \"SpacyEntityExtractor\" Train the model Once the training data and pipeline are configured, train your model according to the Rasa NLU HTTP API . For instance with: curl -XPOST -H 'Content-Type: application/x-yml' 'http://my-rasa-nlu.my-cloud.com:5000/train?project=my-ddd&model=my-model' --data-binary @training_data.yml In this case, the URL, project and model also need to be specified in the DDD config in the next step. Configure the DDD Make sure to configure Rasa NLU in the DDD config, for instance at my_ddd/ddd.config.json , by adding language specific rasa_nlu objects. For instance, for English: { \"rasa_nlu\": { \"eng\": { \"url\": \"http://my-rasa-nlu.my-cloud.com:5000/parse\", \"config\": { \"project\": \"my-ddd\", \"model\": \"my-model\" } } } } The rasa_nlu object contains the following fields: url : A string URL, pointing to the /parse endpoint of a Rasa NLU server . config : An object sent in the JSON payload when TDM posts it to the url . It can contain for instance project and model , as specified by the Rasa NLU HTTP API . TDM also adds the field \"q\": \"<user utterance>\" . If Rasa NLU should not be used for a particular language, remove the language altogether: { \"rasa_nlu\": {} }","title":"Using Rasa NLU"},{"location":"rasa_nlu.html#generate-training-data","text":"In order to use Rasa NLU with TDM, we need to train the model. The Tala SDK can be used to generate training data for your DDD: tala generate rasa my-ddd eng > training_data.yml .","title":"Generate training data"},{"location":"rasa_nlu.html#configure-the-pipeline","text":"The generated training data comes with the spacy_sklearn pipeline by default. At the head of the training data we find: language: \"en\" pipeline: \"spacy_sklearn\" data: | ... Here, the pre-configured spacy_sklearn pipeline will be used, but there are others to choose from too . It's also possible to configure the pipeline oneself, by listing the components explicitly. For instance, this is the spacy_sklearn pipeline: pipeline: - name: \"SpacyNLP\" - name: \"SpacyTokenizer\" - name: \"RegexFeaturizer\" - name: \"SpacyFeaturizer\" - name: \"CRFEntityExtractor\" - name: \"EntitySynonymMapper\" - name: \"SklearnIntentClassifier\"","title":"Configure the pipeline"},{"location":"rasa_nlu.html#add-pre-trained-named-entity-recognizers-ners","text":"Rasa NLU supports pre-trained NERs to be part of the pipeline, for instance the NERs from Duckling and Spacy which can be used together with TDM.","title":"Add pre-trained named entity recognizers (NERs)"},{"location":"rasa_nlu.html#duckling","text":"In this version of TDM, the following Duckling entities are supported: - number : maps to the integer sort. - time : maps to the datetime sort. To enable Duckling, make sure it's available to the Rasa server and add its component to an explicit pipeline: - name: \"DucklingHTTPExtractor\" url: \"http://duckling:8000\" Here, Duckling is available to the Rasa server at http://duckling:8000 . The spacy_sklearn pipeline with the addition of Duckling then becomes: pipeline: - name: \"SpacyNLP\" - name: \"SpacyTokenizer\" - name: \"RegexFeaturizer\" - name: \"SpacyFeaturizer\" - name: \"CRFEntityExtractor\" - name: \"EntitySynonymMapper\" - name: \"SklearnIntentClassifier\" - name: \"DucklingHTTPExtractor\" url: \"http://duckling:8000\"","title":"Duckling"},{"location":"rasa_nlu.html#spacy","text":"In this version of TDM, the following Spacy entity types are supported: - PERSON and PER : map to the person_name sort. To enable Spacy, make sure it's available to the Rasa server and use a pipeline that contains SpacyEntityExtractor , e.g. pipeline: - name: \"SpacyNLP\" - name: \"SpacyTokenizer\" - name: \"RegexFeaturizer\" - name: \"SpacyFeaturizer\" - name: \"CRFEntityExtractor\" - name: \"EntitySynonymMapper\" - name: \"SklearnIntentClassifier\" - name: \"SpacyEntityExtractor\"","title":"Spacy"},{"location":"rasa_nlu.html#train-the-model","text":"Once the training data and pipeline are configured, train your model according to the Rasa NLU HTTP API . For instance with: curl -XPOST -H 'Content-Type: application/x-yml' 'http://my-rasa-nlu.my-cloud.com:5000/train?project=my-ddd&model=my-model' --data-binary @training_data.yml In this case, the URL, project and model also need to be specified in the DDD config in the next step.","title":"Train the model"},{"location":"rasa_nlu.html#configure-the-ddd","text":"Make sure to configure Rasa NLU in the DDD config, for instance at my_ddd/ddd.config.json , by adding language specific rasa_nlu objects. For instance, for English: { \"rasa_nlu\": { \"eng\": { \"url\": \"http://my-rasa-nlu.my-cloud.com:5000/parse\", \"config\": { \"project\": \"my-ddd\", \"model\": \"my-model\" } } } } The rasa_nlu object contains the following fields: url : A string URL, pointing to the /parse endpoint of a Rasa NLU server . config : An object sent in the JSON payload when TDM posts it to the url . It can contain for instance project and model , as specified by the Rasa NLU HTTP API . TDM also adds the field \"q\": \"<user utterance>\" . If Rasa NLU should not be used for a particular language, remove the language altogether: { \"rasa_nlu\": {} }","title":"Configure the DDD"},{"location":"tutorial.html","text":"Step 1. Create the boilerplate First we need to create the DDD boilerplate. mkdir ddd_root; cd ddd_root tdm create-ddd basic_action Before your DDD can be used, it needs to be built. tdm build To make sure your DDD and all dependencies are working as intended, let's run interaction tests. tdm test eng Ran 1 test in 0.386s OK The test reports OK. We're ready to start adding dialogue to our DDD. Step 2. Interaction test Since we're working test driven, let's add an interaction test first. Interaction tests verifiy the dialogue, providing user utterances and specifying the expected system responses. Modify basic_action/test/interaction_tests_eng.txt , add a test for the new dialogue that we want to support. We proceed one step at a time, starting with a very simple dialogue. --- call S> What would you like to do? U> call S> Who do you want to call? Let's run the tests again to verify that they fail. (We don't need to rebuild after only modifying tests.) tdm test eng TDM will complain that it does not understand instead the user. On line 7 of basic_action/test/interaction_tests_eng.txt, expected: S> Who do you want to call? but got: S> I heard you say call. I don't understand. So, What would you like to do? This happens because there's no notion of calling in the DDD. Step 3. Ontology The ontology declares what users can do and talk about, much like header files. In order to call someone we need to add the notion of calling, and the notion of people, to the ontology. Our boilerplate ontology is basically empty, in basic_action/ontology.xml . <?xml version=\"1.0\" encoding=\"utf-8\"?> <ontology name=\"BasicActionOntology\"> </ontology> We extend it with an action to make calls: <?xml version=\"1.0\" encoding=\"utf-8\"?> <ontology name=\"BasicActionOntology\"> <action name=\"call\"/> </ontology> Let's build and run the tests again to see if we missed something. tdm build We now receive a warning. Generating models for DDD 'basic_action'. [eng] Cleaning build directory 'build/eng'...Done. [eng] Generating grammar. Missing grammar entry: How do speakers talk about the action 'call'? Possible contents of the <action> element: <verb-phrase> <noun-phrase> <one-of> [eng] Finished generating grammar. Finished generating models for DDD 'basic_action'. Training models for DDD 'basic_action'. [eng] Asserting that language grammar is lower case...Done. [eng] Compiling generated grammar. [eng] Finished compiling generated grammar. [eng] No ASR specified, will not build language model. [eng] Copying ASR language modules from '/private/tmp/ddd_root/basic_action/grammar/build/eng' to ddd directory...Done. [eng] Not using word list correction, will not generate word list. Apparently, ontology entries require their corresponding grammar entries. Step 4. Grammar The grammar defines what our users and system can say. Our previous build attempt told us to add an entry for the call action. Let's extend basic_action/grammar/grammar_eng.xml with the call action. <?xml version=\"1.0\" encoding=\"utf-8\"?> <grammar> <action name=\"call\"> <verb-phrase> <verb ref=\"call\"/> </verb-phrase> </action> <lexicon> <verb id=\"call\"> <infinitive>call</infinitive> </verb> </lexicon> </grammar> This grammar definition describes that the action call can be referenced with a verb phrase containing the verb call . It also contains a lexicon describing the grammar of call in English. We only need to specifiy the infinitive form for the verb; the other forms, such as imperative, are derived automatically. Let's build and test. tdm build tdm test eng On line 7 of basic_action/test/interaction_tests_eng.txt, expected: S> Who do you want to call? but got: S> The function is not implemented. TDM replies! It means we did something right but apparently we need to implement the functionality as well. We need to add a plan for calling. Step 5. Plan Plans group together what our users can talk about. The plan is executed in order to reach a goal, for example to perform an action. When talking about something in the plan, TDM infers which goal is being implied and puts it at the top of the agenda. Let's check the boilerplate, in basic_action/domain.xml . <?xml version=\"1.0\" encoding=\"utf-8\"?> <domain name=\"BasicActionDomain\" is_super_domain=\"true\"> <goal type=\"perform\" action=\"top\"> <plan> <forget_all/> <findout type=\"goal\"/> </plan> </goal> </domain> We get the top goal for free. This is the only goal on TDM's agenda at startup. It will make TDM ask us which goal we want to achieve. Remember the corresponding default interaction test. --- main menu S> What would you like to do? Anyway, let's add a new goal and plan, corresponding to our call action. Extend the domain. <?xml version=\"1.0\" encoding=\"utf-8\"?> <domain name=\"BasicActionDomain\" is_super_domain=\"true\"> <goal type=\"perform\" action=\"top\"> <plan> <forget_all/> <findout type=\"goal\"/> </plan> </goal> <goal type=\"perform\" action=\"call\"> <plan> <findout type=\"wh_question\" predicate=\"selected_contact\"/> <invoke_service_action name=\"Call\" postconfirm=\"true\"/> </plan> </goal> </domain> In ontology.xml , we also need to add the selected_contact predicate and its sort: <?xml version=\"1.0\" encoding=\"utf-8\"?> <ontology name=\"BasicActionOntology\"> <action name=\"call\"/> <sort name=\"contact\" dynamic=\"true\"/> <predicate name=\"selected_contact\" sort=\"contact\"/> </ontology> A dynamic sort means its individuals are decided during run time, through the service interface. Now build the DDD. tdm build Generating models for DDD 'basic_action'. [eng] Cleaning build directory 'build/eng'...Done. [eng] Generating grammar. Missing grammar entry: How does the system ask about 'selected_contact'? Example: <question speaker=\"system\" predicate=\"selected_contact\" type=\"wh_question\"> <utterance>what is selected contact</utterance> </question> [eng] Finished generating grammar. Finished generating models for DDD 'basic_action'. Training models for DDD 'basic_action'. [eng] Asserting that language grammar is lower case...Done. [eng] Compiling generated grammar. [eng] Finished compiling generated grammar. [eng] No ASR specified, will not build language model. [eng] Copying ASR language modules from '/private/tmp/ddd_root/basic_action/grammar/build/eng' to ddd directory...Done. [eng] Not using word list correction, will not generate word list. We got a new warning about a missing grammar entry. When referencing a predicate in a plan, we apparently need to specify its grammar entry. Since we're using a findout, the grammar entry is to define how TDM should speak the corresponding question . Let's extend basic_action/grammar/grammar_eng.xml with the following: <question speaker=\"system\" predicate=\"selected_contact\" type=\"wh_question\"> <utterance>who do you want to call</utterance> </question> Build and test. tdm build tdm test eng Ran 2 tests in 0.363s OK Everything works as expected. Step 6. Service interface In the next step, we want the user to be able to reply to the question about who to call. We thus extend basic_action/test/interaction_tests_eng.txt accordingly: --- call S> What would you like to do? U> call S> Who do you want to call? U> John S> Calling John. Test: tdm test eng On line 9 of basic_action/test/interaction_tests_eng.txt, expected: S> Calling John. but got: S> I heard you say John. I don't understand. So, Who do you want to call? As can be seen, the system doesn't understand John. We need to add an entity recognizer to our service interface. It needs to recognize entities of our contact sort. Our boilerplate service interface is basically empty, in basic_action/service_interface.xml , so let's just add it. <?xml version=\"1.0\" encoding=\"utf-8\"?> <service_interface> <entity_recognizer name=\"BasicActionRecognizer\"> <target> <http endpoint=\"http://127.0.0.1:10102/contact_recognizer\"/> </target> </entity_recognizer> </service_interface> Here, we use an HTTP target with an end-point that runs an HTTP service. An HTTP service can be hosted anywhere where TDM can reach it. In this tutorial, we assume that the service is hosted locally, i.e. on the same machine as TDM (127.0.0.1), but this is not required. Generally, the developer can choose any web development framework as long as it is within the constraints of the HTTP service API protocol . The entity recognizer is responsible for finding all dynamic entities in utterances. Its accuracy affects the behaviour of the dialogue system. Since the search is conducted during runtime, particular care should be taken to ensure that the method is accurate, robust and has sufficient performance. See the API documentation for details about request and response formats for entity recognizers. In this case, we are providing you with a ready-to-use HTTP service , which includes an entity recognizer. It uses Flask web framework and jinja2 templates in plain python. As the service is hosted locally in this case, we recommend to save it in the DDD folder basic_action . Then, spawn it with Flask: export FLASK_APP=basic_action/http_service_example.py flask run --port=10102 And then, build and test. tdm build tdm test eng UnexpectedActionException: Expected one of the known actions [] but got 'Call' Great, TDM appears to understand John. It wants to execute the Call action using our service interface, but could not find it. Let's add it to basic_action/service_interface.xml . <?xml version=\"1.0\" encoding=\"utf-8\"?> <service_interface> <action name=\"Call\"> <parameters> <parameter predicate=\"selected_contact\" format=\"value\"/> </parameters> <failure_reasons/> <target> <http endpoint=\"http://127.0.0.1:10102/call\"/> </target> </action> <entity_recognizer name=\"BasicActionRecognizer\"> <target> <http endpoint=\"http://127.0.0.1:10102/contact_recognizer\"/> </target> </entity_recognizer> </service_interface> To implement the 'call' action, see the API documentation for details about request and response formats for actions. However, you can also find and use the 'call' action that has been already implemented in the example HTTP service. Build again. tdm build Generating models for DDD 'basic_action'. [eng] Cleaning build directory 'build/eng'...Done. [eng] Generating grammar. Missing grammar entry: How does the system report that the service action 'Call' ended? Example: <report action=\"Call\" status=\"ended\"> <utterance>performed Call</utterance> </report> [eng] Finished generating grammar. Finished generating models for DDD 'basic_action'. Training models for DDD 'basic_action'. [eng] Asserting that language grammar is lower case...Done. [eng] Compiling generated grammar. [eng] Finished compiling generated grammar. [eng] No ASR specified, will not build language model. [eng] Copying ASR language modules from '/private/tmp/ddd_root/basic_action/grammar/build/eng' to ddd directory...Done. [eng] Not using word list correction, will not generate word list. As can be seen, we need to add a grammar entry for the service action Call . This is required because we said so in the plan. Remember postconfirm=\"true\" in the invoke_service_action entry of the plan? Let's add a report grammar entry in basic_action/grammar/grammar_eng.xml . We can reference the selected_contact predicate since its part of the findout entries of the plan. <report action=\"Call\" status=\"ended\"> <utterance>calling <individual predicate=\"selected_contact\"/></utterance> </report> Build and test. tdm build tdm test eng Ran 2 tests in 0.363s OK Success! Step 7. One-shot utterances The DDD so far handles very simple dialogues where the user enters one piece of information at a time. In order to support one-shot utterances such as \"call John\" containing several pieces of information (in this case an action and an answer regarding who to call), we need to extend the grammar. First we add a failing interaction test in basic_action/test/interaction_tests_eng.txt : --- one-shot utterance U> call John S> Calling John. Run the tests to verify that the new one fails. tdm test eng On line 13 of basic_action/test/interaction_tests_eng.txt, expected: S> Calling John. but got: S> I heard you say call John. I don't understand. So, What would you like to do? We now add the following lines to basic_action/grammar/grammar_eng.xml : <request action=\"call\"> <utterance>call <individual sort=\"contact\"/></utterance> </request> The element <request> is used when defining things that the user can say to request that an action is to be performed. In contrast to <action> , <request> is user-specific and deals with whole utterances, including potential references to individuals. The element <individual> acts as a slot, showing that a certain place in the utterance refers to an individual. Now build and test. tdm build tdm test eng Ran 3 tests in 0.523s OK Step 8. Adding a language If you want to add support for a new language, the following steps are needed. First you need to modify the file backend.config.json . In the field supported_languages , add \"fre\" for French and/or \"dut\" for Dutch (separated by commas). Assuming we want to add support for French, the file contents are changed to { \"supported_languages\": [ \"eng\", \"fre\" ] } Second, we need to create interaction tests for the new language. For French, we add the file basic_action/test/interaction_tests_fre.txt with translated contents: --- main menu S> Que voulez-vous faire? --- call S> Que voulez-vous faire? U> appellez S> Qui voulez-vous appeler? U> Andr\u00e9 S> J'appelle Andr\u00e9. --- one-shot utterance U> appellez Andr\u00e9 S> J'appelle Andr\u00e9. Make sure to save the interaction tests with UTF-8 encoding without byte-order mark (BOM) when using non-ASCII characters. Check our HTTP service to see that name of the contacts are already there translated in French (and even Dutch): CONTACTS_FRENCH = { \"Jean\": JOHN, u\"\u00c9lise\": LISA, \"Marie\": MARY, u\"Andr\u00e9\": ANDY, } CONTACTS_DUTCH = { \"Jan\": JOHN, \"Lisa\": LISA, \"Maria\": MARY, \"Andreas\": ANDY, } Finally, we need to create a grammar file for the new language. For French, we add the file basic_action/grammar/grammar_fre.xml with the following contents: <?xml version=\"1.0\" encoding=\"utf-8\"?> <grammar> <action name=\"call\"> <verb-phrase> <verb ref=\"call\"/> </verb-phrase> </action> <request action=\"call\"> <utterance>appellez <individual sort=\"contact\"/></utterance> </request> <lexicon> <verb id=\"call\"> <infinitive>appeller</infinitive> </verb> </lexicon> <question speaker=\"system\" predicate=\"selected_contact\" type=\"wh_question\"> <utterance>qui voulez-vous appeler</utterance> </question> <report action=\"Call\" status=\"ended\"> <utterance>j'appelle <individual predicate=\"selected_contact\"/></utterance> </report> </grammar> Build and test. Note the changed language parameter for interaction testing. tdm build tdm test fre Ran 3 tests in 0.509s OK Step 9. How to continue This tutorial has illustrated how to implement the basic action example . The source code is available on Github . In order to continue, go to the examples section to find an example similar to your desired functionality. Steal the best ideas from there, adjusting them for yor domain. Remember to work test driven, adding a test first, then making it work.","title":"Step-by-step tutorial"},{"location":"tutorial.html#step-1-create-the-boilerplate","text":"First we need to create the DDD boilerplate. mkdir ddd_root; cd ddd_root tdm create-ddd basic_action Before your DDD can be used, it needs to be built. tdm build To make sure your DDD and all dependencies are working as intended, let's run interaction tests. tdm test eng Ran 1 test in 0.386s OK The test reports OK. We're ready to start adding dialogue to our DDD.","title":"Step 1. Create the boilerplate"},{"location":"tutorial.html#step-2-interaction-test","text":"Since we're working test driven, let's add an interaction test first. Interaction tests verifiy the dialogue, providing user utterances and specifying the expected system responses. Modify basic_action/test/interaction_tests_eng.txt , add a test for the new dialogue that we want to support. We proceed one step at a time, starting with a very simple dialogue. --- call S> What would you like to do? U> call S> Who do you want to call? Let's run the tests again to verify that they fail. (We don't need to rebuild after only modifying tests.) tdm test eng TDM will complain that it does not understand instead the user. On line 7 of basic_action/test/interaction_tests_eng.txt, expected: S> Who do you want to call? but got: S> I heard you say call. I don't understand. So, What would you like to do? This happens because there's no notion of calling in the DDD.","title":"Step 2. Interaction test"},{"location":"tutorial.html#step-3-ontology","text":"The ontology declares what users can do and talk about, much like header files. In order to call someone we need to add the notion of calling, and the notion of people, to the ontology. Our boilerplate ontology is basically empty, in basic_action/ontology.xml . <?xml version=\"1.0\" encoding=\"utf-8\"?> <ontology name=\"BasicActionOntology\"> </ontology> We extend it with an action to make calls: <?xml version=\"1.0\" encoding=\"utf-8\"?> <ontology name=\"BasicActionOntology\"> <action name=\"call\"/> </ontology> Let's build and run the tests again to see if we missed something. tdm build We now receive a warning. Generating models for DDD 'basic_action'. [eng] Cleaning build directory 'build/eng'...Done. [eng] Generating grammar. Missing grammar entry: How do speakers talk about the action 'call'? Possible contents of the <action> element: <verb-phrase> <noun-phrase> <one-of> [eng] Finished generating grammar. Finished generating models for DDD 'basic_action'. Training models for DDD 'basic_action'. [eng] Asserting that language grammar is lower case...Done. [eng] Compiling generated grammar. [eng] Finished compiling generated grammar. [eng] No ASR specified, will not build language model. [eng] Copying ASR language modules from '/private/tmp/ddd_root/basic_action/grammar/build/eng' to ddd directory...Done. [eng] Not using word list correction, will not generate word list. Apparently, ontology entries require their corresponding grammar entries.","title":"Step 3. Ontology"},{"location":"tutorial.html#step-4-grammar","text":"The grammar defines what our users and system can say. Our previous build attempt told us to add an entry for the call action. Let's extend basic_action/grammar/grammar_eng.xml with the call action. <?xml version=\"1.0\" encoding=\"utf-8\"?> <grammar> <action name=\"call\"> <verb-phrase> <verb ref=\"call\"/> </verb-phrase> </action> <lexicon> <verb id=\"call\"> <infinitive>call</infinitive> </verb> </lexicon> </grammar> This grammar definition describes that the action call can be referenced with a verb phrase containing the verb call . It also contains a lexicon describing the grammar of call in English. We only need to specifiy the infinitive form for the verb; the other forms, such as imperative, are derived automatically. Let's build and test. tdm build tdm test eng On line 7 of basic_action/test/interaction_tests_eng.txt, expected: S> Who do you want to call? but got: S> The function is not implemented. TDM replies! It means we did something right but apparently we need to implement the functionality as well. We need to add a plan for calling.","title":"Step 4. Grammar"},{"location":"tutorial.html#step-5-plan","text":"Plans group together what our users can talk about. The plan is executed in order to reach a goal, for example to perform an action. When talking about something in the plan, TDM infers which goal is being implied and puts it at the top of the agenda. Let's check the boilerplate, in basic_action/domain.xml . <?xml version=\"1.0\" encoding=\"utf-8\"?> <domain name=\"BasicActionDomain\" is_super_domain=\"true\"> <goal type=\"perform\" action=\"top\"> <plan> <forget_all/> <findout type=\"goal\"/> </plan> </goal> </domain> We get the top goal for free. This is the only goal on TDM's agenda at startup. It will make TDM ask us which goal we want to achieve. Remember the corresponding default interaction test. --- main menu S> What would you like to do? Anyway, let's add a new goal and plan, corresponding to our call action. Extend the domain. <?xml version=\"1.0\" encoding=\"utf-8\"?> <domain name=\"BasicActionDomain\" is_super_domain=\"true\"> <goal type=\"perform\" action=\"top\"> <plan> <forget_all/> <findout type=\"goal\"/> </plan> </goal> <goal type=\"perform\" action=\"call\"> <plan> <findout type=\"wh_question\" predicate=\"selected_contact\"/> <invoke_service_action name=\"Call\" postconfirm=\"true\"/> </plan> </goal> </domain> In ontology.xml , we also need to add the selected_contact predicate and its sort: <?xml version=\"1.0\" encoding=\"utf-8\"?> <ontology name=\"BasicActionOntology\"> <action name=\"call\"/> <sort name=\"contact\" dynamic=\"true\"/> <predicate name=\"selected_contact\" sort=\"contact\"/> </ontology> A dynamic sort means its individuals are decided during run time, through the service interface. Now build the DDD. tdm build Generating models for DDD 'basic_action'. [eng] Cleaning build directory 'build/eng'...Done. [eng] Generating grammar. Missing grammar entry: How does the system ask about 'selected_contact'? Example: <question speaker=\"system\" predicate=\"selected_contact\" type=\"wh_question\"> <utterance>what is selected contact</utterance> </question> [eng] Finished generating grammar. Finished generating models for DDD 'basic_action'. Training models for DDD 'basic_action'. [eng] Asserting that language grammar is lower case...Done. [eng] Compiling generated grammar. [eng] Finished compiling generated grammar. [eng] No ASR specified, will not build language model. [eng] Copying ASR language modules from '/private/tmp/ddd_root/basic_action/grammar/build/eng' to ddd directory...Done. [eng] Not using word list correction, will not generate word list. We got a new warning about a missing grammar entry. When referencing a predicate in a plan, we apparently need to specify its grammar entry. Since we're using a findout, the grammar entry is to define how TDM should speak the corresponding question . Let's extend basic_action/grammar/grammar_eng.xml with the following: <question speaker=\"system\" predicate=\"selected_contact\" type=\"wh_question\"> <utterance>who do you want to call</utterance> </question> Build and test. tdm build tdm test eng Ran 2 tests in 0.363s OK Everything works as expected.","title":"Step 5. Plan"},{"location":"tutorial.html#step-6-service-interface","text":"In the next step, we want the user to be able to reply to the question about who to call. We thus extend basic_action/test/interaction_tests_eng.txt accordingly: --- call S> What would you like to do? U> call S> Who do you want to call? U> John S> Calling John. Test: tdm test eng On line 9 of basic_action/test/interaction_tests_eng.txt, expected: S> Calling John. but got: S> I heard you say John. I don't understand. So, Who do you want to call? As can be seen, the system doesn't understand John. We need to add an entity recognizer to our service interface. It needs to recognize entities of our contact sort. Our boilerplate service interface is basically empty, in basic_action/service_interface.xml , so let's just add it. <?xml version=\"1.0\" encoding=\"utf-8\"?> <service_interface> <entity_recognizer name=\"BasicActionRecognizer\"> <target> <http endpoint=\"http://127.0.0.1:10102/contact_recognizer\"/> </target> </entity_recognizer> </service_interface> Here, we use an HTTP target with an end-point that runs an HTTP service. An HTTP service can be hosted anywhere where TDM can reach it. In this tutorial, we assume that the service is hosted locally, i.e. on the same machine as TDM (127.0.0.1), but this is not required. Generally, the developer can choose any web development framework as long as it is within the constraints of the HTTP service API protocol . The entity recognizer is responsible for finding all dynamic entities in utterances. Its accuracy affects the behaviour of the dialogue system. Since the search is conducted during runtime, particular care should be taken to ensure that the method is accurate, robust and has sufficient performance. See the API documentation for details about request and response formats for entity recognizers. In this case, we are providing you with a ready-to-use HTTP service , which includes an entity recognizer. It uses Flask web framework and jinja2 templates in plain python. As the service is hosted locally in this case, we recommend to save it in the DDD folder basic_action . Then, spawn it with Flask: export FLASK_APP=basic_action/http_service_example.py flask run --port=10102 And then, build and test. tdm build tdm test eng UnexpectedActionException: Expected one of the known actions [] but got 'Call' Great, TDM appears to understand John. It wants to execute the Call action using our service interface, but could not find it. Let's add it to basic_action/service_interface.xml . <?xml version=\"1.0\" encoding=\"utf-8\"?> <service_interface> <action name=\"Call\"> <parameters> <parameter predicate=\"selected_contact\" format=\"value\"/> </parameters> <failure_reasons/> <target> <http endpoint=\"http://127.0.0.1:10102/call\"/> </target> </action> <entity_recognizer name=\"BasicActionRecognizer\"> <target> <http endpoint=\"http://127.0.0.1:10102/contact_recognizer\"/> </target> </entity_recognizer> </service_interface> To implement the 'call' action, see the API documentation for details about request and response formats for actions. However, you can also find and use the 'call' action that has been already implemented in the example HTTP service. Build again. tdm build Generating models for DDD 'basic_action'. [eng] Cleaning build directory 'build/eng'...Done. [eng] Generating grammar. Missing grammar entry: How does the system report that the service action 'Call' ended? Example: <report action=\"Call\" status=\"ended\"> <utterance>performed Call</utterance> </report> [eng] Finished generating grammar. Finished generating models for DDD 'basic_action'. Training models for DDD 'basic_action'. [eng] Asserting that language grammar is lower case...Done. [eng] Compiling generated grammar. [eng] Finished compiling generated grammar. [eng] No ASR specified, will not build language model. [eng] Copying ASR language modules from '/private/tmp/ddd_root/basic_action/grammar/build/eng' to ddd directory...Done. [eng] Not using word list correction, will not generate word list. As can be seen, we need to add a grammar entry for the service action Call . This is required because we said so in the plan. Remember postconfirm=\"true\" in the invoke_service_action entry of the plan? Let's add a report grammar entry in basic_action/grammar/grammar_eng.xml . We can reference the selected_contact predicate since its part of the findout entries of the plan. <report action=\"Call\" status=\"ended\"> <utterance>calling <individual predicate=\"selected_contact\"/></utterance> </report> Build and test. tdm build tdm test eng Ran 2 tests in 0.363s OK Success!","title":"Step 6. Service interface"},{"location":"tutorial.html#step-7-one-shot-utterances","text":"The DDD so far handles very simple dialogues where the user enters one piece of information at a time. In order to support one-shot utterances such as \"call John\" containing several pieces of information (in this case an action and an answer regarding who to call), we need to extend the grammar. First we add a failing interaction test in basic_action/test/interaction_tests_eng.txt : --- one-shot utterance U> call John S> Calling John. Run the tests to verify that the new one fails. tdm test eng On line 13 of basic_action/test/interaction_tests_eng.txt, expected: S> Calling John. but got: S> I heard you say call John. I don't understand. So, What would you like to do? We now add the following lines to basic_action/grammar/grammar_eng.xml : <request action=\"call\"> <utterance>call <individual sort=\"contact\"/></utterance> </request> The element <request> is used when defining things that the user can say to request that an action is to be performed. In contrast to <action> , <request> is user-specific and deals with whole utterances, including potential references to individuals. The element <individual> acts as a slot, showing that a certain place in the utterance refers to an individual. Now build and test. tdm build tdm test eng Ran 3 tests in 0.523s OK","title":"Step 7. One-shot utterances"},{"location":"tutorial.html#step-8-adding-a-language","text":"If you want to add support for a new language, the following steps are needed. First you need to modify the file backend.config.json . In the field supported_languages , add \"fre\" for French and/or \"dut\" for Dutch (separated by commas). Assuming we want to add support for French, the file contents are changed to { \"supported_languages\": [ \"eng\", \"fre\" ] } Second, we need to create interaction tests for the new language. For French, we add the file basic_action/test/interaction_tests_fre.txt with translated contents: --- main menu S> Que voulez-vous faire? --- call S> Que voulez-vous faire? U> appellez S> Qui voulez-vous appeler? U> Andr\u00e9 S> J'appelle Andr\u00e9. --- one-shot utterance U> appellez Andr\u00e9 S> J'appelle Andr\u00e9. Make sure to save the interaction tests with UTF-8 encoding without byte-order mark (BOM) when using non-ASCII characters. Check our HTTP service to see that name of the contacts are already there translated in French (and even Dutch): CONTACTS_FRENCH = { \"Jean\": JOHN, u\"\u00c9lise\": LISA, \"Marie\": MARY, u\"Andr\u00e9\": ANDY, } CONTACTS_DUTCH = { \"Jan\": JOHN, \"Lisa\": LISA, \"Maria\": MARY, \"Andreas\": ANDY, } Finally, we need to create a grammar file for the new language. For French, we add the file basic_action/grammar/grammar_fre.xml with the following contents: <?xml version=\"1.0\" encoding=\"utf-8\"?> <grammar> <action name=\"call\"> <verb-phrase> <verb ref=\"call\"/> </verb-phrase> </action> <request action=\"call\"> <utterance>appellez <individual sort=\"contact\"/></utterance> </request> <lexicon> <verb id=\"call\"> <infinitive>appeller</infinitive> </verb> </lexicon> <question speaker=\"system\" predicate=\"selected_contact\" type=\"wh_question\"> <utterance>qui voulez-vous appeler</utterance> </question> <report action=\"Call\" status=\"ended\"> <utterance>j'appelle <individual predicate=\"selected_contact\"/></utterance> </report> </grammar> Build and test. Note the changed language parameter for interaction testing. tdm build tdm test fre Ran 3 tests in 0.509s OK","title":"Step 8. Adding a language"},{"location":"tutorial.html#step-9-how-to-continue","text":"This tutorial has illustrated how to implement the basic action example . The source code is available on Github . In order to continue, go to the examples section to find an example similar to your desired functionality. Steal the best ideas from there, adjusting them for yor domain. Remember to work test driven, adding a test first, then making it work.","title":"Step 9. How to continue"},{"location":"APIs/http_frontend.html","text":"This document describes API version 3.3 for HTTP frontends, enabling frontends to integrate with TDM over HTTP. It covers e.g. how input from the user and output from TDM are communicated between TDM and the client. Important concepts This section describes some concepts that are important to understand and comply with when integrating TDM in a dialog system. Requests and responses TDM serves an HTTP server and responds to requests done by the client. The client is the consumer of the API outlined in this document. The client invokes TDM with an HTTP request to the interaction endpoint, e.g. http://localhost:9090/interact , using the POST method and a JSON body. The client should expect the status code to be 200 OK. For other status codes, the client should report an error to the user. The request body always contains a version number, specifying the version of the HTTP API format. The exact format of the request and the response depends on the type of request as described in the separate sections below. Turn management Turn management is a vital part of dialog between humans, read for instance the Wikipedia article . Since TDM is based on research on human-human dialog, turn management is a central concept here too. The TDM client is responsible for turn management, because it's the component that is closest to the human in the human-machine dialog that TDM enables. Since the machine is intended to assist the human, the human decides the pace, the turn taking, of the conversation. In spoken dialog, turn taking happens in close collaboration with the spoken output of the system, which means that the system's turn management needs to happen as close to this component, the text-to-speech component (TTS), as possible. TDM enables intuitive turn taking by instructing its client how to deal with the user input that it's range of sensors can pick up. The instructions are straightforward and revolve around passivity. If the user is passive, for instance doesn't know what to say, for a given amount of time, the client sends TDM a passivity request , which lets the system take the next turn instead of the user. The user should be considered passive when not doing anything related to the dialog. If the user however takes some action (although not completing its turn just yet), for instance by typing (if it's a text interface) or talking (if it's a spoken interface), the user should be considered active and the passivity request should not be sent to TDM. Instead the user should be allowed to complete its turn, resulting in an input request. TDM instructs its client about how long time of passivity that should pass before sending the passivity request in the output.expected_passivity field of the response . For instance, if TDM responds with: { \"output\": { ... \"expected_passivity\": 1.0 }, ... } then the client should send a passivity request when the user has been passive for 1 second. The 1 second should start counting when the system utterance has reached the user, which in a spoken interface means when the TTS finished speaking TDM's utterance. Note that sometimes TDM does not have anything to say when the user becomes passive ( \"expected_passivity\": null ), and sometimes it just needs to progress the conversation immediately after saying something ( \"expected_passivity\": 0.0 ). Read the details about how to interpret the expected_passivity value in the response format section . Errors When an error occurs in TDM during a request, for instance due to incomplete turn management, the response contains the \"error\" field. It's important to note that this could mean that the session stops. If it has stopped, further requests on the same session will report errors that the provided session ID is unknown. Start session requests When a new session should be started, the client issues a start_session request. The response contains initial output from TDM and a session ID that can be used in subsequent requests. For more details, see the response format . If a session ID is provided together with the start_session request, an error is given. The integrity of the session is however maintained. Request Example: { \"version\": \"3.3\", \"session\": {}, \"request\": { \"start_session\": {} } } The session object can contain frontend-specific session data to be used in dialog or by services. For more details, see the session object The start_session object may contain the following optional members: ddd_set : A string specifying a DDD set for the session. If omitted, a default DDD set configured by the backend is used. The start_session request may be issued on its own, so that the system will start the conversation; or combined with natural_language_input , semantic_input and event requests to start the conversation from there. Example when combined with natural_language_input : { \"version\": \"3.3\", \"request\": { \"start_session\": {}, \"natural_language_input\": {...} } } Response See response format . Natural language input requests When the client detects natural language input from the user, it issues a request and receives output from TDM. The request can contain either hypotheses with the speech modality, or a single utterance with the text modality. Request Speech input example: { \"version\": \"3.3\", \"session\": { \"session_id\": \"0000-abcd-1111-efgh\" }, \"request\": { \"natural_language_input\": { \"modality\": \"speech\", \"hypotheses\": [ { \"utterance\": \"call John\", \"confidence\": 0.81 }, { \"utterance\": \"calling John\", \"confidence\": 0.65 }, { \"utterance\": \"call him John\", \"confidence\": 0.31 } ] } } } Text input example: { \"version\": \"3.3\", \"session\": { \"session_id\": \"0000-abcd-1111-efgh\" }, \"request\": { \"natural_language_input\": { \"modality\": \"text\", \"utterance\": \"I'm searching for flights from London to Paris tomorrow\" } } } The session object can contain frontend-specific session data to be used in dialog or by services. For more details, see the session object The natural_language_input object contains the following members: modality : Should be either speech or text depending on how the input was detected. hypotheses : A list of hypothesis objects which should be provided if modality is speech ; otherwize the field should be omitted. utterance : A string containing the utterance if modality is text ; otherwize the field should be omitted. The natural_language_input request may be combined with the start_session request when a session does not yet exist, but may not be combined with other requests. Example: { \"version\": \"3.3\", \"request\": { \"start_session\": {}, \"natural_language_input\": {...} } } Response See response format . Semantic input requests When the client has user input on a semantic format, as a user move, it should issue the semantic_input request. Semantic in this case means that the user input does not need to be interpreted; the user move is already known. This is useful when an external natural language understanding (NLU) component has already interpreted the input; when the user presses a button in a GUI; or for instance when the user makes a gesture which is interpreted as a user move. The semantic format is different for each of the supported user moves. See the move object section for examples. Request { \"version\": \"3.3\", \"session\": { \"session_id\": \"0000-abcd-1111-efgh\" }, \"request\": { \"semantic_input\": { \"interpretations\": [ { \"utterance\": \"call John\", \"modality\": \"speech\", \"moves\": [ { \"perception_confidence\": 0.81, \"understanding_confidence\": 0.92215, \"ddd\": \"phone\", \"semantic_expression\": \"request(call)\" }, { \"perception_confidence\": 0.81, \"understanding_confidence\": 0.98532, \"ddd\": \"phone\", \"semantic_expression\": \"answer(contact_john)\" } ] }, { \"utterance\": \"calling John\", \"modality\": \"speech\", \"moves\": [ { \"perception_confidence\": 0.65, \"understanding_confidence\": 0.5234, \"ddd\": \"phone\", \"semantic_expression\": \"request(call)\" }, { \"perception_confidence\": 0.65, \"understanding_confidence\": 0.98532, \"ddd\": \"phone\", \"semantic_expression\": \"answer(contact_john)\" } ] }, { \"utterance\": \"call him John\", \"modality\": \"speech\", \"moves\": [ { \"perception_confidence\": 0.31, \"understanding_confidence\": 0.2216, \"ddd\": \"phone\", \"semantic_expression\": \"request(call)\" }, { \"perception_confidence\": 0.31, \"understanding_confidence\": 0.98532, \"ddd\": \"phone\", \"semantic_expression\": \"answer(contact_john)\" } ] }, { \"utterance\": \"call him John\", \"modality\": \"speech\", \"moves\": [ { \"perception_confidence\": 0.31, \"understanding_confidence\": 0.10126, \"ddd\": \"phone\", \"semantic_expression\": \"ask(?X.phone_number(X))\" }, { \"perception_confidence\": 0.31, \"understanding_confidence\": 0.98532, \"ddd\": \"phone\", \"semantic_expression\": \"answer(contact_john)\" } ] } ] } } } The session object can contain frontend-specific session data to be used in dialog or by services. For more details, see the session object The semantic_input object contains the following members: interpretations : A list of interpretation objects . TDM will use confidence scores and the context of the current state of the session to decide which interpretation to act upon. The semantic_input request may be combined with the start_session request when a session does not yet exist, but may not be combined with other requests. Example: { \"version\": \"3.3\", \"request\": { \"start_session\": {}, \"semantic_input\": {...} } } Response See response format . Passivity requests When the client detects user passivity, it issues a request and receives output from TDM. Request Example: { \"version\": \"3.3\", \"session\": { \"session_id\": \"0000-abcd-1111-efgh\" }, \"request\": { \"passivity\": {} } } The session object can contain frontend-specific session data to be used in dialog or by services. For more details, see the session object The passivity request may not be combined with other requests in the same call. Response See response format . Event requests When the client detects that an event pertaining to a relevant DDD has occurred, it should issue an event notification request, and receives output from TDM. Request Example: { \"version\": \"3.3\", \"session\": { \"session_id\": \"0000-abcd-1111-efgh\" }, \"request\": { \"event\": { \"name\": \"IncomingCall\", \"status\": \"started\", \"parameters\": { \"caller\": \"contact_12345\" } } } } The session object can contain frontend-specific session data to be used in dialog or by services. For more details, see the session object The event object contains the following members: name : A string corresponding to the name of the event, specified as an action in the service interface. status : Either started or ended . parameters : A map of key-value pairs pertaining to the event, corresponding to the parameters specified for the action in the service interface. The key is a string matching the parameter's predicate, and the value is a string containing the ID of the value (e.g. a number or a string depending on the sort). The event request may be combined with the start_session request when a session does not yet exist, but may not be combined with other requests. Example: { \"version\": \"3.3\", \"request\": { \"start_session\": {}, \"event\": {...} } } Response See response format . Session object A session object can contain frontend-specific session data. The data is forwarded as is to all service calls on the HTTP API for services . That way, the data can be used in service calls directly; or influence the dialog, for instance by being retrieved through service queries. Note that session data is not automatically stored or attached to the session within TDM. It is returned in the response and can be injected in future requests. If specific data should be available to all service calls on a session, the data needs to be injected in every request on that session, or the DDD needs to retrieve it into the dialog state, for instance by a service query. For all requests except start session , a session_id is required and used to identify to which session the request is being made. For start session requests however, the session_id is disallowed and instead generated by TDM. It should be retrieved from the response . Example for start session request: { \"session\": { \"my_frontend\": { \"user_id\": \"123-abc-456-def\", \"position\": { \"latitude\": \"57.699188\", \"longitude\": \"11.948313\" } } } } Example otherwise: { \"session\": { \"session_id\": \"0000-abcd-1111-efgh\", \"my_frontend\": { \"user_id\": \"123-abc-456-def\", \"position\": { \"latitude\": \"57.699188\", \"longitude\": \"11.948313\" } } } } Hypothesis object A hypothesis object contains information about what the user is believed to have uttered, consisting of the following members: utterance : A string containing the utterance. confidence : A number from 0.0 to 1.0 representing the confidence of the hypothesis. Interpretation object An interpretation translates an utterance into one or several semantic moves. An interpretation object contains: utterance : (optional) A string containing the utterance. modality : The modality that the user used to provide the original input. One of speech , text , haptic , other . moves : A list of move objects . Move object A move object contains information about how a user move was interpreted. Its members are: ddd : (optional) A string containing the DDD name. For DDD independent moves (e.g. answer(yes) and request(up) ), this field may be omitted; in which case the currently active DDD will be used to parse the semantic expression. perception_confidence : A float between 0.0 and 1.0 , representing the confidence that a spoken utterance actually matches the textual utterance, for instance when a speech-to-text (STT) component turned it into text. If no perception component was used, the confidence should be set to 1.0 . understanding_confidence : A float between 0.0 and 1.0 , representing the confidence that the textual utterance actually represents this move, for instance when an NLU component interprets the textual utterance. If no understanding component was used, for instance if the user pressed a button, the confidence should be set to 1.0 . semantic_expression : A semantic expression for the move, expressed in the dialog formalism . Supported moves are request , ask and answer . See examples below for details. Example of a request move: A request move has just one parameter: An action. In this case the call action, which must be defined in the ontology of the phone DDD. { \"ddd\": \"phone\", \"semantic_expression\": \"request(call)\", \"perception_confidence\": 0.65, \"understanding_confidence\": 0.5234 } Example of builtin request move: The builtin and DDD independent actions top and up can be requested without including the DDD name: { \"semantic_expression\": \"request(top)\", \"perception_confidence\": 0.56, \"understanding_confidence\": 0.65305 } Example of ask moves: An ask move contains a question. Questions are expressed with a leading ? . Question in ask moves always contain a predicate that must be defined in the ontology of the DDD. There are two supported types of questions in ask moves: wh-questions (questions about what, when, whom, which etc.) and yes-no questions (that can be answered with a yes or no). Example of an ask move containing a wh-question : Wh-questions are represented in a lambda-like form. In the case below, the question ?X.phone_number(X) means that we're asking what someone's phone number is. { \"ddd\": \"phone\", \"semantic_expression\": \"ask(?X.phone_number(X))\", \"perception_confidence\": 0.31, \"understanding_confidence\": 0.10126 } Example of an ask move containing a yes-no question : In the case below, the question ?missed_calls means that we're asking whether there are any missed calls (without asking e.g. when or from whom). { \"ddd\": \"phone\", \"semantic_expression\": \"ask(?missed_calls)\", \"perception_confidence\": 0.43, \"understanding_confidence\": 0.2432 } Example of a sortal answer move: A sortal answer move has an individual as its parameter. In this case, the individual contact_john , must be defined in the ontology of the phone DDD. { \"ddd\": \"phone\", \"semantic_expression\": \"answer(contact_john)\", \"perception_confidence\": 0.65, \"understanding_confidence\": 0.98532 } Example of a propositional answer move: A propositional answer move has a proposition as its parameter, consisting of a predicate and an individual. In this case, the predicate selected_contact , and the individual contact_john , must be defined in the ontology of the phone DDD. { \"ddd\": \"phone\", \"semantic_expression\": \"answer(selected_contact(contact_john))\", \"perception_confidence\": 0.65, \"understanding_confidence\": 0.71347 } Example of builtin sortal answer move: The builtin and DDD independent answers yes and no can be used without including the DDD name: { \"semantic_expression\": \"answer(yes)\", \"perception_confidence\": 0.834, \"understanding_confidence\": 0.71359 } Response format The response format differs when the request was successful compared to when it encountered an error. Successful request The TDM response from a successful request typically contains an output utterance and other relevant information. Example: { \"version\": \"3.3\", \"session\": { \"session_id\": \"0000-abcd-1111-efgh\" }, \"output\": { \"moves\": [\"ask(?X.selected_contact(X))\"], \"utterance\": \"Who do you want to call?\", \"expected_passivity\": 5.0, \"actions\": [] }, \"nlu_result\": { \"selected_utterance\": \"call John\", \"confidence\": 0.88 }, \"context\": { \"active_ddd\": \"my_ddd\", \"facts\": {}, \"language\": \"eng\", \"goal\": \"perform(call)\", \"plan\": [\"findout(?X.selected_contact(X))\"], \"facts_being_grounded\": {}, \"selected_hypothesis\": { \"utterance\": \"call John\", \"confidence\": 0.88 }, \"selected_interpretation\": [{ \"ddd\": \"send_to_frontend\", \"understanding_confidence\": \"0.749\", \"perception_confidence\": \"0.88\", \"semantic_expression\": \"request(call)\" }], \"expected_input\": { \"alternatives\": [ {\"semantic_expression\": \"answer(contact_john)\"}, {\"semantic_expression\": \"answer(contact_lisa)\"} ] } } } The session object is always provided and contains the same data that was provided in the request. Unlike requests however, it always contains: session_id : The ID of the current session. The output object is provided unless an error has occurred and has the following members: moves : The moves made by the system this turn. This is a list of move expressions in the dialog formalism , where the moves should be uttered in the listed order. Moves here are similar to the semantic_expression field of move objects . utterance : A string representing the output utterance from the system and should be realized by the client (e.g. by speaking it or displaying it as text). expected_passivity : If not null, the value is a number corresponding to the number of seconds of user passivity after which the client is expected to make a passivity request . If the value is 0.0, the passivity notification request should be issued immediately after having realized the system output. actions : A list of action invocation objects , which needs to be invoked by the client. TDM assumes that the actions will succeed and reports them accordingly. The nlu_result object is provided for natural language input requests , unless an error has occurred. It has the following members: selected_utterance : The utterance selected as the best candidate amoung the list of hypotheses. confidence : A number representing the joint confidence of the input and the NLU processing. The context object is provided unless an error has occurred and contains the following members: active_ddd : The name of the currently active DDD. facts : Information gathered during the conversation (see facts object ). language : ID of the current language. goal : Currently active goal, expressed as a goal in the dialog formalism . plan : Remaining items on the current plan, represented by a list of plan items in the dialog formalism . facts_being_grounded : Information that the system is currently grounding with the user, represented as a list of facts objects . selected_hypothesis : The natural language hypothesis that the system decided to act on. If the system turn was requested with a natural language input request , this corresponds to one of the hypothesis objects that were part of it. This field is null if a hypothesis could not be determined. selected_interpretation : The semantic interpretation that the system decided to act on. If the system turn was requested with a semantic input request , this corresponds to one of the interpretation objects that were part of it. This field is null if an interpretation could not be determined. expected_input : An expected input object , containing alternatives that TDM considers expected by the user the next turn. This field is null if TDM does not expect input, or if it doesn't know what input to expect. A warnings field is provided if warnings have been issued, as a list of strings, one string per warning. This can for instance happen when TDM is updated to a new version of this frontend API and the previous version is deprecated. In such cases, update your request formats to comply with the warning and avoid potential future errors: Request that encountered an error The TDM response when an error was encountered in the request contains an error description. { \"version\": \"3.3\", \"session\": { \"session_id\": \"0000-abcd-1111-efgh\" }, \"error\": { \"description\": \"An exception was encountered when processing the request\" } } An error object is provided if an error has occurred. In such cases, an error should be reported to the user by the client, and the session should not be resumed with further requests. The error field has the following members: description : A human readable technical description of the error. Action invocation object An action invocation object contains information about an action to be invoked by the client. The object has the following members: name is a string corresponding to the action's name in service_interface.xml . parameters contains values for all parameters that are specified for the method in service_interface.xml . If a parameter is unknown, its value is null . Otherwise it's an object containing: sort : ID of the predicate's sort as defined in the ontology. value : ID of the value. For the sorts integer and real , the ID is a number. For other sorts, e.g. string , datetime and custom sorts, the ID is a string. grammar_entry : Natural-language representation of the value. Example: { \"name\": \"call\", \"parameters\": { \"selected_contact\": { \"sort\": \"contact\", \"value\": \"contact_john\", \"grammar_entry\": \"John\" } } } Facts object The facts field contains a map of key-value pairs for information gathered during the conversation, e.g. from the user. The map may be empty. The key is a string matching a predicate as defined in the ontology. The value is an object with the following members: sort : ID of the predicate's sort as defined in the ontology. value : ID of the value (e.g. a number or a string depending on the sort). For predicates of sort datetime , the ID is an ISO 8601 string. grammar_entry : Natural-language representation of the value. Example: { \"facts\": { \"departure\": { \"sort\": \"city\", \"value\": \"city_012345\", \"grammar_entry\": \"London\" }, \"destination\": { \"sort\": \"city\", \"value\": \"city_012346\", \"grammar_entry\": \"Newcastle\" } } } Expected input object The expected input object contains alternatives that TDM considers expected by the user the next turn. They can for instance be used to add quick-answer buttons to a GUI or chat client. The object has the following members: alternatives : A list of alternative objects . If TDM asks a yes-no question , it expects the yes or no answer : { \"alternatives\": [ {\"semantic_expression\": \"answer(yes)\"}, {\"semantic_expression\": \"answer(no)\"} ] } If TDM asks an alternative question or a wh-question where the alternatives are known, the expected input object either contains answer moves with unary propositions : { \"alternatives\": [ {\"semantic_expression\": \"answer(selected_contact(contact_john))\"}, {\"semantic_expression\": \"answer(selected_contact(contact_lisa))\"} ] } ... or request and ask moves : { \"alternatives\": [ {\"semantic_expression\": \"request(call)\"}, {\"semantic_expression\": \"ask(?X.phone_number(X))\"} ] } Alternative object An alternative object contains information about the moves that the user is expected to take the next turn. It contains the following members: semantic_expression : A semantic expression of the expected move, expressed in the dialog formalism .","title":"API for HTTP frontends"},{"location":"APIs/http_frontend.html#important-concepts","text":"This section describes some concepts that are important to understand and comply with when integrating TDM in a dialog system. Requests and responses TDM serves an HTTP server and responds to requests done by the client. The client is the consumer of the API outlined in this document. The client invokes TDM with an HTTP request to the interaction endpoint, e.g. http://localhost:9090/interact , using the POST method and a JSON body. The client should expect the status code to be 200 OK. For other status codes, the client should report an error to the user. The request body always contains a version number, specifying the version of the HTTP API format. The exact format of the request and the response depends on the type of request as described in the separate sections below. Turn management Turn management is a vital part of dialog between humans, read for instance the Wikipedia article . Since TDM is based on research on human-human dialog, turn management is a central concept here too. The TDM client is responsible for turn management, because it's the component that is closest to the human in the human-machine dialog that TDM enables. Since the machine is intended to assist the human, the human decides the pace, the turn taking, of the conversation. In spoken dialog, turn taking happens in close collaboration with the spoken output of the system, which means that the system's turn management needs to happen as close to this component, the text-to-speech component (TTS), as possible. TDM enables intuitive turn taking by instructing its client how to deal with the user input that it's range of sensors can pick up. The instructions are straightforward and revolve around passivity. If the user is passive, for instance doesn't know what to say, for a given amount of time, the client sends TDM a passivity request , which lets the system take the next turn instead of the user. The user should be considered passive when not doing anything related to the dialog. If the user however takes some action (although not completing its turn just yet), for instance by typing (if it's a text interface) or talking (if it's a spoken interface), the user should be considered active and the passivity request should not be sent to TDM. Instead the user should be allowed to complete its turn, resulting in an input request. TDM instructs its client about how long time of passivity that should pass before sending the passivity request in the output.expected_passivity field of the response . For instance, if TDM responds with: { \"output\": { ... \"expected_passivity\": 1.0 }, ... } then the client should send a passivity request when the user has been passive for 1 second. The 1 second should start counting when the system utterance has reached the user, which in a spoken interface means when the TTS finished speaking TDM's utterance. Note that sometimes TDM does not have anything to say when the user becomes passive ( \"expected_passivity\": null ), and sometimes it just needs to progress the conversation immediately after saying something ( \"expected_passivity\": 0.0 ). Read the details about how to interpret the expected_passivity value in the response format section . Errors When an error occurs in TDM during a request, for instance due to incomplete turn management, the response contains the \"error\" field. It's important to note that this could mean that the session stops. If it has stopped, further requests on the same session will report errors that the provided session ID is unknown.","title":"Important concepts"},{"location":"APIs/http_frontend.html#start-session-requests","text":"When a new session should be started, the client issues a start_session request. The response contains initial output from TDM and a session ID that can be used in subsequent requests. For more details, see the response format . If a session ID is provided together with the start_session request, an error is given. The integrity of the session is however maintained. Request Example: { \"version\": \"3.3\", \"session\": {}, \"request\": { \"start_session\": {} } } The session object can contain frontend-specific session data to be used in dialog or by services. For more details, see the session object The start_session object may contain the following optional members: ddd_set : A string specifying a DDD set for the session. If omitted, a default DDD set configured by the backend is used. The start_session request may be issued on its own, so that the system will start the conversation; or combined with natural_language_input , semantic_input and event requests to start the conversation from there. Example when combined with natural_language_input : { \"version\": \"3.3\", \"request\": { \"start_session\": {}, \"natural_language_input\": {...} } } Response See response format .","title":"Start session requests"},{"location":"APIs/http_frontend.html#natural-language-input-requests","text":"When the client detects natural language input from the user, it issues a request and receives output from TDM. The request can contain either hypotheses with the speech modality, or a single utterance with the text modality. Request Speech input example: { \"version\": \"3.3\", \"session\": { \"session_id\": \"0000-abcd-1111-efgh\" }, \"request\": { \"natural_language_input\": { \"modality\": \"speech\", \"hypotheses\": [ { \"utterance\": \"call John\", \"confidence\": 0.81 }, { \"utterance\": \"calling John\", \"confidence\": 0.65 }, { \"utterance\": \"call him John\", \"confidence\": 0.31 } ] } } } Text input example: { \"version\": \"3.3\", \"session\": { \"session_id\": \"0000-abcd-1111-efgh\" }, \"request\": { \"natural_language_input\": { \"modality\": \"text\", \"utterance\": \"I'm searching for flights from London to Paris tomorrow\" } } } The session object can contain frontend-specific session data to be used in dialog or by services. For more details, see the session object The natural_language_input object contains the following members: modality : Should be either speech or text depending on how the input was detected. hypotheses : A list of hypothesis objects which should be provided if modality is speech ; otherwize the field should be omitted. utterance : A string containing the utterance if modality is text ; otherwize the field should be omitted. The natural_language_input request may be combined with the start_session request when a session does not yet exist, but may not be combined with other requests. Example: { \"version\": \"3.3\", \"request\": { \"start_session\": {}, \"natural_language_input\": {...} } } Response See response format .","title":"Natural language input requests"},{"location":"APIs/http_frontend.html#semantic-input-requests","text":"When the client has user input on a semantic format, as a user move, it should issue the semantic_input request. Semantic in this case means that the user input does not need to be interpreted; the user move is already known. This is useful when an external natural language understanding (NLU) component has already interpreted the input; when the user presses a button in a GUI; or for instance when the user makes a gesture which is interpreted as a user move. The semantic format is different for each of the supported user moves. See the move object section for examples. Request { \"version\": \"3.3\", \"session\": { \"session_id\": \"0000-abcd-1111-efgh\" }, \"request\": { \"semantic_input\": { \"interpretations\": [ { \"utterance\": \"call John\", \"modality\": \"speech\", \"moves\": [ { \"perception_confidence\": 0.81, \"understanding_confidence\": 0.92215, \"ddd\": \"phone\", \"semantic_expression\": \"request(call)\" }, { \"perception_confidence\": 0.81, \"understanding_confidence\": 0.98532, \"ddd\": \"phone\", \"semantic_expression\": \"answer(contact_john)\" } ] }, { \"utterance\": \"calling John\", \"modality\": \"speech\", \"moves\": [ { \"perception_confidence\": 0.65, \"understanding_confidence\": 0.5234, \"ddd\": \"phone\", \"semantic_expression\": \"request(call)\" }, { \"perception_confidence\": 0.65, \"understanding_confidence\": 0.98532, \"ddd\": \"phone\", \"semantic_expression\": \"answer(contact_john)\" } ] }, { \"utterance\": \"call him John\", \"modality\": \"speech\", \"moves\": [ { \"perception_confidence\": 0.31, \"understanding_confidence\": 0.2216, \"ddd\": \"phone\", \"semantic_expression\": \"request(call)\" }, { \"perception_confidence\": 0.31, \"understanding_confidence\": 0.98532, \"ddd\": \"phone\", \"semantic_expression\": \"answer(contact_john)\" } ] }, { \"utterance\": \"call him John\", \"modality\": \"speech\", \"moves\": [ { \"perception_confidence\": 0.31, \"understanding_confidence\": 0.10126, \"ddd\": \"phone\", \"semantic_expression\": \"ask(?X.phone_number(X))\" }, { \"perception_confidence\": 0.31, \"understanding_confidence\": 0.98532, \"ddd\": \"phone\", \"semantic_expression\": \"answer(contact_john)\" } ] } ] } } } The session object can contain frontend-specific session data to be used in dialog or by services. For more details, see the session object The semantic_input object contains the following members: interpretations : A list of interpretation objects . TDM will use confidence scores and the context of the current state of the session to decide which interpretation to act upon. The semantic_input request may be combined with the start_session request when a session does not yet exist, but may not be combined with other requests. Example: { \"version\": \"3.3\", \"request\": { \"start_session\": {}, \"semantic_input\": {...} } } Response See response format .","title":"Semantic input requests"},{"location":"APIs/http_frontend.html#passivity-requests","text":"When the client detects user passivity, it issues a request and receives output from TDM. Request Example: { \"version\": \"3.3\", \"session\": { \"session_id\": \"0000-abcd-1111-efgh\" }, \"request\": { \"passivity\": {} } } The session object can contain frontend-specific session data to be used in dialog or by services. For more details, see the session object The passivity request may not be combined with other requests in the same call. Response See response format .","title":"Passivity requests"},{"location":"APIs/http_frontend.html#event-requests","text":"When the client detects that an event pertaining to a relevant DDD has occurred, it should issue an event notification request, and receives output from TDM. Request Example: { \"version\": \"3.3\", \"session\": { \"session_id\": \"0000-abcd-1111-efgh\" }, \"request\": { \"event\": { \"name\": \"IncomingCall\", \"status\": \"started\", \"parameters\": { \"caller\": \"contact_12345\" } } } } The session object can contain frontend-specific session data to be used in dialog or by services. For more details, see the session object The event object contains the following members: name : A string corresponding to the name of the event, specified as an action in the service interface. status : Either started or ended . parameters : A map of key-value pairs pertaining to the event, corresponding to the parameters specified for the action in the service interface. The key is a string matching the parameter's predicate, and the value is a string containing the ID of the value (e.g. a number or a string depending on the sort). The event request may be combined with the start_session request when a session does not yet exist, but may not be combined with other requests. Example: { \"version\": \"3.3\", \"request\": { \"start_session\": {}, \"event\": {...} } } Response See response format .","title":"Event requests"},{"location":"APIs/http_frontend.html#session-object","text":"A session object can contain frontend-specific session data. The data is forwarded as is to all service calls on the HTTP API for services . That way, the data can be used in service calls directly; or influence the dialog, for instance by being retrieved through service queries. Note that session data is not automatically stored or attached to the session within TDM. It is returned in the response and can be injected in future requests. If specific data should be available to all service calls on a session, the data needs to be injected in every request on that session, or the DDD needs to retrieve it into the dialog state, for instance by a service query. For all requests except start session , a session_id is required and used to identify to which session the request is being made. For start session requests however, the session_id is disallowed and instead generated by TDM. It should be retrieved from the response . Example for start session request: { \"session\": { \"my_frontend\": { \"user_id\": \"123-abc-456-def\", \"position\": { \"latitude\": \"57.699188\", \"longitude\": \"11.948313\" } } } } Example otherwise: { \"session\": { \"session_id\": \"0000-abcd-1111-efgh\", \"my_frontend\": { \"user_id\": \"123-abc-456-def\", \"position\": { \"latitude\": \"57.699188\", \"longitude\": \"11.948313\" } } } }","title":"Session object"},{"location":"APIs/http_frontend.html#hypothesis-object","text":"A hypothesis object contains information about what the user is believed to have uttered, consisting of the following members: utterance : A string containing the utterance. confidence : A number from 0.0 to 1.0 representing the confidence of the hypothesis.","title":"Hypothesis object"},{"location":"APIs/http_frontend.html#interpretation-object","text":"An interpretation translates an utterance into one or several semantic moves. An interpretation object contains: utterance : (optional) A string containing the utterance. modality : The modality that the user used to provide the original input. One of speech , text , haptic , other . moves : A list of move objects .","title":"Interpretation object"},{"location":"APIs/http_frontend.html#move-object","text":"A move object contains information about how a user move was interpreted. Its members are: ddd : (optional) A string containing the DDD name. For DDD independent moves (e.g. answer(yes) and request(up) ), this field may be omitted; in which case the currently active DDD will be used to parse the semantic expression. perception_confidence : A float between 0.0 and 1.0 , representing the confidence that a spoken utterance actually matches the textual utterance, for instance when a speech-to-text (STT) component turned it into text. If no perception component was used, the confidence should be set to 1.0 . understanding_confidence : A float between 0.0 and 1.0 , representing the confidence that the textual utterance actually represents this move, for instance when an NLU component interprets the textual utterance. If no understanding component was used, for instance if the user pressed a button, the confidence should be set to 1.0 . semantic_expression : A semantic expression for the move, expressed in the dialog formalism . Supported moves are request , ask and answer . See examples below for details. Example of a request move: A request move has just one parameter: An action. In this case the call action, which must be defined in the ontology of the phone DDD. { \"ddd\": \"phone\", \"semantic_expression\": \"request(call)\", \"perception_confidence\": 0.65, \"understanding_confidence\": 0.5234 } Example of builtin request move: The builtin and DDD independent actions top and up can be requested without including the DDD name: { \"semantic_expression\": \"request(top)\", \"perception_confidence\": 0.56, \"understanding_confidence\": 0.65305 } Example of ask moves: An ask move contains a question. Questions are expressed with a leading ? . Question in ask moves always contain a predicate that must be defined in the ontology of the DDD. There are two supported types of questions in ask moves: wh-questions (questions about what, when, whom, which etc.) and yes-no questions (that can be answered with a yes or no). Example of an ask move containing a wh-question : Wh-questions are represented in a lambda-like form. In the case below, the question ?X.phone_number(X) means that we're asking what someone's phone number is. { \"ddd\": \"phone\", \"semantic_expression\": \"ask(?X.phone_number(X))\", \"perception_confidence\": 0.31, \"understanding_confidence\": 0.10126 } Example of an ask move containing a yes-no question : In the case below, the question ?missed_calls means that we're asking whether there are any missed calls (without asking e.g. when or from whom). { \"ddd\": \"phone\", \"semantic_expression\": \"ask(?missed_calls)\", \"perception_confidence\": 0.43, \"understanding_confidence\": 0.2432 } Example of a sortal answer move: A sortal answer move has an individual as its parameter. In this case, the individual contact_john , must be defined in the ontology of the phone DDD. { \"ddd\": \"phone\", \"semantic_expression\": \"answer(contact_john)\", \"perception_confidence\": 0.65, \"understanding_confidence\": 0.98532 } Example of a propositional answer move: A propositional answer move has a proposition as its parameter, consisting of a predicate and an individual. In this case, the predicate selected_contact , and the individual contact_john , must be defined in the ontology of the phone DDD. { \"ddd\": \"phone\", \"semantic_expression\": \"answer(selected_contact(contact_john))\", \"perception_confidence\": 0.65, \"understanding_confidence\": 0.71347 } Example of builtin sortal answer move: The builtin and DDD independent answers yes and no can be used without including the DDD name: { \"semantic_expression\": \"answer(yes)\", \"perception_confidence\": 0.834, \"understanding_confidence\": 0.71359 }","title":"Move object"},{"location":"APIs/http_frontend.html#response-format","text":"The response format differs when the request was successful compared to when it encountered an error. Successful request The TDM response from a successful request typically contains an output utterance and other relevant information. Example: { \"version\": \"3.3\", \"session\": { \"session_id\": \"0000-abcd-1111-efgh\" }, \"output\": { \"moves\": [\"ask(?X.selected_contact(X))\"], \"utterance\": \"Who do you want to call?\", \"expected_passivity\": 5.0, \"actions\": [] }, \"nlu_result\": { \"selected_utterance\": \"call John\", \"confidence\": 0.88 }, \"context\": { \"active_ddd\": \"my_ddd\", \"facts\": {}, \"language\": \"eng\", \"goal\": \"perform(call)\", \"plan\": [\"findout(?X.selected_contact(X))\"], \"facts_being_grounded\": {}, \"selected_hypothesis\": { \"utterance\": \"call John\", \"confidence\": 0.88 }, \"selected_interpretation\": [{ \"ddd\": \"send_to_frontend\", \"understanding_confidence\": \"0.749\", \"perception_confidence\": \"0.88\", \"semantic_expression\": \"request(call)\" }], \"expected_input\": { \"alternatives\": [ {\"semantic_expression\": \"answer(contact_john)\"}, {\"semantic_expression\": \"answer(contact_lisa)\"} ] } } } The session object is always provided and contains the same data that was provided in the request. Unlike requests however, it always contains: session_id : The ID of the current session. The output object is provided unless an error has occurred and has the following members: moves : The moves made by the system this turn. This is a list of move expressions in the dialog formalism , where the moves should be uttered in the listed order. Moves here are similar to the semantic_expression field of move objects . utterance : A string representing the output utterance from the system and should be realized by the client (e.g. by speaking it or displaying it as text). expected_passivity : If not null, the value is a number corresponding to the number of seconds of user passivity after which the client is expected to make a passivity request . If the value is 0.0, the passivity notification request should be issued immediately after having realized the system output. actions : A list of action invocation objects , which needs to be invoked by the client. TDM assumes that the actions will succeed and reports them accordingly. The nlu_result object is provided for natural language input requests , unless an error has occurred. It has the following members: selected_utterance : The utterance selected as the best candidate amoung the list of hypotheses. confidence : A number representing the joint confidence of the input and the NLU processing. The context object is provided unless an error has occurred and contains the following members: active_ddd : The name of the currently active DDD. facts : Information gathered during the conversation (see facts object ). language : ID of the current language. goal : Currently active goal, expressed as a goal in the dialog formalism . plan : Remaining items on the current plan, represented by a list of plan items in the dialog formalism . facts_being_grounded : Information that the system is currently grounding with the user, represented as a list of facts objects . selected_hypothesis : The natural language hypothesis that the system decided to act on. If the system turn was requested with a natural language input request , this corresponds to one of the hypothesis objects that were part of it. This field is null if a hypothesis could not be determined. selected_interpretation : The semantic interpretation that the system decided to act on. If the system turn was requested with a semantic input request , this corresponds to one of the interpretation objects that were part of it. This field is null if an interpretation could not be determined. expected_input : An expected input object , containing alternatives that TDM considers expected by the user the next turn. This field is null if TDM does not expect input, or if it doesn't know what input to expect. A warnings field is provided if warnings have been issued, as a list of strings, one string per warning. This can for instance happen when TDM is updated to a new version of this frontend API and the previous version is deprecated. In such cases, update your request formats to comply with the warning and avoid potential future errors: Request that encountered an error The TDM response when an error was encountered in the request contains an error description. { \"version\": \"3.3\", \"session\": { \"session_id\": \"0000-abcd-1111-efgh\" }, \"error\": { \"description\": \"An exception was encountered when processing the request\" } } An error object is provided if an error has occurred. In such cases, an error should be reported to the user by the client, and the session should not be resumed with further requests. The error field has the following members: description : A human readable technical description of the error.","title":"Response format"},{"location":"APIs/http_frontend.html#action-invocation-object","text":"An action invocation object contains information about an action to be invoked by the client. The object has the following members: name is a string corresponding to the action's name in service_interface.xml . parameters contains values for all parameters that are specified for the method in service_interface.xml . If a parameter is unknown, its value is null . Otherwise it's an object containing: sort : ID of the predicate's sort as defined in the ontology. value : ID of the value. For the sorts integer and real , the ID is a number. For other sorts, e.g. string , datetime and custom sorts, the ID is a string. grammar_entry : Natural-language representation of the value. Example: { \"name\": \"call\", \"parameters\": { \"selected_contact\": { \"sort\": \"contact\", \"value\": \"contact_john\", \"grammar_entry\": \"John\" } } }","title":"Action invocation object"},{"location":"APIs/http_frontend.html#facts-object","text":"The facts field contains a map of key-value pairs for information gathered during the conversation, e.g. from the user. The map may be empty. The key is a string matching a predicate as defined in the ontology. The value is an object with the following members: sort : ID of the predicate's sort as defined in the ontology. value : ID of the value (e.g. a number or a string depending on the sort). For predicates of sort datetime , the ID is an ISO 8601 string. grammar_entry : Natural-language representation of the value. Example: { \"facts\": { \"departure\": { \"sort\": \"city\", \"value\": \"city_012345\", \"grammar_entry\": \"London\" }, \"destination\": { \"sort\": \"city\", \"value\": \"city_012346\", \"grammar_entry\": \"Newcastle\" } } }","title":"Facts object"},{"location":"APIs/http_frontend.html#expected-input-object","text":"The expected input object contains alternatives that TDM considers expected by the user the next turn. They can for instance be used to add quick-answer buttons to a GUI or chat client. The object has the following members: alternatives : A list of alternative objects . If TDM asks a yes-no question , it expects the yes or no answer : { \"alternatives\": [ {\"semantic_expression\": \"answer(yes)\"}, {\"semantic_expression\": \"answer(no)\"} ] } If TDM asks an alternative question or a wh-question where the alternatives are known, the expected input object either contains answer moves with unary propositions : { \"alternatives\": [ {\"semantic_expression\": \"answer(selected_contact(contact_john))\"}, {\"semantic_expression\": \"answer(selected_contact(contact_lisa))\"} ] } ... or request and ask moves : { \"alternatives\": [ {\"semantic_expression\": \"request(call)\"}, {\"semantic_expression\": \"ask(?X.phone_number(X))\"} ] }","title":"Expected input object"},{"location":"APIs/http_frontend.html#alternative-object","text":"An alternative object contains information about the moves that the user is expected to take the next turn. It contains the following members: semantic_expression : A semantic expression of the expected move, expressed in the dialog formalism .","title":"Alternative object"},{"location":"APIs/http_service.html","text":"This document describes API version 1.1 for HTTP services. It needs to be implemented by services invoked by TDM over HTTP. Services are used by DDDs to invoke actions, invoke queries, recognize entities, and to validate parameters. TDM invokes service methods with an HTTP request to the endpoint specified in service_interface.xml , using the POST method and a JSON body. It expects the status code to be 200 OK. (For other status codes, TDM reports an error to the user.) The request body always contains a version number, specifying the version of the service integration format. The service can use the version in the request to validate that the service implementation is compatible with the request. The service also returns a version number in the response body, corresponding to the version of this API used when implementing the service. If the service returns a version number that is not compatible with the request, TDM reports an error to the user. Responses from services adhere to the JSend specification . See response format for a general description. The exact format of the request and the response depends on the service method and is described below. Action requests Request Below is an example of a request body for an action called SetTemperature , invoked when the user has requested to set the temperature to 23 degrees: { \"version\": \"1.1\", \"session\": { \"session_id\": \"0000-abcd-1111-efgh\" }, \"request\": { \"type\": \"action\", \"name\": \"SetTemperature\", \"parameters\": { \"degrees\": { \"sort\": \"integer\", \"value\": 23, \"grammar_entry\": \"23\" } } }, \"context\": { \"active_ddd\": \"MyDDD\", \"facts\": { \"degrees\": { \"sort\": \"integer\", \"value\": 23, \"grammar_entry\": \"23\" } }, \"language\": \"eng\", \"invocation_id\": \"2222-ijkl-3333-mnop\" } } Format for request : see Request object . Format for session : see Session object . Format for context : see Context object . Response Actions invoked over HTTP can either succeed or fail with an expected reason. Below is the expected response body for the request above, when successful: { \"status\": \"success\", \"data\": { \"version\": \"1.1\" } } Format for status and data : see Response format . But say that someone tries to set the temperature of a refrigerator to 23 degrees, which is more than it can handle. If there's a failure reason temperature_too_high declared in service_interface.xml , the service can fail expectedly with: { \"status\": \"fail\", \"data\": { \"version\": \"1.1\", \"reason\": \"temperature_too_high\" } } Format for status and data : see Response format . The data object additionally contains these action specific members: reason matching the failure that occurred. It needs to match one of the failure reasons declared for this action in service_interface.xml . Query requests Queries are invoked by TDM to retrieve information from a service, e.g. in order to be able to respond to a question from a user, or to fetch alternatives for alternative questions. Request Below is an example of a request body for a query called current_temperature with the parameter location , invoked when the user has asked for the temperature in London: { \"version\": \"1.1\", \"session\": { \"session_id\": \"0000-abcd-1111-efgh\" }, \"request\": { \"type\": \"query\", \"name\": \"current_temperature\", \"parameters\": { \"location\": { \"sort\": \"city\", \"value\": \"city_012345\", \"grammar_entry\": \"London\" } }, \"min_results\": 1, \"max_results\": 1 }, \"context\": { \"active_ddd\": \"MyDDD\", \"facts\": { \"location\": { \"sort\": \"city\", \"value\": \"city_012345\", \"grammar_entry\": \"London\" } }, \"language\": \"eng\", \"invocation_id\": \"2222-ijkl-3333-mnop\" } } Format for request : see Request object . The request object additionally contains these query specific members: min_results specifies the minimum number of results that the service should return as a non-negative integer. If the service returns fewer results than specified by min_results , TDM reports an error to the user. max_results specifies the maximum number of results that the service should return. max_results is either a positive integer, or null meaning that there is no upper bound. If the service returns more results than specified by max_results , TDM reports an error to the user. Format for session : see Session object . Format for context : see Context object . Response Below is an example of a response body for the request above, when the current temperature in London is 17 degrees: { \"status\": \"success\", \"data\": { \"version\": \"1.1\", \"result\": [ { \"value\": 17, \"confidence\": 1.0, \"grammar_entry\": null } ] } } General format for responses: see Response format . data additionally contains these members specific to queries: result : contains a list result items. Each result item is an object with the following members: value can be either a number, string or null , depending on the query's predicate. For predicates of sort integer or real , a number is expected. For predicates of sort datetime , an ISO 8601 string is expected. For predicates of a custom sort, a string is expected, corresponding to the name of the individual. For dynamic sorts, the value null is supported, in which case a grammar entry is required. confidence should normally be set to 1.0. However, when the information is uncertain - e.g. when making a prediction from a user model - confidence can be set to a value from 0.0 to 1.0. grammar_entry can be set to specify a natural-language represention of the result. This is required for dynamic sorts, when value is null . Additional query example: Multiple results Below is an example of a request and response for a query called selected_contact which is used to determine whether a single contact can be identified based on a first and last name. In the example, only the first name is known, and the service returns two matching contacts. Request: { \"version\": \"1.1\", \"session\": { \"session_id\": \"0000-abcd-1111-efgh\" }, \"request\": { \"type\": \"query\", \"name\": \"selected_contact\", \"parameters\": { \"selected_first_name\": { \"sort\": \"first_name\", \"value\": \"fist_name_john\", \"grammar_entry\": \"John\" }, \"selected_last_name\": null }, \"min_results\": 0, \"max_results\": null }, \"context\": { \"active_ddd\": \"MyDDD\", \"facts\": { \"selected_first_name\": { \"sort\": \"first_name\", \"value\": \"fist_name_john\", \"grammar_entry\": \"John\" } }, \"language\": \"eng\", \"invocation_id\": \"2222-ijkl-3333-mnop\" } } Response: { \"status\": \"success\", \"data\": { \"version\": \"1.1\", \"result\": [ { \"value\": \"contact_john_johnson\", \"confidence\": 1.0, \"grammar_entry\": \"John Johnson\" }, { \"value\": \"contact_john_thompson\", \"confidence\": 1.0, \"grammar_entry\": \"John Thompson\" } ] } } Also note that for this request example, the service may return an empty list of results if no matching contacts were found for the given parameters. Entity recognizer requests Entity recognizers are invoked by TDM to identify entities in user utterances. Request Below is an example of a request body for an entity recognition invocation when the user has said \"what is the temperature in London\": { \"version\": \"1.1\", \"session\": { \"session_id\": \"0000-abcd-1111-efgh\" }, \"request\": { \"type\": \"entity_recognizer\", \"name\": \"LocationRecognizer\", \"utterance\": \"what is the temperature in London\" }, \"context\": { \"active_ddd\": \"MyDDD\", \"facts\": {}, \"language\": \"eng\", \"invocation_id\": \"2222-ijkl-3333-mnop\" } } Format for request : see Request object . The request object additionally contains these members specific to entity recognizers: utterance is the user utterance that should be searched for entities. It's a string. Format for session : see Session object . Format for context : see Context object . Response Below is an example of a response body for the request above: { \"status\": \"success\", \"data\": { \"version\": \"1.1\", \"result\": [ { \"grammar_entry\": \"London\", \"sort\": \"city\", \"value\": \"city_012345\" } ] } } General format for responses: see Response format . data additionally contains these members specific to entity recognizers: result : contains a list of zero or more result items. Each result item is an object with the following members: grammar_entry : Natural-language representation of the recognized entity. sort : The entity's sort, corresponding to the sort's name in ontology.xml . value : ID or semantic representation of the entity if known, otherwise null . For static (non-dynamic) sorts, the value is mandatory and should correspond to the semantic name of an individual. Validator requests Validators are invoked by TDM to determine if information provided by the user is valid. If not, relevant feedback is given to the user. Request Below is an example of a request body for a validator called RouteValidator with the parameters departure and destination : { \"version\": \"1.1\", \"session\": { \"session_id\": \"0000-abcd-1111-efgh\" }, \"request\": { \"type\": \"validator\", \"name\": \"RouteValidator\", \"parameters\": { \"departure\": { \"sort\": \"city\", \"value\": \"city_012345\", \"grammar_entry\": \"London\" }, \"destination\": { \"sort\": \"city\", \"value\": \"city_099998\", \"grammar_entry\": \"Chippinghirst\" } } }, \"context\": { \"active_ddd\": \"MyDDD\", \"facts\": { \"departure\": { \"sort\": \"city\", \"value\": \"city_012345\", \"grammar_entry\": \"London\" }, \"destination\": { \"sort\": \"city\", \"value\": \"city_099998\", \"grammar_entry\": \"Chippinghirst\" } }, \"language\": \"eng\", \"invocation_id\": \"2222-ijkl-3333-mnop\" } } Format for request : see Request object . Format for session : see Session object . Format for context : see Context object . Response Below is an example of a response body for the request above: { \"status\": \"success\", \"data\": { \"version\": \"1.1\", \"is_valid\": false } } General format for responses: see Response format . data additionally contains these validator specific members: is_valid : can be either true or false , specifying whether the combination of parameters is valid or not. Request object In general, the request object contains the following members. It may also contain additional method specific members. type is the method type, e.g. action or query . All methods that can be declared in service_interface.xml are supported. See examples for each of them above. name is the method name, as specified in service_interface.xml . parameters contains values for all parameters that are specified for the method in service_interface.xml . If a parameter is unknown, its value is null . Otherwise it's an object containing: sort : ID of the predicate's sort as defined in the ontology. value : ID of the value. For the sorts integer and real , the ID is a number. For other sorts, e.g. string , datetime and custom sorts, the ID is a string. grammar_entry : Natural-language representation of the value. Example: { \"request\": { \"type\": \"validator\", \"name\": \"contact_validator\", \"parameters\": { \"selected_first_name\": { \"sort\": \"first_name\", \"value\": \"fist_name_john\", \"grammar_entry\": \"John\" }, \"selected_last_name\": null } } } Session object The session object contains the following members: session_id : String representing the current TDM session. Additionally, it contains the same data that was injected in the frontend request to TDM. This way, service calls can utilize frontend-specific session data. For more details, read about the session object in the frontend API docs Example: { \"session\": { \"session_id\": \"0000-abcd-1111-efgh\", \"my_frontend\": { \"user_id\": \"123-abc-456-def\", \"position\": { \"latitude\": \"57.699188\", \"longitude\": \"11.948313\" } } } } Context object The context object contains the following members: active_ddd : The name of the currently active DDD. facts : Information gathered during the conversation (see Facts object ). language : ID of the current language. invocation_id : A unique identifer for the invocation from TDM. This ID can be logged for analytics and issue reporting. Facts object The facts object contains a map of key-value pairs for information gathered during the conversation, e.g. from the user. The map may be empty. The key is a string matching a predicate as defined in the ontology. The value is an object with the following members: sort : ID of the predicate's sort as defined in the ontology. value : ID of the value. For the sorts integer and real , the ID is a number. For other sorts, e.g. string , datetime and custom sorts, the ID is a string. grammar_entry : Natural-language representation of the value. Example: { \"facts\": { \"departure\": { \"sort\": \"city\", \"value\": \"city_012345\", \"grammar_entry\": \"London\" }, \"destination\": { \"sort\": \"city\", \"value\": \"city_012346\", \"grammar_entry\": \"Newcastle\" } } } Response format All service responses adhere to the JSend specification . In general, responses can have one of three appearances, corresponding to the status of the invocation: success , fail and error . See the examples below. Success: { \"status\": \"success\", \"data\": { \"version\": \"1.1\" } } Successful method invocations need to set their status to success . The data object contains mostly method specific members. All methods need however include: version : the version of the API used to process the request and format the response. If the version is not compatible with the request, TDM reports an error to the user. Fail: { \"status\": \"fail\", \"data\": { \"version\": \"1.1\" } } Failures cannot be used with queries, entity recognizers or validators, but is supported by actions . If a fail status is not supported or is reported unexpectedly, it is treated as an error . error is however preferred over fail since a helpful message can be provided. TDM will report the error to the user, but will not mention any details. To report a failure, the status need to be set to fail . The data object contains mostly method specific members. All methods need however include: version : the version of the API used to process the request and format the response. Error: { \"status\": \"error\", \"message\": \"Could not communicate with the database.\", \"code\": 135, \"data\": { \"version\": \"1.1\" } } When a service encounters an error, i.e. an exception, the status need to be set to error . TDM will report the error to the user, but will not mention any details. message should be a human-readable message, explaining what went wrong. It will be logged but is not exposed to end-users. code (optional) is a numeric code identifying the error, if applicable. The data needs to contain: version : the version of the API used to process the request and format the response.","title":"API for HTTP services"},{"location":"APIs/http_service.html#action-requests","text":"Request Below is an example of a request body for an action called SetTemperature , invoked when the user has requested to set the temperature to 23 degrees: { \"version\": \"1.1\", \"session\": { \"session_id\": \"0000-abcd-1111-efgh\" }, \"request\": { \"type\": \"action\", \"name\": \"SetTemperature\", \"parameters\": { \"degrees\": { \"sort\": \"integer\", \"value\": 23, \"grammar_entry\": \"23\" } } }, \"context\": { \"active_ddd\": \"MyDDD\", \"facts\": { \"degrees\": { \"sort\": \"integer\", \"value\": 23, \"grammar_entry\": \"23\" } }, \"language\": \"eng\", \"invocation_id\": \"2222-ijkl-3333-mnop\" } } Format for request : see Request object . Format for session : see Session object . Format for context : see Context object . Response Actions invoked over HTTP can either succeed or fail with an expected reason. Below is the expected response body for the request above, when successful: { \"status\": \"success\", \"data\": { \"version\": \"1.1\" } } Format for status and data : see Response format . But say that someone tries to set the temperature of a refrigerator to 23 degrees, which is more than it can handle. If there's a failure reason temperature_too_high declared in service_interface.xml , the service can fail expectedly with: { \"status\": \"fail\", \"data\": { \"version\": \"1.1\", \"reason\": \"temperature_too_high\" } } Format for status and data : see Response format . The data object additionally contains these action specific members: reason matching the failure that occurred. It needs to match one of the failure reasons declared for this action in service_interface.xml .","title":"Action requests"},{"location":"APIs/http_service.html#query-requests","text":"Queries are invoked by TDM to retrieve information from a service, e.g. in order to be able to respond to a question from a user, or to fetch alternatives for alternative questions. Request Below is an example of a request body for a query called current_temperature with the parameter location , invoked when the user has asked for the temperature in London: { \"version\": \"1.1\", \"session\": { \"session_id\": \"0000-abcd-1111-efgh\" }, \"request\": { \"type\": \"query\", \"name\": \"current_temperature\", \"parameters\": { \"location\": { \"sort\": \"city\", \"value\": \"city_012345\", \"grammar_entry\": \"London\" } }, \"min_results\": 1, \"max_results\": 1 }, \"context\": { \"active_ddd\": \"MyDDD\", \"facts\": { \"location\": { \"sort\": \"city\", \"value\": \"city_012345\", \"grammar_entry\": \"London\" } }, \"language\": \"eng\", \"invocation_id\": \"2222-ijkl-3333-mnop\" } } Format for request : see Request object . The request object additionally contains these query specific members: min_results specifies the minimum number of results that the service should return as a non-negative integer. If the service returns fewer results than specified by min_results , TDM reports an error to the user. max_results specifies the maximum number of results that the service should return. max_results is either a positive integer, or null meaning that there is no upper bound. If the service returns more results than specified by max_results , TDM reports an error to the user. Format for session : see Session object . Format for context : see Context object . Response Below is an example of a response body for the request above, when the current temperature in London is 17 degrees: { \"status\": \"success\", \"data\": { \"version\": \"1.1\", \"result\": [ { \"value\": 17, \"confidence\": 1.0, \"grammar_entry\": null } ] } } General format for responses: see Response format . data additionally contains these members specific to queries: result : contains a list result items. Each result item is an object with the following members: value can be either a number, string or null , depending on the query's predicate. For predicates of sort integer or real , a number is expected. For predicates of sort datetime , an ISO 8601 string is expected. For predicates of a custom sort, a string is expected, corresponding to the name of the individual. For dynamic sorts, the value null is supported, in which case a grammar entry is required. confidence should normally be set to 1.0. However, when the information is uncertain - e.g. when making a prediction from a user model - confidence can be set to a value from 0.0 to 1.0. grammar_entry can be set to specify a natural-language represention of the result. This is required for dynamic sorts, when value is null .","title":"Query requests"},{"location":"APIs/http_service.html#additional-query-example-multiple-results","text":"Below is an example of a request and response for a query called selected_contact which is used to determine whether a single contact can be identified based on a first and last name. In the example, only the first name is known, and the service returns two matching contacts. Request: { \"version\": \"1.1\", \"session\": { \"session_id\": \"0000-abcd-1111-efgh\" }, \"request\": { \"type\": \"query\", \"name\": \"selected_contact\", \"parameters\": { \"selected_first_name\": { \"sort\": \"first_name\", \"value\": \"fist_name_john\", \"grammar_entry\": \"John\" }, \"selected_last_name\": null }, \"min_results\": 0, \"max_results\": null }, \"context\": { \"active_ddd\": \"MyDDD\", \"facts\": { \"selected_first_name\": { \"sort\": \"first_name\", \"value\": \"fist_name_john\", \"grammar_entry\": \"John\" } }, \"language\": \"eng\", \"invocation_id\": \"2222-ijkl-3333-mnop\" } } Response: { \"status\": \"success\", \"data\": { \"version\": \"1.1\", \"result\": [ { \"value\": \"contact_john_johnson\", \"confidence\": 1.0, \"grammar_entry\": \"John Johnson\" }, { \"value\": \"contact_john_thompson\", \"confidence\": 1.0, \"grammar_entry\": \"John Thompson\" } ] } } Also note that for this request example, the service may return an empty list of results if no matching contacts were found for the given parameters.","title":"Additional query example: Multiple results"},{"location":"APIs/http_service.html#entity-recognizer-requests","text":"Entity recognizers are invoked by TDM to identify entities in user utterances. Request Below is an example of a request body for an entity recognition invocation when the user has said \"what is the temperature in London\": { \"version\": \"1.1\", \"session\": { \"session_id\": \"0000-abcd-1111-efgh\" }, \"request\": { \"type\": \"entity_recognizer\", \"name\": \"LocationRecognizer\", \"utterance\": \"what is the temperature in London\" }, \"context\": { \"active_ddd\": \"MyDDD\", \"facts\": {}, \"language\": \"eng\", \"invocation_id\": \"2222-ijkl-3333-mnop\" } } Format for request : see Request object . The request object additionally contains these members specific to entity recognizers: utterance is the user utterance that should be searched for entities. It's a string. Format for session : see Session object . Format for context : see Context object . Response Below is an example of a response body for the request above: { \"status\": \"success\", \"data\": { \"version\": \"1.1\", \"result\": [ { \"grammar_entry\": \"London\", \"sort\": \"city\", \"value\": \"city_012345\" } ] } } General format for responses: see Response format . data additionally contains these members specific to entity recognizers: result : contains a list of zero or more result items. Each result item is an object with the following members: grammar_entry : Natural-language representation of the recognized entity. sort : The entity's sort, corresponding to the sort's name in ontology.xml . value : ID or semantic representation of the entity if known, otherwise null . For static (non-dynamic) sorts, the value is mandatory and should correspond to the semantic name of an individual.","title":"Entity recognizer requests"},{"location":"APIs/http_service.html#validator-requests","text":"Validators are invoked by TDM to determine if information provided by the user is valid. If not, relevant feedback is given to the user. Request Below is an example of a request body for a validator called RouteValidator with the parameters departure and destination : { \"version\": \"1.1\", \"session\": { \"session_id\": \"0000-abcd-1111-efgh\" }, \"request\": { \"type\": \"validator\", \"name\": \"RouteValidator\", \"parameters\": { \"departure\": { \"sort\": \"city\", \"value\": \"city_012345\", \"grammar_entry\": \"London\" }, \"destination\": { \"sort\": \"city\", \"value\": \"city_099998\", \"grammar_entry\": \"Chippinghirst\" } } }, \"context\": { \"active_ddd\": \"MyDDD\", \"facts\": { \"departure\": { \"sort\": \"city\", \"value\": \"city_012345\", \"grammar_entry\": \"London\" }, \"destination\": { \"sort\": \"city\", \"value\": \"city_099998\", \"grammar_entry\": \"Chippinghirst\" } }, \"language\": \"eng\", \"invocation_id\": \"2222-ijkl-3333-mnop\" } } Format for request : see Request object . Format for session : see Session object . Format for context : see Context object . Response Below is an example of a response body for the request above: { \"status\": \"success\", \"data\": { \"version\": \"1.1\", \"is_valid\": false } } General format for responses: see Response format . data additionally contains these validator specific members: is_valid : can be either true or false , specifying whether the combination of parameters is valid or not.","title":"Validator requests"},{"location":"APIs/http_service.html#request-object","text":"In general, the request object contains the following members. It may also contain additional method specific members. type is the method type, e.g. action or query . All methods that can be declared in service_interface.xml are supported. See examples for each of them above. name is the method name, as specified in service_interface.xml . parameters contains values for all parameters that are specified for the method in service_interface.xml . If a parameter is unknown, its value is null . Otherwise it's an object containing: sort : ID of the predicate's sort as defined in the ontology. value : ID of the value. For the sorts integer and real , the ID is a number. For other sorts, e.g. string , datetime and custom sorts, the ID is a string. grammar_entry : Natural-language representation of the value. Example: { \"request\": { \"type\": \"validator\", \"name\": \"contact_validator\", \"parameters\": { \"selected_first_name\": { \"sort\": \"first_name\", \"value\": \"fist_name_john\", \"grammar_entry\": \"John\" }, \"selected_last_name\": null } } }","title":"Request object"},{"location":"APIs/http_service.html#session-object","text":"The session object contains the following members: session_id : String representing the current TDM session. Additionally, it contains the same data that was injected in the frontend request to TDM. This way, service calls can utilize frontend-specific session data. For more details, read about the session object in the frontend API docs Example: { \"session\": { \"session_id\": \"0000-abcd-1111-efgh\", \"my_frontend\": { \"user_id\": \"123-abc-456-def\", \"position\": { \"latitude\": \"57.699188\", \"longitude\": \"11.948313\" } } } }","title":"Session object"},{"location":"APIs/http_service.html#context-object","text":"The context object contains the following members: active_ddd : The name of the currently active DDD. facts : Information gathered during the conversation (see Facts object ). language : ID of the current language. invocation_id : A unique identifer for the invocation from TDM. This ID can be logged for analytics and issue reporting.","title":"Context object"},{"location":"APIs/http_service.html#facts-object","text":"The facts object contains a map of key-value pairs for information gathered during the conversation, e.g. from the user. The map may be empty. The key is a string matching a predicate as defined in the ontology. The value is an object with the following members: sort : ID of the predicate's sort as defined in the ontology. value : ID of the value. For the sorts integer and real , the ID is a number. For other sorts, e.g. string , datetime and custom sorts, the ID is a string. grammar_entry : Natural-language representation of the value. Example: { \"facts\": { \"departure\": { \"sort\": \"city\", \"value\": \"city_012345\", \"grammar_entry\": \"London\" }, \"destination\": { \"sort\": \"city\", \"value\": \"city_012346\", \"grammar_entry\": \"Newcastle\" } } }","title":"Facts object"},{"location":"APIs/http_service.html#response-format","text":"All service responses adhere to the JSend specification . In general, responses can have one of three appearances, corresponding to the status of the invocation: success , fail and error . See the examples below. Success: { \"status\": \"success\", \"data\": { \"version\": \"1.1\" } } Successful method invocations need to set their status to success . The data object contains mostly method specific members. All methods need however include: version : the version of the API used to process the request and format the response. If the version is not compatible with the request, TDM reports an error to the user. Fail: { \"status\": \"fail\", \"data\": { \"version\": \"1.1\" } } Failures cannot be used with queries, entity recognizers or validators, but is supported by actions . If a fail status is not supported or is reported unexpectedly, it is treated as an error . error is however preferred over fail since a helpful message can be provided. TDM will report the error to the user, but will not mention any details. To report a failure, the status need to be set to fail . The data object contains mostly method specific members. All methods need however include: version : the version of the API used to process the request and format the response. Error: { \"status\": \"error\", \"message\": \"Could not communicate with the database.\", \"code\": 135, \"data\": { \"version\": \"1.1\" } } When a service encounters an error, i.e. an exception, the status need to be set to error . TDM will report the error to the user, but will not mention any details. message should be a human-readable message, explaining what went wrong. It will be logged but is not exposed to end-users. code (optional) is a numeric code identifying the error, if applicable. The data needs to contain: version : the version of the API used to process the request and format the response.","title":"Response format"}]}