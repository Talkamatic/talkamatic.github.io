{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting started \u00b6 Welcome to the Talkamatic documentation. The site you just entered describes: the foundation of our technologies, most notably the Dialog formalism that models our entire dialog universe some assistance for dialog designers , a tutorial and some publicly available code examples among other things API definitions , whether you integrate the TDM Pipeline into your software stack, build your own NLU or create your own domain-specific service doesn't matter, it's all there Additionally, there's further illustrated reading about TDM wrapped into a PDF here .","title":"Getting started"},{"location":"#getting-started","text":"Welcome to the Talkamatic documentation. The site you just entered describes: the foundation of our technologies, most notably the Dialog formalism that models our entire dialog universe some assistance for dialog designers , a tutorial and some publicly available code examples among other things API definitions , whether you integrate the TDM Pipeline into your software stack, build your own NLU or create your own domain-specific service doesn't matter, it's all there Additionally, there's further illustrated reading about TDM wrapped into a PDF here .","title":"Getting started"},{"location":"formalism/","text":"Dialog Formalism \u00b6 The Dialog Formalism is a formal language for expressing semantics and domain knowledge within the framework of issue-based dialog management (Larsson, 2002) 1 based on the information state approach (Larsson, Traum, 2000) 2 , (Traum, Larsson, 2003) 3 , which is the foundation of TDM. For readers familiar with logic, the Dialog Formalism is closely related to first-order predicate logic. Some of the constructs of the Dialog Formalism are described below, with corresponding example expressions. Semantics \u00b6 The Dialog Formalism covers semantics, constructs that occur in language, regardless of the actual language. Predicates \u00b6 Predicates are used to formalise the meanings of nouns, verbs and adjectives. They typically correspond to slots in form-based (slot-filling) dialog management. Example: selected_contact Individuals \u00b6 Individuals can be arguments of predicates, which corresponds to being values of slots in form-based dialog management. It also aligns with the term \"entity\" used in many other contexts. In TDM, yes and no are modelled as individuals, even if they are not individuals in the concrete sense, but this allows them to be used in answers. Examples: contact_john , which would correspond to John in natural language. yes no Propositions \u00b6 A proposition expresses something that can be true or false, can be believed to be true, or can be taken as a fact. Propositions have a predicate , a polarity (positive or negative), an arity (nullary or unary) and optionally an argument (an individual , typically). Negative polarity is expressed using the negation operator ~ as prefix. Nullary proposition \u00b6 A nullary proposition has no argument. Examples: need_visa expresses that a visa is needed. ~need_visa expresses that a visa is not needed. Unary propositions \u00b6 A unary proposition takes an individual as an argument. Examples: selected_contact(contact_john) expresses that the selected contact is John. ~selected_contact(contact_john) expresses that the selected contact is not John. Goal propositions \u00b6 A goal proposition expresses that a particular goal should be targeted. It has the form goal(G) where G is a goal . Examples: goal(perform(call)) expresses that the goal of performing call should be targeted. goal(resolve(?X.phone_number(X))) expresses that the goal of resolving ?X.phone_number(X) should be targeted. Actions \u00b6 An action is something that can be performed. Example: call Questions \u00b6 A question is something that can be asked, answered and resolved. Its expression begins with the question operator ? . Yes-no questions \u00b6 A yes-no question is a question that can be answered with a yes or no. Examples: ?need_visa expresses a question regarding whether a visa is needed. ?selected_contact(contact_john) expresses a question regarding whether the selected contact is John. WH questions \u00b6 A WH question is a question about what, when, where etc. It is expressed as a lambda abstraction. Example: ?X.selected_contact(X) expresses a question about which contact to select. Alternative questions \u00b6 An alternative question is a question containing multiple alternative answers expressed as a set of propositions. Example: ?set([number_to_call(home), number_to_call(mobile)]) expresses a question about whether to call the home or mobile number. Moves \u00b6 (Dialog) moves reflect the meaning and function of something that is communicated in a dialog. Utterances spoken by the user or system correspond to sequences of moves. TDM supports many different kinds of dialog moves, the most common of which are described below. Ask moves \u00b6 An ask move represents the act of asking a question. It has the form ask(Q) where Q is a question . Example: ask(?X.selected_contact(X)) Request moves \u00b6 A request move represents the act of requesting an action that needs to be performed. It has the form request(A) where A is an action . Example: request(call) Answer moves \u00b6 An answer move represents the act of answering a question. It has the form answer(A) where A can be a proposition (in a so called propositional answer) or an individual (in a so called sortal answer). The individual of a sortal answer combines with a question to form a proposition; for example, the question ?x.selected_name(x) combined with the individual contact_john forms the proposition selected_name(contact_john) . Examples: answer(contact_john) answer(selected_contact(contact_john)) answer(yes) answer(no) Domain knowledge \u00b6 In addition to semantics, the Dialog Formalism also covers domain knowledge such as goals and (the contents of) plans. Goals \u00b6 A goal expresses an action to perform or a question to resolve, as elaborated below. Perform goals \u00b6 A perform goal has the form perform(A) where A is an action . Example: perform(call) expresses the goal of performing the action call . Resolve goals \u00b6 A resolve goal has the form resolve(Q) where Q is a question . Example: resolve(?X.phone_number(X)) expresses the goal of resolving the question ?X.phone_number(X) . Plan items \u00b6 For every goal, there is a corresponding plan for how the goal can be fulfilled. Plans are however not fully expressed in the dialog formalism, but instead covered by the XML domain format of dialog domain descriptions . Individual plan items, the pieces that the plan consists of and each an instruction to TDM, can be expressed though. This section describes some of the most common items. Findout \u00b6 A findout item expresses an instruction to find the answer to a question, e.g. by asking the user or asking a service. Example: findout(?X.selected_contact(X)) Bind \u00b6 The bind(Q) construction, where Q is a question, lets the system understand answers to a question Q that it does not ask explicitly. This makes it possible to take optional and unrequested parameters that the user provides into consideration. For example, if bind(?x.price-class(x)) is in a plan in a travel agency domain, the system will understand something like \"I would like to travel business class\", but it will not ask e.g. \"What price class did you have in mind?\". Invoke service action \u00b6 An invoke_service_action expresses an action to be performed by a service. Example: invoke_service_action(Call, {preconfirm=interrogative, postconfirm=True, downdate_plan=False}) Invoke service query \u00b6 An invoke_service_query expresses an instruction to find the answer to a question by asking a service. Example: invoke_service_query(?X.phone_number(X)) Larsson, S. (2002). Issue-based dialogue management. Department of Linguistics, University of Gothenburg. \u21a9 Larsson, S., & Traum, D. R. (2000). Information state and dialogue management in the TRINDI dialogue move engine toolkit. Natural language engineering, 6(3-4), 323-340. \u21a9 Traum, D. R., & Larsson, S. (2003). The information state approach to dialogue management. In Current and new directions in discourse and dialogue (pp. 325-353). Springer, Dordrecht. \u21a9","title":"Dialog formalism"},{"location":"formalism/#dialog-formalism","text":"The Dialog Formalism is a formal language for expressing semantics and domain knowledge within the framework of issue-based dialog management (Larsson, 2002) 1 based on the information state approach (Larsson, Traum, 2000) 2 , (Traum, Larsson, 2003) 3 , which is the foundation of TDM. For readers familiar with logic, the Dialog Formalism is closely related to first-order predicate logic. Some of the constructs of the Dialog Formalism are described below, with corresponding example expressions.","title":"Dialog Formalism"},{"location":"formalism/#semantics","text":"The Dialog Formalism covers semantics, constructs that occur in language, regardless of the actual language.","title":"Semantics"},{"location":"formalism/#predicates","text":"Predicates are used to formalise the meanings of nouns, verbs and adjectives. They typically correspond to slots in form-based (slot-filling) dialog management. Example: selected_contact","title":"Predicates"},{"location":"formalism/#individuals","text":"Individuals can be arguments of predicates, which corresponds to being values of slots in form-based dialog management. It also aligns with the term \"entity\" used in many other contexts. In TDM, yes and no are modelled as individuals, even if they are not individuals in the concrete sense, but this allows them to be used in answers. Examples: contact_john , which would correspond to John in natural language. yes no","title":"Individuals"},{"location":"formalism/#propositions","text":"A proposition expresses something that can be true or false, can be believed to be true, or can be taken as a fact. Propositions have a predicate , a polarity (positive or negative), an arity (nullary or unary) and optionally an argument (an individual , typically). Negative polarity is expressed using the negation operator ~ as prefix.","title":"Propositions"},{"location":"formalism/#nullary-proposition","text":"A nullary proposition has no argument. Examples: need_visa expresses that a visa is needed. ~need_visa expresses that a visa is not needed.","title":"Nullary proposition"},{"location":"formalism/#unary-propositions","text":"A unary proposition takes an individual as an argument. Examples: selected_contact(contact_john) expresses that the selected contact is John. ~selected_contact(contact_john) expresses that the selected contact is not John.","title":"Unary propositions"},{"location":"formalism/#goal-propositions","text":"A goal proposition expresses that a particular goal should be targeted. It has the form goal(G) where G is a goal . Examples: goal(perform(call)) expresses that the goal of performing call should be targeted. goal(resolve(?X.phone_number(X))) expresses that the goal of resolving ?X.phone_number(X) should be targeted.","title":"Goal propositions"},{"location":"formalism/#actions","text":"An action is something that can be performed. Example: call","title":"Actions"},{"location":"formalism/#questions","text":"A question is something that can be asked, answered and resolved. Its expression begins with the question operator ? .","title":"Questions"},{"location":"formalism/#yes-no-questions","text":"A yes-no question is a question that can be answered with a yes or no. Examples: ?need_visa expresses a question regarding whether a visa is needed. ?selected_contact(contact_john) expresses a question regarding whether the selected contact is John.","title":"Yes-no questions"},{"location":"formalism/#wh-questions","text":"A WH question is a question about what, when, where etc. It is expressed as a lambda abstraction. Example: ?X.selected_contact(X) expresses a question about which contact to select.","title":"WH questions"},{"location":"formalism/#alternative-questions","text":"An alternative question is a question containing multiple alternative answers expressed as a set of propositions. Example: ?set([number_to_call(home), number_to_call(mobile)]) expresses a question about whether to call the home or mobile number.","title":"Alternative questions"},{"location":"formalism/#moves","text":"(Dialog) moves reflect the meaning and function of something that is communicated in a dialog. Utterances spoken by the user or system correspond to sequences of moves. TDM supports many different kinds of dialog moves, the most common of which are described below.","title":"Moves"},{"location":"formalism/#ask-moves","text":"An ask move represents the act of asking a question. It has the form ask(Q) where Q is a question . Example: ask(?X.selected_contact(X))","title":"Ask moves"},{"location":"formalism/#request-moves","text":"A request move represents the act of requesting an action that needs to be performed. It has the form request(A) where A is an action . Example: request(call)","title":"Request moves"},{"location":"formalism/#answer-moves","text":"An answer move represents the act of answering a question. It has the form answer(A) where A can be a proposition (in a so called propositional answer) or an individual (in a so called sortal answer). The individual of a sortal answer combines with a question to form a proposition; for example, the question ?x.selected_name(x) combined with the individual contact_john forms the proposition selected_name(contact_john) . Examples: answer(contact_john) answer(selected_contact(contact_john)) answer(yes) answer(no)","title":"Answer moves"},{"location":"formalism/#domain-knowledge","text":"In addition to semantics, the Dialog Formalism also covers domain knowledge such as goals and (the contents of) plans.","title":"Domain knowledge"},{"location":"formalism/#goals","text":"A goal expresses an action to perform or a question to resolve, as elaborated below.","title":"Goals"},{"location":"formalism/#perform-goals","text":"A perform goal has the form perform(A) where A is an action . Example: perform(call) expresses the goal of performing the action call .","title":"Perform goals"},{"location":"formalism/#resolve-goals","text":"A resolve goal has the form resolve(Q) where Q is a question . Example: resolve(?X.phone_number(X)) expresses the goal of resolving the question ?X.phone_number(X) .","title":"Resolve goals"},{"location":"formalism/#plan-items","text":"For every goal, there is a corresponding plan for how the goal can be fulfilled. Plans are however not fully expressed in the dialog formalism, but instead covered by the XML domain format of dialog domain descriptions . Individual plan items, the pieces that the plan consists of and each an instruction to TDM, can be expressed though. This section describes some of the most common items.","title":"Plan items"},{"location":"formalism/#findout","text":"A findout item expresses an instruction to find the answer to a question, e.g. by asking the user or asking a service. Example: findout(?X.selected_contact(X))","title":"Findout"},{"location":"formalism/#bind","text":"The bind(Q) construction, where Q is a question, lets the system understand answers to a question Q that it does not ask explicitly. This makes it possible to take optional and unrequested parameters that the user provides into consideration. For example, if bind(?x.price-class(x)) is in a plan in a travel agency domain, the system will understand something like \"I would like to travel business class\", but it will not ask e.g. \"What price class did you have in mind?\".","title":"Bind"},{"location":"formalism/#invoke-service-action","text":"An invoke_service_action expresses an action to be performed by a service. Example: invoke_service_action(Call, {preconfirm=interrogative, postconfirm=True, downdate_plan=False})","title":"Invoke service action"},{"location":"formalism/#invoke-service-query","text":"An invoke_service_query expresses an instruction to find the answer to a question by asking a service. Example: invoke_service_query(?X.phone_number(X)) Larsson, S. (2002). Issue-based dialogue management. Department of Linguistics, University of Gothenburg. \u21a9 Larsson, S., & Traum, D. R. (2000). Information state and dialogue management in the TRINDI dialogue move engine toolkit. Natural language engineering, 6(3-4), 323-340. \u21a9 Traum, D. R., & Larsson, S. (2003). The information state approach to dialogue management. In Current and new directions in discourse and dialogue (pp. 325-353). Springer, Dordrecht. \u21a9","title":"Invoke service query"},{"location":"ibdm/","text":"Issue-based Dialogue Management \u00b6 The goal of all practical dialogue is to communicate information which is useful in some activity. This means that conversational goals should describe missing information, and to fulfil a conversational goal, what we need to do is to communicate the missing information. Issues, or questions, are essentially entities specifying certain pieces of as-yet-unavailable information. That is, conversational goals can to a large extent be modelled as questions. The issue-based approach to dialogue management has proven very useful for implementing important mechanisms dealing with general (cross-domain) aspects of dialogue, such as inquiry-oriented dialogue interactions, dealing with multiple simultaneous tasks, sharing information between tasks, grounding, interactive communication management, question accommodation, belief revision, action-oriented dialogue, and negotiative dialogue.","title":"Issue-based Dialogue Management"},{"location":"ibdm/#issue-based-dialogue-management","text":"The goal of all practical dialogue is to communicate information which is useful in some activity. This means that conversational goals should describe missing information, and to fulfil a conversational goal, what we need to do is to communicate the missing information. Issues, or questions, are essentially entities specifying certain pieces of as-yet-unavailable information. That is, conversational goals can to a large extent be modelled as questions. The issue-based approach to dialogue management has proven very useful for implementing important mechanisms dealing with general (cross-domain) aspects of dialogue, such as inquiry-oriented dialogue interactions, dealing with multiple simultaneous tasks, sharing information between tasks, grounding, interactive communication management, question accommodation, belief revision, action-oriented dialogue, and negotiative dialogue.","title":"Issue-based Dialogue Management"},{"location":"api-definitions/nlg_api/","text":"NLG API \u00b6 This document describes version 1.0 of the API for Natural Language Generation (NLG) components, enabling 3 rd party NLGs to integrate with the TDM pipeline. It covers how the TDM pipeline sends requests to the NLG, and how it expects responses to come back. The endpoint that the TDM pipeline calls to reach the NLG is configurable on the pipeline side, but it's recommended to accept requests on the root URL, e.g: http://nlg/ . Request \u00b6 When the TDM pipeline needs to generate what the system is saying, it sends a request to the NLG. The request contains moves from the dialog manager. Example: { \"version\" : \"1.0\" , \"moves\" : [ { \"semantic_expression\" : \"icm:acc*pos\" }, { \"semantic_expression\" : \"ask(?X.selected_contact(X))\" } ] } The following members are required: version : The version that the consumer is expecting served. This is used to detect compatibility problems. moves : A list of Move objects . Response \u00b6 The NLG generates a natural language utterance. It can either succeed its generation, or fail if it doesn't cover the moves sent to it. General example \u00b6 { \"status\" : \"success\" , ... } All responses need to contain the following members: status : success if the NLG successfully generated an utterance, fail if it failed and error if an error happened unexpectedly. Success \u00b6 When the NLG succeeds in generating its utterance, use the success response. { \"status\" : \"success\" , \"utterance\" : \"Who do you want to call?\" } When status is success , the following members need to be present: utterance : A string with the generated utterance. Failure \u00b6 When the NLG fails to generate an utterance, for instance because one of the moves sent to it isn't covered, use the fail response. { \"status\" : \"fail\" } Error \u00b6 When an error occurs unexpectedly, use the error response. { \"status\" : \"error\" , \"description\" : \"A helpful description of the error.\" } When status is error , the following members need to be present: message : A string with a helpful message. code (optional): A numeric code identifying the error, if applicable.","title":"NLG API"},{"location":"api-definitions/nlg_api/#nlg-api","text":"This document describes version 1.0 of the API for Natural Language Generation (NLG) components, enabling 3 rd party NLGs to integrate with the TDM pipeline. It covers how the TDM pipeline sends requests to the NLG, and how it expects responses to come back. The endpoint that the TDM pipeline calls to reach the NLG is configurable on the pipeline side, but it's recommended to accept requests on the root URL, e.g: http://nlg/ .","title":"NLG API"},{"location":"api-definitions/nlg_api/#request","text":"When the TDM pipeline needs to generate what the system is saying, it sends a request to the NLG. The request contains moves from the dialog manager. Example: { \"version\" : \"1.0\" , \"moves\" : [ { \"semantic_expression\" : \"icm:acc*pos\" }, { \"semantic_expression\" : \"ask(?X.selected_contact(X))\" } ] } The following members are required: version : The version that the consumer is expecting served. This is used to detect compatibility problems. moves : A list of Move objects .","title":"Request"},{"location":"api-definitions/nlg_api/#response","text":"The NLG generates a natural language utterance. It can either succeed its generation, or fail if it doesn't cover the moves sent to it.","title":"Response"},{"location":"api-definitions/nlg_api/#general-example","text":"{ \"status\" : \"success\" , ... } All responses need to contain the following members: status : success if the NLG successfully generated an utterance, fail if it failed and error if an error happened unexpectedly.","title":"General example"},{"location":"api-definitions/nlg_api/#success","text":"When the NLG succeeds in generating its utterance, use the success response. { \"status\" : \"success\" , \"utterance\" : \"Who do you want to call?\" } When status is success , the following members need to be present: utterance : A string with the generated utterance.","title":"Success"},{"location":"api-definitions/nlg_api/#failure","text":"When the NLG fails to generate an utterance, for instance because one of the moves sent to it isn't covered, use the fail response. { \"status\" : \"fail\" }","title":"Failure"},{"location":"api-definitions/nlg_api/#error","text":"When an error occurs unexpectedly, use the error response. { \"status\" : \"error\" , \"description\" : \"A helpful description of the error.\" } When status is error , the following members need to be present: message : A string with a helpful message. code (optional): A numeric code identifying the error, if applicable.","title":"Error"},{"location":"api-definitions/nlu_api/","text":"NLU API \u00b6 This document describes the API for NLUs, enabling 3 rd party NLUs to integrate with the TDM pipeline. It covers how the TDM pipeline sends requests to the NLU, and how it expects responses to come back. The endpoint that the TDM pipeline calls to reach the NLU is configurable on the pipeline side, but it's recommended to accept requests on the root URL, e.g: http://nlu/ . Request \u00b6 When the TDM pipeline needs to understand what a user has said, it sends a request to the NLU. The request contains natural language input consisting of either hypotheses with the speech modality, or a single utterance with the text modality. See the natural language input object . Example: { \"modality\" : \"speech\" , \"hypotheses\" : [ { \"utterance\" : \"I want chinese\" , \"confidence\" : 0.86 }, ] } Response \u00b6 The NLU's output must be converted into semantic input containing interpretations and entities . See the semantic input object . Example: { \"interpretations\" : [ { \"utterance\" : \"I want to have chinese food\" , \"modality\" : \"speech\" , \"moves\" : [ { \"perception_confidence\" : 0.86 , \"understanding_confidence\" : 0.92215 , \"ddd\" : \"my_restaurants\" , \"semantic_expression\" : \"request(restaurant_search)\" }, { \"perception_confidence\" : 0.86 , \"understanding_confidence\" : 0.98532 , \"ddd\" : \"my_restaurants\" , \"semantic_expression\" : \"answer(cuisine_chinese)\" } ] }, { \"utterance\" : \"I want to have chinese food\" , \"modality\" : \"speech\" , \"moves\" : [ { \"perception_confidence\" : 0.86 , \"understanding_confidence\" : 0.5234 , \"ddd\" : \"my_restaurants\" , \"semantic_expression\" : \"request(restaurant_search)\" } ] } ], \"entities\" : [ { \"name\" : \"cuisine_chinese\" , \"sort\" : \"cuisine\" , \"natural_language_form\" : \"chinese\" , \"ddd\" : \"my_restaurants\" } ] }","title":"NLU API"},{"location":"api-definitions/nlu_api/#nlu-api","text":"This document describes the API for NLUs, enabling 3 rd party NLUs to integrate with the TDM pipeline. It covers how the TDM pipeline sends requests to the NLU, and how it expects responses to come back. The endpoint that the TDM pipeline calls to reach the NLU is configurable on the pipeline side, but it's recommended to accept requests on the root URL, e.g: http://nlu/ .","title":"NLU API"},{"location":"api-definitions/nlu_api/#request","text":"When the TDM pipeline needs to understand what a user has said, it sends a request to the NLU. The request contains natural language input consisting of either hypotheses with the speech modality, or a single utterance with the text modality. See the natural language input object . Example: { \"modality\" : \"speech\" , \"hypotheses\" : [ { \"utterance\" : \"I want chinese\" , \"confidence\" : 0.86 }, ] }","title":"Request"},{"location":"api-definitions/nlu_api/#response","text":"The NLU's output must be converted into semantic input containing interpretations and entities . See the semantic input object . Example: { \"interpretations\" : [ { \"utterance\" : \"I want to have chinese food\" , \"modality\" : \"speech\" , \"moves\" : [ { \"perception_confidence\" : 0.86 , \"understanding_confidence\" : 0.92215 , \"ddd\" : \"my_restaurants\" , \"semantic_expression\" : \"request(restaurant_search)\" }, { \"perception_confidence\" : 0.86 , \"understanding_confidence\" : 0.98532 , \"ddd\" : \"my_restaurants\" , \"semantic_expression\" : \"answer(cuisine_chinese)\" } ] }, { \"utterance\" : \"I want to have chinese food\" , \"modality\" : \"speech\" , \"moves\" : [ { \"perception_confidence\" : 0.86 , \"understanding_confidence\" : 0.5234 , \"ddd\" : \"my_restaurants\" , \"semantic_expression\" : \"request(restaurant_search)\" } ] } ], \"entities\" : [ { \"name\" : \"cuisine_chinese\" , \"sort\" : \"cuisine\" , \"natural_language_form\" : \"chinese\" , \"ddd\" : \"my_restaurants\" } ] }","title":"Response"},{"location":"api-definitions/pipeline_api/","text":"Pipeline API \u00b6 This document describes API version 3.3 for HTTP frontends, enabling frontends to integrate with TDM over HTTP. It covers e.g. how input from the user and output from TDM are communicated between TDM and the client. Important concepts \u00b6 This section describes some concepts that are important to understand and comply with when integrating TDM in a dialog system. Requests and responses \u00b6 TDM serves an HTTP server and responds to requests done by the client. The client is the consumer of the API outlined in this document. The client invokes TDM with an HTTP request to the interaction endpoint, e.g. http://localhost:9090/interact , using the POST method and a JSON body. The client should expect the status code to be 200 OK. For other status codes, the client should report an error to the user. The request body always contains a version number, specifying the version of the HTTP API format. The exact format of the request and the response depends on the type of request as described in the separate sections below. Turn taking \u00b6 Turn taking is a vital part of dialog between humans, read for instance the Wikipedia article . Since TDM is based on research on human-human dialog, turn taking is a central concept here too. The TDM client is responsible for managing turn-taking on behalf of the machine, because it's the component that is closest to the human, in the human-machine dialog that TDM enables. Since the machine is intended to assist the human, the human decides the pace, the turn taking, of the conversation. In spoken dialog, turn taking happens in close collaboration with the spoken output of the system, which means that the system's turn management needs to happen as close to this component, the text-to-speech component (TTS), as possible. TDM enables intuitive turn taking by instructing its client how to deal with the user input that it's range of sensors can pick up. The instructions are straightforward and revolve around passivity. If the user is passive, for instance doesn't know what to say, for a given amount of time, the client sends TDM a passivity request , which lets the system take the next turn instead of the user. The user should be considered passive when not doing anything related to the dialog. If the user however takes some action (although not completing its turn just yet), for instance by typing (if it's a text interface) or talking (if it's a spoken interface), the user should be considered active and the passivity request should not be sent to TDM. Instead the user should be allowed to complete its turn, resulting in an input request. TDM instructs its client about how much time of passivity that should pass before sending the passivity request in the output.expected_passivity field of the response . For instance, if TDM responds with: { \"output\" : { ... \"expected_passivity\" : 1.0 }, ... } then the client should send a passivity request when the user has been passive for 1 second. The 1 second should start counting when the system utterance has reached the user, which in a spoken interface means when the TTS finished speaking TDM's utterance. Note that sometimes TDM does not have anything to say when the user becomes passive ( \"expected_passivity\": null ), and sometimes it just needs to progress the conversation immediately after saying something ( \"expected_passivity\": 0.0 ). Read the details about how to interpret the expected_passivity value in the response format section . Errors \u00b6 When an error occurs in TDM during a request, for instance due to incomplete turn management, the response contains the \"error\" field. It's important to note that this could mean that the session stops. If it has stopped, further requests on the same session will report errors that the provided session ID is unknown. Start session requests \u00b6 When a new session should be started, the client issues a start_session request. The response contains initial output from TDM and a session ID that can be used in subsequent requests. For more details, see the response format . If a session ID is provided together with the start_session request, an error is given. The integrity of the session is however maintained. Request \u00b6 Example: { \"version\" : \"3.3\" , \"session\" : {}, \"request\" : { \"start_session\" : {} } } The session object can contain frontend-specific session data to be used in dialog or by services. For more details, see the session object . The start_session object may contain the following optional members: ddd_set : A string specifying a DDD set for the session. If omitted, a default DDD set configured by the backend is used. The start_session request may be issued on its own, so that the system will start the conversation; or combined with natural_language_input , semantic_input and event requests to start the conversation from there. Example when combined with natural_language_input : { \"version\" : \"3.3\" , \"request\" : { \"start_session\" : {}, \"natural_language_input\" : { ... } } } Response \u00b6 See response format . Natural language input requests \u00b6 When the client detects natural language input from the user, it issues a request and receives output from TDM. The request can contain either hypotheses with the speech modality, or a single utterance with the text modality. Request \u00b6 Speech input example: { \"version\" : \"3.3\" , \"session\" : { \"session_id\" : \"0000-abcd-1111-efgh\" }, \"request\" : { \"natural_language_input\" : { \"modality\" : \"speech\" , \"hypotheses\" : [ { \"utterance\" : \"call John\" , \"confidence\" : 0.81 }, { \"utterance\" : \"calling John\" , \"confidence\" : 0.65 }, { \"utterance\" : \"call him John\" , \"confidence\" : 0.31 } ] } } } Text input example: { \"version\" : \"3.3\" , \"session\" : { \"session_id\" : \"0000-abcd-1111-efgh\" }, \"request\" : { \"natural_language_input\" : { \"modality\" : \"text\" , \"utterance\" : \"I'm searching for flights from London to Paris tomorrow\" } } } The session object can contain frontend-specific session data to be used in dialog or by services. For more details, see the session object See the natural language input object for more details. The natural_language_input request may be combined with the start_session request when a session does not yet exist, but may not be combined with other requests. Example: { \"version\" : \"3.3\" , \"request\" : { \"start_session\" : {}, \"natural_language_input\" : { ... } } } Response \u00b6 See response format . Semantic input requests \u00b6 When the client has user input on a semantic format, as a user move, it should issue the semantic_input request. Semantic in this case means that the user input does not need to be interpreted; the user move is already known. This is useful when an external natural language understanding (NLU) component has already interpreted the input; when the user presses a button in a GUI; or for instance when the user makes a gesture which is interpreted as a user move. Request \u00b6 { \"version\" : \"3.3\" , \"session\" : { \"session_id\" : \"0000-abcd-1111-efgh\" }, \"request\" : { \"semantic_input\" : { \"interpretations\" : [ { \"utterance\" : \"call John\" , \"modality\" : \"speech\" , \"moves\" : [ { \"perception_confidence\" : 0.81 , \"understanding_confidence\" : 0.92215 , \"ddd\" : \"phone\" , \"semantic_expression\" : \"request(call)\" }, { \"perception_confidence\" : 0.81 , \"understanding_confidence\" : 0.98532 , \"ddd\" : \"phone\" , \"semantic_expression\" : \"answer(contact_john)\" } ] }, { \"utterance\" : \"calling John\" , \"modality\" : \"speech\" , \"moves\" : [ { \"perception_confidence\" : 0.65 , \"understanding_confidence\" : 0.5234 , \"ddd\" : \"phone\" , \"semantic_expression\" : \"request(call)\" }, { \"perception_confidence\" : 0.65 , \"understanding_confidence\" : 0.98532 , \"ddd\" : \"phone\" , \"semantic_expression\" : \"answer(contact_john)\" } ] }, { \"utterance\" : \"call him John\" , \"modality\" : \"speech\" , \"moves\" : [ { \"perception_confidence\" : 0.31 , \"understanding_confidence\" : 0.2216 , \"ddd\" : \"phone\" , \"semantic_expression\" : \"request(call)\" }, { \"perception_confidence\" : 0.31 , \"understanding_confidence\" : 0.98532 , \"ddd\" : \"phone\" , \"semantic_expression\" : \"answer(contact_john)\" } ] }, { \"utterance\" : \"call him John\" , \"modality\" : \"speech\" , \"moves\" : [ { \"perception_confidence\" : 0.31 , \"understanding_confidence\" : 0.10126 , \"ddd\" : \"phone\" , \"semantic_expression\" : \"ask(?X.phone_number(X))\" }, { \"perception_confidence\" : 0.31 , \"understanding_confidence\" : 0.98532 , \"ddd\" : \"phone\" , \"semantic_expression\" : \"answer(contact_john)\" } ] } ], \"entities\" : [ { \"name\" : \"contact_john\" , \"sort\" : \"contact\" , \"natural_language_form\" : \"John\" , \"ddd\" : \"phone\" } ] } } } The session object can contain frontend-specific session data to be used in dialog or by services. For more details, see the session object . interpretations : A list of interpretation objects . TDM will use confidence scores and the context of the current state of the session to decide which interpretation to act upon. entities : (optional) A list of entity objects . TDM can use these entities in interpretations and for natural language generation. See the semantic input object for more details. The semantic_input request may be combined with the start_session request when a session does not yet exist, but may not be combined with other requests. Example: { \"version\" : \"3.3\" , \"request\" : { \"start_session\" : {}, \"semantic_input\" : { ... } } } Response \u00b6 See response format . Passivity requests \u00b6 When the client detects user passivity, it issues a request and receives output from TDM. Request \u00b6 Example: { \"version\" : \"3.3\" , \"session\" : { \"session_id\" : \"0000-abcd-1111-efgh\" }, \"request\" : { \"passivity\" : {} } } The session object can contain frontend-specific session data to be used in dialog or by services. For more details, see the session object . The passivity request may not be combined with other requests in the same call. Response \u00b6 See response format . Event requests \u00b6 When the client detects that an event pertaining to a relevant DDD has occurred, it should issue an event notification request, and receives output from TDM. Request \u00b6 Example: { \"version\" : \"3.3\" , \"session\" : { \"session_id\" : \"0000-abcd-1111-efgh\" }, \"request\" : { \"event\" : { \"name\" : \"IncomingCall\" , \"status\" : \"started\" , \"parameters\" : { \"caller\" : \"contact_12345\" } } } } The session object can contain frontend-specific session data to be used in dialog or by services. For more details, see the session object . The event object contains the following members: name : A string corresponding to the name of the event, specified as an action in the service interface. status : Either started or ended . parameters : A map of key-value pairs pertaining to the event, corresponding to the parameters specified for the action in the service interface. The key is a string matching the parameter's predicate, and the value is a string containing the ID of the value (e.g. a number or a string depending on the sort). The event request may be combined with the start_session request when a session does not yet exist, but may not be combined with other requests. Example: { \"version\" : \"3.3\" , \"request\" : { \"start_session\" : {}, \"event\" : { ... } } } Response \u00b6 See response format . Response format \u00b6 The response format differs when the request was successful compared to when it encountered an error. Successful request \u00b6 The TDM response from a successful request typically contains an output utterance and other relevant information. Example: { \"version\" : \"3.3\" , \"session\" : { \"session_id\" : \"0000-abcd-1111-efgh\" }, \"output\" : { \"moves\" : [ \"ask(?X.selected_contact(X))\" ], \"utterance\" : \"Who do you want to call?\" , \"expected_passivity\" : 5.0 , \"actions\" : [] }, \"nlu_result\" : { \"selected_utterance\" : \"call John\" , \"confidence\" : 0.88 }, \"context\" : { \"active_ddd\" : \"my_ddd\" , \"facts\" : {}, \"language\" : \"eng\" , \"goal\" : \"perform(call)\" , \"plan\" : [ \"findout(?X.selected_contact(X))\" ], \"facts_being_grounded\" : {}, \"selected_hypothesis\" : { \"utterance\" : \"call John\" , \"confidence\" : 0.88 }, \"selected_interpretation\" : [{ \"ddd\" : \"send_to_frontend\" , \"understanding_confidence\" : \"0.749\" , \"perception_confidence\" : \"0.88\" , \"semantic_expression\" : \"request(call)\" }], \"expected_input\" : { \"alternatives\" : [ { \"semantic_expression\" : \"answer(contact_john)\" }, { \"semantic_expression\" : \"answer(contact_lisa)\" } ] } } } The session object is always provided and contains the same data that was provided in the request. Unlike requests however, it always contains: session_id : The ID of the current session. The output object is provided unless an error has occurred and has the following members: moves : The moves made by the system this turn. This is a list of move expressions in the dialog formalism , where the moves should be uttered in the listed order. Moves here are similar to the semantic_expression field of move objects . utterance : A string representing the output utterance from the system and should be realized by the client (e.g. by speaking it or displaying it as text). expected_passivity : If not null, the value is a number corresponding to the number of seconds of user passivity after which the client is expected to make a passivity request . If the value is 0.0, the passivity notification request should be issued immediately after having realized the system output. actions : A list of action invocation objects , which needs to be invoked by the client. TDM assumes that the actions will succeed and reports them accordingly. The nlu_result object is provided for natural language input requests , unless an error has occurred. It has the following members: selected_utterance : The utterance selected as the best candidate among the list of hypotheses. confidence : A number representing the joint confidence of the input and the NLU processing. The context object is provided unless an error has occurred and contains the following members: active_ddd : The name of the currently active DDD. facts : Information gathered during the conversation (see facts object ). language : ID of the current language. goal : Currently active goal, expressed as a goal in the dialog formalism . plan : Remaining items on the current plan, represented by a list of plan items in the dialog formalism . facts_being_grounded : Information that the system is currently grounding with the user, represented as a list of facts objects . selected_hypothesis : The natural language hypothesis that the system decided to act on. If the system turn was requested with a natural language input request , this corresponds to one of the hypothesis objects that were part of it. This field is null if a hypothesis could not be determined. selected_interpretation : The semantic interpretation that the system decided to act on. If the system turn was requested with a semantic input request , this corresponds to one of the interpretation objects that were part of it. This field is null if an interpretation could not be determined. expected_input : An expected input object , containing alternatives that TDM considers expected by the user the next turn. This field is null if TDM does not expect input, or if it doesn't know what input to expect. A warnings field is provided if warnings have been issued, as a list of strings, one string per warning. This can for instance happen when TDM is updated to a new version of this frontend API and the previous version is deprecated. In such cases, update your request formats to comply with the warning and avoid potential future errors: Request that encountered an error \u00b6 The TDM response when an error was encountered in the request contains an error description. { \"version\" : \"3.3\" , \"session\" : { \"session_id\" : \"0000-abcd-1111-efgh\" }, \"error\" : { \"description\" : \"An exception was encountered when processing the request\" } } An error object is provided if an error has occurred. In such cases, an error should be reported to the user by the client, and the session should not be resumed with further requests. The error field has the following members: description : A human readable technical description of the error. Session object \u00b6 A session object can contain frontend-specific session data. The data is forwarded as is to all service calls on the HTTP API for services . That way, the data can be used in service calls directly; or influence the dialog, for instance by being retrieved through service queries. Note that session data is not automatically stored or attached to the session within TDM. It is returned in the response and can be injected in future requests. If specific data should be available to all service calls on a session, the data needs to be injected in every request on that session, or the DDD needs to retrieve it into the dialog state, for instance by a service query. For all requests except start session , a session_id is required and used to identify to which session the request is being made. For start session requests however, the session_id is disallowed and instead generated by TDM. It should be retrieved from the response . Example for start session request: { \"session\" : { \"my_frontend\" : { \"user_id\" : \"123-abc-456-def\" , \"position\" : { \"latitude\" : \"57.699188\" , \"longitude\" : \"11.948313\" } } } } Example otherwise: { \"session\" : { \"session_id\" : \"0000-abcd-1111-efgh\" , \"my_frontend\" : { \"user_id\" : \"123-abc-456-def\" , \"position\" : { \"latitude\" : \"57.699188\" , \"longitude\" : \"11.948313\" } } } } Output object \u00b6 The output object contains the following members: moves : The moves made by the system this turn. This is a list of move expressions in the dialog formalism . Moves here are similar to the semantic_expression field of move objects . utterance : A string representing the output utterance from the system and should be realized by the client (e.g. by speaking it or displaying it as text). expected_passivity : If not null, the value is a number corresponding to the number of seconds of user passivity after which the client is expected to make a passivity request . If the value is 0.0, the passivity notification request should be issued immediately after having realized the system output. actions : A list of action invocation objects , which needs to be invoked by the client. TDM assumes that the actions will succeed and reports them accordingly. NLU results object \u00b6 The nlu_result object contains the following members: selected_utterance : The utterance selected as the best candidate amoung the list of natural language input hypotheses. confidence : A number representing the joint confidence of the input and the NLU processing. Context object \u00b6 The context object contains the following members: active_ddd : The name of the currently active DDD. facts : Information gathered during the conversation (see facts object ). language : ID of the current language. goal : Currently active goal, expressed as a goal proposition in the dialog formalism . plan : Remaining items on the current plan, represented by a list of plan items in the dialog formalism . facts_being_grounded : Information that the system is currently grounding with the user, represented as a list of facts objects . selected_hypothesis : The natural language hypothesis that the system decided to act on. If the system turn was requested with a natural language input request , this corresponds to one of the hypothesis objects that were part of it. This field is null if a hypothesis could not be determined. selected_interpretation : The semantic interpretation that the system decided to act on. If the system turn was requested with a semantic input request , this corresponds to one of the interpretation objects that were part of it. This field is null if an interpretation could not be determined. expected_input : An expected input object , containing alternatives that TDM considers expected by the user the next turn. This field is null if TDM does not expect input, or if it doesn't know what input to expect. Action invocation object \u00b6 An action invocation object contains information about an action to be invoked by the client. The object has the following members: name is a string corresponding to the action's name in service_interface.xml . parameters contains values for all parameters that are specified for the method in service_interface.xml . If a parameter is unknown, its value is null . Otherwise it's an object containing: sort : ID of the predicate's sort as defined in the ontology. value : ID of the value. For the sorts integer and real , the ID is a number. For other sorts, e.g. string , datetime and custom sorts, the ID is a string. grammar_entry : Natural-language representation of the value. Example: { \"name\" : \"call\" , \"parameters\" : { \"selected_contact\" : { \"sort\" : \"contact\" , \"value\" : \"contact_john\" , \"grammar_entry\" : \"John\" } } } Facts object \u00b6 The facts field contains a map of key-value pairs for information gathered during the conversation, e.g. from the user. The map may be empty. The key is a string matching a predicate as defined in the ontology. The value is an object with the following members: sort : ID of the predicate's sort as defined in the ontology. value : ID of the value (e.g. a number or a string depending on the sort). For predicates of sort datetime , the ID is an ISO 8601 string. grammar_entry : Natural-language representation of the value. Example: { \"facts\" : { \"departure\" : { \"sort\" : \"city\" , \"value\" : \"city_012345\" , \"grammar_entry\" : \"London\" }, \"destination\" : { \"sort\" : \"city\" , \"value\" : \"city_012346\" , \"grammar_entry\" : \"Newcastle\" } } } Expected input object \u00b6 The expected input object contains alternatives that TDM considers expected by the user the next turn. They can for instance be used to add quick-answer buttons to a GUI or chat client. The object has the following members: alternatives : A list of alternative objects . If TDM asks a yes-no question , it expects the yes or no answer : { \"alternatives\" : [ { \"semantic_expression\" : \"answer(yes)\" }, { \"semantic_expression\" : \"answer(no)\" } ] } If TDM asks an alternative question or a wh-question where the alternatives are known, the expected input object either contains answer moves with unary propositions : { \"alternatives\" : [ { \"semantic_expression\" : \"answer(selected_contact(contact_john))\" }, { \"semantic_expression\" : \"answer(selected_contact(contact_lisa))\" } ] } ... or request and ask moves : { \"alternatives\" : [ { \"semantic_expression\" : \"request(call)\" }, { \"semantic_expression\" : \"ask(?X.phone_number(X))\" } ] } Alternative object \u00b6 An alternative object contains information about the moves that the user is expected to take the next turn. It contains the following members: semantic_expression : A semantic expression of the expected move, expressed in the dialog formalism .","title":"Pipeline API"},{"location":"api-definitions/pipeline_api/#pipeline-api","text":"This document describes API version 3.3 for HTTP frontends, enabling frontends to integrate with TDM over HTTP. It covers e.g. how input from the user and output from TDM are communicated between TDM and the client.","title":"Pipeline API"},{"location":"api-definitions/pipeline_api/#important-concepts","text":"This section describes some concepts that are important to understand and comply with when integrating TDM in a dialog system.","title":"Important concepts"},{"location":"api-definitions/pipeline_api/#requests-and-responses","text":"TDM serves an HTTP server and responds to requests done by the client. The client is the consumer of the API outlined in this document. The client invokes TDM with an HTTP request to the interaction endpoint, e.g. http://localhost:9090/interact , using the POST method and a JSON body. The client should expect the status code to be 200 OK. For other status codes, the client should report an error to the user. The request body always contains a version number, specifying the version of the HTTP API format. The exact format of the request and the response depends on the type of request as described in the separate sections below.","title":"Requests and responses"},{"location":"api-definitions/pipeline_api/#turn-taking","text":"Turn taking is a vital part of dialog between humans, read for instance the Wikipedia article . Since TDM is based on research on human-human dialog, turn taking is a central concept here too. The TDM client is responsible for managing turn-taking on behalf of the machine, because it's the component that is closest to the human, in the human-machine dialog that TDM enables. Since the machine is intended to assist the human, the human decides the pace, the turn taking, of the conversation. In spoken dialog, turn taking happens in close collaboration with the spoken output of the system, which means that the system's turn management needs to happen as close to this component, the text-to-speech component (TTS), as possible. TDM enables intuitive turn taking by instructing its client how to deal with the user input that it's range of sensors can pick up. The instructions are straightforward and revolve around passivity. If the user is passive, for instance doesn't know what to say, for a given amount of time, the client sends TDM a passivity request , which lets the system take the next turn instead of the user. The user should be considered passive when not doing anything related to the dialog. If the user however takes some action (although not completing its turn just yet), for instance by typing (if it's a text interface) or talking (if it's a spoken interface), the user should be considered active and the passivity request should not be sent to TDM. Instead the user should be allowed to complete its turn, resulting in an input request. TDM instructs its client about how much time of passivity that should pass before sending the passivity request in the output.expected_passivity field of the response . For instance, if TDM responds with: { \"output\" : { ... \"expected_passivity\" : 1.0 }, ... } then the client should send a passivity request when the user has been passive for 1 second. The 1 second should start counting when the system utterance has reached the user, which in a spoken interface means when the TTS finished speaking TDM's utterance. Note that sometimes TDM does not have anything to say when the user becomes passive ( \"expected_passivity\": null ), and sometimes it just needs to progress the conversation immediately after saying something ( \"expected_passivity\": 0.0 ). Read the details about how to interpret the expected_passivity value in the response format section .","title":"Turn taking"},{"location":"api-definitions/pipeline_api/#errors","text":"When an error occurs in TDM during a request, for instance due to incomplete turn management, the response contains the \"error\" field. It's important to note that this could mean that the session stops. If it has stopped, further requests on the same session will report errors that the provided session ID is unknown.","title":"Errors"},{"location":"api-definitions/pipeline_api/#start-session-requests","text":"When a new session should be started, the client issues a start_session request. The response contains initial output from TDM and a session ID that can be used in subsequent requests. For more details, see the response format . If a session ID is provided together with the start_session request, an error is given. The integrity of the session is however maintained.","title":"Start session requests"},{"location":"api-definitions/pipeline_api/#request","text":"Example: { \"version\" : \"3.3\" , \"session\" : {}, \"request\" : { \"start_session\" : {} } } The session object can contain frontend-specific session data to be used in dialog or by services. For more details, see the session object . The start_session object may contain the following optional members: ddd_set : A string specifying a DDD set for the session. If omitted, a default DDD set configured by the backend is used. The start_session request may be issued on its own, so that the system will start the conversation; or combined with natural_language_input , semantic_input and event requests to start the conversation from there. Example when combined with natural_language_input : { \"version\" : \"3.3\" , \"request\" : { \"start_session\" : {}, \"natural_language_input\" : { ... } } }","title":"Request"},{"location":"api-definitions/pipeline_api/#response","text":"See response format .","title":"Response"},{"location":"api-definitions/pipeline_api/#natural-language-input-requests","text":"When the client detects natural language input from the user, it issues a request and receives output from TDM. The request can contain either hypotheses with the speech modality, or a single utterance with the text modality.","title":"Natural language input requests"},{"location":"api-definitions/pipeline_api/#request_1","text":"Speech input example: { \"version\" : \"3.3\" , \"session\" : { \"session_id\" : \"0000-abcd-1111-efgh\" }, \"request\" : { \"natural_language_input\" : { \"modality\" : \"speech\" , \"hypotheses\" : [ { \"utterance\" : \"call John\" , \"confidence\" : 0.81 }, { \"utterance\" : \"calling John\" , \"confidence\" : 0.65 }, { \"utterance\" : \"call him John\" , \"confidence\" : 0.31 } ] } } } Text input example: { \"version\" : \"3.3\" , \"session\" : { \"session_id\" : \"0000-abcd-1111-efgh\" }, \"request\" : { \"natural_language_input\" : { \"modality\" : \"text\" , \"utterance\" : \"I'm searching for flights from London to Paris tomorrow\" } } } The session object can contain frontend-specific session data to be used in dialog or by services. For more details, see the session object See the natural language input object for more details. The natural_language_input request may be combined with the start_session request when a session does not yet exist, but may not be combined with other requests. Example: { \"version\" : \"3.3\" , \"request\" : { \"start_session\" : {}, \"natural_language_input\" : { ... } } }","title":"Request"},{"location":"api-definitions/pipeline_api/#response_1","text":"See response format .","title":"Response"},{"location":"api-definitions/pipeline_api/#semantic-input-requests","text":"When the client has user input on a semantic format, as a user move, it should issue the semantic_input request. Semantic in this case means that the user input does not need to be interpreted; the user move is already known. This is useful when an external natural language understanding (NLU) component has already interpreted the input; when the user presses a button in a GUI; or for instance when the user makes a gesture which is interpreted as a user move.","title":"Semantic input requests"},{"location":"api-definitions/pipeline_api/#request_2","text":"{ \"version\" : \"3.3\" , \"session\" : { \"session_id\" : \"0000-abcd-1111-efgh\" }, \"request\" : { \"semantic_input\" : { \"interpretations\" : [ { \"utterance\" : \"call John\" , \"modality\" : \"speech\" , \"moves\" : [ { \"perception_confidence\" : 0.81 , \"understanding_confidence\" : 0.92215 , \"ddd\" : \"phone\" , \"semantic_expression\" : \"request(call)\" }, { \"perception_confidence\" : 0.81 , \"understanding_confidence\" : 0.98532 , \"ddd\" : \"phone\" , \"semantic_expression\" : \"answer(contact_john)\" } ] }, { \"utterance\" : \"calling John\" , \"modality\" : \"speech\" , \"moves\" : [ { \"perception_confidence\" : 0.65 , \"understanding_confidence\" : 0.5234 , \"ddd\" : \"phone\" , \"semantic_expression\" : \"request(call)\" }, { \"perception_confidence\" : 0.65 , \"understanding_confidence\" : 0.98532 , \"ddd\" : \"phone\" , \"semantic_expression\" : \"answer(contact_john)\" } ] }, { \"utterance\" : \"call him John\" , \"modality\" : \"speech\" , \"moves\" : [ { \"perception_confidence\" : 0.31 , \"understanding_confidence\" : 0.2216 , \"ddd\" : \"phone\" , \"semantic_expression\" : \"request(call)\" }, { \"perception_confidence\" : 0.31 , \"understanding_confidence\" : 0.98532 , \"ddd\" : \"phone\" , \"semantic_expression\" : \"answer(contact_john)\" } ] }, { \"utterance\" : \"call him John\" , \"modality\" : \"speech\" , \"moves\" : [ { \"perception_confidence\" : 0.31 , \"understanding_confidence\" : 0.10126 , \"ddd\" : \"phone\" , \"semantic_expression\" : \"ask(?X.phone_number(X))\" }, { \"perception_confidence\" : 0.31 , \"understanding_confidence\" : 0.98532 , \"ddd\" : \"phone\" , \"semantic_expression\" : \"answer(contact_john)\" } ] } ], \"entities\" : [ { \"name\" : \"contact_john\" , \"sort\" : \"contact\" , \"natural_language_form\" : \"John\" , \"ddd\" : \"phone\" } ] } } } The session object can contain frontend-specific session data to be used in dialog or by services. For more details, see the session object . interpretations : A list of interpretation objects . TDM will use confidence scores and the context of the current state of the session to decide which interpretation to act upon. entities : (optional) A list of entity objects . TDM can use these entities in interpretations and for natural language generation. See the semantic input object for more details. The semantic_input request may be combined with the start_session request when a session does not yet exist, but may not be combined with other requests. Example: { \"version\" : \"3.3\" , \"request\" : { \"start_session\" : {}, \"semantic_input\" : { ... } } }","title":"Request"},{"location":"api-definitions/pipeline_api/#response_2","text":"See response format .","title":"Response"},{"location":"api-definitions/pipeline_api/#passivity-requests","text":"When the client detects user passivity, it issues a request and receives output from TDM.","title":"Passivity requests"},{"location":"api-definitions/pipeline_api/#request_3","text":"Example: { \"version\" : \"3.3\" , \"session\" : { \"session_id\" : \"0000-abcd-1111-efgh\" }, \"request\" : { \"passivity\" : {} } } The session object can contain frontend-specific session data to be used in dialog or by services. For more details, see the session object . The passivity request may not be combined with other requests in the same call.","title":"Request"},{"location":"api-definitions/pipeline_api/#response_3","text":"See response format .","title":"Response"},{"location":"api-definitions/pipeline_api/#event-requests","text":"When the client detects that an event pertaining to a relevant DDD has occurred, it should issue an event notification request, and receives output from TDM.","title":"Event requests"},{"location":"api-definitions/pipeline_api/#request_4","text":"Example: { \"version\" : \"3.3\" , \"session\" : { \"session_id\" : \"0000-abcd-1111-efgh\" }, \"request\" : { \"event\" : { \"name\" : \"IncomingCall\" , \"status\" : \"started\" , \"parameters\" : { \"caller\" : \"contact_12345\" } } } } The session object can contain frontend-specific session data to be used in dialog or by services. For more details, see the session object . The event object contains the following members: name : A string corresponding to the name of the event, specified as an action in the service interface. status : Either started or ended . parameters : A map of key-value pairs pertaining to the event, corresponding to the parameters specified for the action in the service interface. The key is a string matching the parameter's predicate, and the value is a string containing the ID of the value (e.g. a number or a string depending on the sort). The event request may be combined with the start_session request when a session does not yet exist, but may not be combined with other requests. Example: { \"version\" : \"3.3\" , \"request\" : { \"start_session\" : {}, \"event\" : { ... } } }","title":"Request"},{"location":"api-definitions/pipeline_api/#response_4","text":"See response format .","title":"Response"},{"location":"api-definitions/pipeline_api/#response-format","text":"The response format differs when the request was successful compared to when it encountered an error.","title":"Response format"},{"location":"api-definitions/pipeline_api/#successful-request","text":"The TDM response from a successful request typically contains an output utterance and other relevant information. Example: { \"version\" : \"3.3\" , \"session\" : { \"session_id\" : \"0000-abcd-1111-efgh\" }, \"output\" : { \"moves\" : [ \"ask(?X.selected_contact(X))\" ], \"utterance\" : \"Who do you want to call?\" , \"expected_passivity\" : 5.0 , \"actions\" : [] }, \"nlu_result\" : { \"selected_utterance\" : \"call John\" , \"confidence\" : 0.88 }, \"context\" : { \"active_ddd\" : \"my_ddd\" , \"facts\" : {}, \"language\" : \"eng\" , \"goal\" : \"perform(call)\" , \"plan\" : [ \"findout(?X.selected_contact(X))\" ], \"facts_being_grounded\" : {}, \"selected_hypothesis\" : { \"utterance\" : \"call John\" , \"confidence\" : 0.88 }, \"selected_interpretation\" : [{ \"ddd\" : \"send_to_frontend\" , \"understanding_confidence\" : \"0.749\" , \"perception_confidence\" : \"0.88\" , \"semantic_expression\" : \"request(call)\" }], \"expected_input\" : { \"alternatives\" : [ { \"semantic_expression\" : \"answer(contact_john)\" }, { \"semantic_expression\" : \"answer(contact_lisa)\" } ] } } } The session object is always provided and contains the same data that was provided in the request. Unlike requests however, it always contains: session_id : The ID of the current session. The output object is provided unless an error has occurred and has the following members: moves : The moves made by the system this turn. This is a list of move expressions in the dialog formalism , where the moves should be uttered in the listed order. Moves here are similar to the semantic_expression field of move objects . utterance : A string representing the output utterance from the system and should be realized by the client (e.g. by speaking it or displaying it as text). expected_passivity : If not null, the value is a number corresponding to the number of seconds of user passivity after which the client is expected to make a passivity request . If the value is 0.0, the passivity notification request should be issued immediately after having realized the system output. actions : A list of action invocation objects , which needs to be invoked by the client. TDM assumes that the actions will succeed and reports them accordingly. The nlu_result object is provided for natural language input requests , unless an error has occurred. It has the following members: selected_utterance : The utterance selected as the best candidate among the list of hypotheses. confidence : A number representing the joint confidence of the input and the NLU processing. The context object is provided unless an error has occurred and contains the following members: active_ddd : The name of the currently active DDD. facts : Information gathered during the conversation (see facts object ). language : ID of the current language. goal : Currently active goal, expressed as a goal in the dialog formalism . plan : Remaining items on the current plan, represented by a list of plan items in the dialog formalism . facts_being_grounded : Information that the system is currently grounding with the user, represented as a list of facts objects . selected_hypothesis : The natural language hypothesis that the system decided to act on. If the system turn was requested with a natural language input request , this corresponds to one of the hypothesis objects that were part of it. This field is null if a hypothesis could not be determined. selected_interpretation : The semantic interpretation that the system decided to act on. If the system turn was requested with a semantic input request , this corresponds to one of the interpretation objects that were part of it. This field is null if an interpretation could not be determined. expected_input : An expected input object , containing alternatives that TDM considers expected by the user the next turn. This field is null if TDM does not expect input, or if it doesn't know what input to expect. A warnings field is provided if warnings have been issued, as a list of strings, one string per warning. This can for instance happen when TDM is updated to a new version of this frontend API and the previous version is deprecated. In such cases, update your request formats to comply with the warning and avoid potential future errors:","title":"Successful request"},{"location":"api-definitions/pipeline_api/#request-that-encountered-an-error","text":"The TDM response when an error was encountered in the request contains an error description. { \"version\" : \"3.3\" , \"session\" : { \"session_id\" : \"0000-abcd-1111-efgh\" }, \"error\" : { \"description\" : \"An exception was encountered when processing the request\" } } An error object is provided if an error has occurred. In such cases, an error should be reported to the user by the client, and the session should not be resumed with further requests. The error field has the following members: description : A human readable technical description of the error.","title":"Request that encountered an error"},{"location":"api-definitions/pipeline_api/#session-object","text":"A session object can contain frontend-specific session data. The data is forwarded as is to all service calls on the HTTP API for services . That way, the data can be used in service calls directly; or influence the dialog, for instance by being retrieved through service queries. Note that session data is not automatically stored or attached to the session within TDM. It is returned in the response and can be injected in future requests. If specific data should be available to all service calls on a session, the data needs to be injected in every request on that session, or the DDD needs to retrieve it into the dialog state, for instance by a service query. For all requests except start session , a session_id is required and used to identify to which session the request is being made. For start session requests however, the session_id is disallowed and instead generated by TDM. It should be retrieved from the response . Example for start session request: { \"session\" : { \"my_frontend\" : { \"user_id\" : \"123-abc-456-def\" , \"position\" : { \"latitude\" : \"57.699188\" , \"longitude\" : \"11.948313\" } } } } Example otherwise: { \"session\" : { \"session_id\" : \"0000-abcd-1111-efgh\" , \"my_frontend\" : { \"user_id\" : \"123-abc-456-def\" , \"position\" : { \"latitude\" : \"57.699188\" , \"longitude\" : \"11.948313\" } } } }","title":"Session object"},{"location":"api-definitions/pipeline_api/#output-object","text":"The output object contains the following members: moves : The moves made by the system this turn. This is a list of move expressions in the dialog formalism . Moves here are similar to the semantic_expression field of move objects . utterance : A string representing the output utterance from the system and should be realized by the client (e.g. by speaking it or displaying it as text). expected_passivity : If not null, the value is a number corresponding to the number of seconds of user passivity after which the client is expected to make a passivity request . If the value is 0.0, the passivity notification request should be issued immediately after having realized the system output. actions : A list of action invocation objects , which needs to be invoked by the client. TDM assumes that the actions will succeed and reports them accordingly.","title":"Output object"},{"location":"api-definitions/pipeline_api/#nlu-results-object","text":"The nlu_result object contains the following members: selected_utterance : The utterance selected as the best candidate amoung the list of natural language input hypotheses. confidence : A number representing the joint confidence of the input and the NLU processing.","title":"NLU results object"},{"location":"api-definitions/pipeline_api/#context-object","text":"The context object contains the following members: active_ddd : The name of the currently active DDD. facts : Information gathered during the conversation (see facts object ). language : ID of the current language. goal : Currently active goal, expressed as a goal proposition in the dialog formalism . plan : Remaining items on the current plan, represented by a list of plan items in the dialog formalism . facts_being_grounded : Information that the system is currently grounding with the user, represented as a list of facts objects . selected_hypothesis : The natural language hypothesis that the system decided to act on. If the system turn was requested with a natural language input request , this corresponds to one of the hypothesis objects that were part of it. This field is null if a hypothesis could not be determined. selected_interpretation : The semantic interpretation that the system decided to act on. If the system turn was requested with a semantic input request , this corresponds to one of the interpretation objects that were part of it. This field is null if an interpretation could not be determined. expected_input : An expected input object , containing alternatives that TDM considers expected by the user the next turn. This field is null if TDM does not expect input, or if it doesn't know what input to expect.","title":"Context object"},{"location":"api-definitions/pipeline_api/#action-invocation-object","text":"An action invocation object contains information about an action to be invoked by the client. The object has the following members: name is a string corresponding to the action's name in service_interface.xml . parameters contains values for all parameters that are specified for the method in service_interface.xml . If a parameter is unknown, its value is null . Otherwise it's an object containing: sort : ID of the predicate's sort as defined in the ontology. value : ID of the value. For the sorts integer and real , the ID is a number. For other sorts, e.g. string , datetime and custom sorts, the ID is a string. grammar_entry : Natural-language representation of the value. Example: { \"name\" : \"call\" , \"parameters\" : { \"selected_contact\" : { \"sort\" : \"contact\" , \"value\" : \"contact_john\" , \"grammar_entry\" : \"John\" } } }","title":"Action invocation object"},{"location":"api-definitions/pipeline_api/#facts-object","text":"The facts field contains a map of key-value pairs for information gathered during the conversation, e.g. from the user. The map may be empty. The key is a string matching a predicate as defined in the ontology. The value is an object with the following members: sort : ID of the predicate's sort as defined in the ontology. value : ID of the value (e.g. a number or a string depending on the sort). For predicates of sort datetime , the ID is an ISO 8601 string. grammar_entry : Natural-language representation of the value. Example: { \"facts\" : { \"departure\" : { \"sort\" : \"city\" , \"value\" : \"city_012345\" , \"grammar_entry\" : \"London\" }, \"destination\" : { \"sort\" : \"city\" , \"value\" : \"city_012346\" , \"grammar_entry\" : \"Newcastle\" } } }","title":"Facts object"},{"location":"api-definitions/pipeline_api/#expected-input-object","text":"The expected input object contains alternatives that TDM considers expected by the user the next turn. They can for instance be used to add quick-answer buttons to a GUI or chat client. The object has the following members: alternatives : A list of alternative objects . If TDM asks a yes-no question , it expects the yes or no answer : { \"alternatives\" : [ { \"semantic_expression\" : \"answer(yes)\" }, { \"semantic_expression\" : \"answer(no)\" } ] } If TDM asks an alternative question or a wh-question where the alternatives are known, the expected input object either contains answer moves with unary propositions : { \"alternatives\" : [ { \"semantic_expression\" : \"answer(selected_contact(contact_john))\" }, { \"semantic_expression\" : \"answer(selected_contact(contact_lisa))\" } ] } ... or request and ask moves : { \"alternatives\" : [ { \"semantic_expression\" : \"request(call)\" }, { \"semantic_expression\" : \"ask(?X.phone_number(X))\" } ] }","title":"Expected input object"},{"location":"api-definitions/pipeline_api/#alternative-object","text":"An alternative object contains information about the moves that the user is expected to take the next turn. It contains the following members: semantic_expression : A semantic expression of the expected move, expressed in the dialog formalism .","title":"Alternative object"},{"location":"api-definitions/service_api/","text":"Service API \u00b6 This document describes API version 1.1 for HTTP services. It needs to be implemented by services invoked by TDM over HTTP. Services are used by DDDs to invoke actions, invoke queries, recognize entities, and to validate parameters. TDM invokes service methods with an HTTP request to the endpoint specified in service_interface.xml , using the POST method and a JSON body. It expects the status code to be 200 OK. (For other status codes, TDM reports an error to the user.) The request body always contains a version number, specifying the version of the service integration format. The service can use the version in the request to validate that the service implementation is compatible with the request. The service also returns a version number in the response body, corresponding to the version of this API used when implementing the service. If the service returns a version number that is not compatible with the request, TDM reports an error to the user. Responses from services adhere to the JSend specification . See response format for a general description. The exact format of the request and the response depends on the service method and is described below. Action requests \u00b6 Request \u00b6 Below is an example of a request body for an action called SetTemperature , invoked when the user has requested to set the temperature to 23 degrees: { \"version\" : \"1.1\" , \"session\" : { \"session_id\" : \"0000-abcd-1111-efgh\" }, \"request\" : { \"type\" : \"action\" , \"name\" : \"SetTemperature\" , \"parameters\" : { \"degrees\" : { \"sort\" : \"integer\" , \"value\" : 23 , \"grammar_entry\" : \"23\" } } }, \"context\" : { \"active_ddd\" : \"MyDDD\" , \"facts\" : { \"degrees\" : { \"sort\" : \"integer\" , \"value\" : 23 , \"grammar_entry\" : \"23\" } }, \"language\" : \"eng\" , \"invocation_id\" : \"2222-ijkl-3333-mnop\" } } Format for request : see Request object . Format for session : see Session object . Format for context : see Context object . Response \u00b6 Actions invoked over HTTP can either succeed or fail with an expected reason. Below is the expected response body for the request above, when successful: { \"status\" : \"success\" , \"data\" : { \"version\" : \"1.1\" } } Format for status and data : see Response format . But say that someone tries to set the temperature of a refrigerator to 23 degrees, which is more than it can handle. If there's a failure reason temperature_too_high declared in service_interface.xml , the service can fail expectedly with: { \"status\" : \"fail\" , \"data\" : { \"version\" : \"1.1\" , \"reason\" : \"temperature_too_high\" } } Format for status and data : see Response format . The data object additionally contains these action specific members: reason matching the failure that occurred. It needs to match one of the failure reasons declared for this action in service_interface.xml . Query requests \u00b6 Queries are invoked by TDM to retrieve information from a service, e.g. in order to be able to respond to a question from a user, or to fetch alternatives for alternative questions. Request \u00b6 Below is an example of a request body for a query called current_temperature with the parameter location , invoked when the user has asked for the temperature in London: { \"version\" : \"1.1\" , \"session\" : { \"session_id\" : \"0000-abcd-1111-efgh\" }, \"request\" : { \"type\" : \"query\" , \"name\" : \"current_temperature\" , \"parameters\" : { \"location\" : { \"sort\" : \"city\" , \"value\" : \"city_012345\" , \"grammar_entry\" : \"London\" } }, \"min_results\" : 1 , \"max_results\" : 1 }, \"context\" : { \"active_ddd\" : \"MyDDD\" , \"facts\" : { \"location\" : { \"sort\" : \"city\" , \"value\" : \"city_012345\" , \"grammar_entry\" : \"London\" } }, \"language\" : \"eng\" , \"invocation_id\" : \"2222-ijkl-3333-mnop\" } } Format for request : see Request object . The request object additionally contains these query specific members: min_results specifies the minimum number of results that the service should return as a non-negative integer. If the service returns fewer results than specified by min_results , TDM reports an error to the user. max_results specifies the maximum number of results that the service should return. max_results is either a positive integer, or null meaning that there is no upper bound. If the service returns more results than specified by max_results , TDM reports an error to the user. Format for session : see Session object . Format for context : see Context object . Response \u00b6 Below is an example of a response body for the request above, when the current temperature in London is 17 degrees: { \"status\" : \"success\" , \"data\" : { \"version\" : \"1.1\" , \"result\" : [ { \"value\" : 17 , \"confidence\" : 1.0 , \"grammar_entry\" : null } ] } } General format for responses: see Response format . data additionally contains these members specific to queries: result : contains a list result items. Each result item is an object with the following members: value can be either a number, string or null , depending on the query's predicate. For predicates of sort integer or real , a number is expected. For predicates of sort datetime , an ISO 8601 string is expected. For predicates of a custom sort, a string is expected, corresponding to the name of the individual. For dynamic sorts, the value null is supported, in which case a grammar entry is required. confidence should normally be set to 1.0. However, when the information is uncertain - e.g. when making a prediction from a user model - confidence can be set to a value from 0.0 to 1.0. grammar_entry can be set to specify a natural-language represention of the result. This is required for dynamic sorts, when value is null . Additional query example: Multiple results \u00b6 Below is an example of a request and response for a query called selected_contact which is used to determine whether a single contact can be identified based on a first and last name. In the example, only the first name is known, and the service returns two matching contacts. Request: { \"version\" : \"1.1\" , \"session\" : { \"session_id\" : \"0000-abcd-1111-efgh\" }, \"request\" : { \"type\" : \"query\" , \"name\" : \"selected_contact\" , \"parameters\" : { \"selected_first_name\" : { \"sort\" : \"first_name\" , \"value\" : \"fist_name_john\" , \"grammar_entry\" : \"John\" }, \"selected_last_name\" : null }, \"min_results\" : 0 , \"max_results\" : null }, \"context\" : { \"active_ddd\" : \"MyDDD\" , \"facts\" : { \"selected_first_name\" : { \"sort\" : \"first_name\" , \"value\" : \"fist_name_john\" , \"grammar_entry\" : \"John\" } }, \"language\" : \"eng\" , \"invocation_id\" : \"2222-ijkl-3333-mnop\" } } Response: { \"status\" : \"success\" , \"data\" : { \"version\" : \"1.1\" , \"result\" : [ { \"value\" : \"contact_john_johnson\" , \"confidence\" : 1.0 , \"grammar_entry\" : \"John Johnson\" }, { \"value\" : \"contact_john_thompson\" , \"confidence\" : 1.0 , \"grammar_entry\" : \"John Thompson\" } ] } } Also note that for this request example, the service may return an empty list of results if no matching contacts were found for the given parameters. Entity recognizer requests \u00b6 Entity recognizers are invoked by TDM to identify entities in user utterances. Request \u00b6 Below is an example of a request body for an entity recognition invocation when the user has said \"what is the temperature in London\": { \"version\" : \"1.1\" , \"session\" : { \"session_id\" : \"0000-abcd-1111-efgh\" }, \"request\" : { \"type\" : \"entity_recognizer\" , \"name\" : \"LocationRecognizer\" , \"utterance\" : \"what is the temperature in London\" }, \"context\" : { \"active_ddd\" : \"MyDDD\" , \"facts\" : {}, \"language\" : \"eng\" , \"invocation_id\" : \"2222-ijkl-3333-mnop\" } } Format for request : see Request object . The request object additionally contains these members specific to entity recognizers: utterance is the user utterance that should be searched for entities. It's a string. Format for session : see Session object . Format for context : see Context object . Response \u00b6 Below is an example of a response body for the request above: { \"status\" : \"success\" , \"data\" : { \"version\" : \"1.1\" , \"result\" : [ { \"grammar_entry\" : \"London\" , \"sort\" : \"city\" , \"value\" : \"city_012345\" } ] } } General format for responses: see Response format . data additionally contains these members specific to entity recognizers: result : contains a list of zero or more result items. Each result item is an object with the following members: grammar_entry : Natural-language representation of the recognized entity. sort : The entity's sort, corresponding to the sort's name in ontology.xml . value : ID or semantic representation of the entity if known, otherwise null . For static (non-dynamic) sorts, the value is mandatory and should correspond to the semantic name of an individual. Validator requests \u00b6 Validators are invoked by TDM to determine if information provided by the user is valid. If not, relevant feedback is given to the user. Request \u00b6 Below is an example of a request body for a validator called RouteValidator with the parameters departure and destination : { \"version\" : \"1.1\" , \"session\" : { \"session_id\" : \"0000-abcd-1111-efgh\" }, \"request\" : { \"type\" : \"validator\" , \"name\" : \"RouteValidator\" , \"parameters\" : { \"departure\" : { \"sort\" : \"city\" , \"value\" : \"city_012345\" , \"grammar_entry\" : \"London\" }, \"destination\" : { \"sort\" : \"city\" , \"value\" : \"city_099998\" , \"grammar_entry\" : \"Chippinghirst\" } } }, \"context\" : { \"active_ddd\" : \"MyDDD\" , \"facts\" : { \"departure\" : { \"sort\" : \"city\" , \"value\" : \"city_012345\" , \"grammar_entry\" : \"London\" }, \"destination\" : { \"sort\" : \"city\" , \"value\" : \"city_099998\" , \"grammar_entry\" : \"Chippinghirst\" } }, \"language\" : \"eng\" , \"invocation_id\" : \"2222-ijkl-3333-mnop\" } } Format for request : see Request object . Format for session : see Session object . Format for context : see Context object . Response \u00b6 Below is an example of a response body for the request above: { \"status\" : \"success\" , \"data\" : { \"version\" : \"1.1\" , \"is_valid\" : false } } General format for responses: see Response format . data additionally contains these validator specific members: is_valid : can be either true or false , specifying whether the combination of parameters is valid or not. Request object \u00b6 In general, the request object contains the following members. It may also contain additional method specific members. type is the method type, e.g. action or query . All methods that can be declared in service_interface.xml are supported. See examples for each of them above. name is the method name, as specified in service_interface.xml . parameters contains values for all parameters that are specified for the method in service_interface.xml . If a parameter is unknown, its value is null . Otherwise it's an object containing: sort : ID of the predicate's sort as defined in the ontology. value : ID of the value. For the sorts integer and real , the ID is a number. For other sorts, e.g. string , datetime and custom sorts, the ID is a string. grammar_entry : Natural-language representation of the value. Example: { \"request\" : { \"type\" : \"validator\" , \"name\" : \"contact_validator\" , \"parameters\" : { \"selected_first_name\" : { \"sort\" : \"first_name\" , \"value\" : \"fist_name_john\" , \"grammar_entry\" : \"John\" }, \"selected_last_name\" : null } } } Session object \u00b6 The session object contains the following members: session_id : String representing the current TDM session. Additionally, it contains the same data that was injected in the frontend request to TDM. This way, service calls can utilize frontend-specific session data. For more details, read about the session object in the frontend API docs Example: { \"session\" : { \"session_id\" : \"0000-abcd-1111-efgh\" , \"my_frontend\" : { \"user_id\" : \"123-abc-456-def\" , \"position\" : { \"latitude\" : \"57.699188\" , \"longitude\" : \"11.948313\" } } } } Context object \u00b6 The context object contains the following members: active_ddd : The name of the currently active DDD. facts : Information gathered during the conversation (see Facts object ). language : ID of the current language. invocation_id : A unique identifer for the invocation from TDM. This ID can be logged for analytics and issue reporting. Facts object \u00b6 The facts object contains a map of key-value pairs for information gathered during the conversation, e.g. from the user. The map may be empty. The key is a string matching a predicate as defined in the ontology. The value is an object with the following members: sort : ID of the predicate's sort as defined in the ontology. value : ID of the value. For the sorts integer and real , the ID is a number. For other sorts, e.g. string , datetime and custom sorts, the ID is a string. grammar_entry : Natural-language representation of the value. Example: { \"facts\" : { \"departure\" : { \"sort\" : \"city\" , \"value\" : \"city_012345\" , \"grammar_entry\" : \"London\" }, \"destination\" : { \"sort\" : \"city\" , \"value\" : \"city_012346\" , \"grammar_entry\" : \"Newcastle\" } } } Response format \u00b6 All service responses adhere to the JSend specification . In general, responses can have one of three appearances, corresponding to the status of the invocation: success , fail and error . See the examples below. Success: { \"status\" : \"success\" , \"data\" : { \"version\" : \"1.1\" } } Successful method invocations need to set their status to success . The data object contains mostly method specific members. All methods need however include: version : the version of the API used to process the request and format the response. If the version is not compatible with the request, TDM reports an error to the user. Fail: { \"status\" : \"fail\" , \"data\" : { \"version\" : \"1.1\" } } Failures cannot be used with queries, entity recognizers or validators, but is supported by actions . If a fail status is not supported or is reported unexpectedly, it is treated as an error . error is however preferred over fail since a helpful message can be provided. TDM will report the error to the user, but will not mention any details. To report a failure, the status need to be set to fail . The data object contains mostly method specific members. All methods need however include: version : the version of the API used to process the request and format the response. Error: { \"status\" : \"error\" , \"message\" : \"Could not communicate with the database.\" , \"code\" : 135 , \"data\" : { \"version\" : \"1.1\" } } When a service encounters an error, i.e. an exception, the status need to be set to error . TDM will report the error to the user, but will not mention any details. message should be a human-readable message, explaining what went wrong. It will be logged but is not exposed to end-users. code (optional) is a numeric code identifying the error, if applicable. The data needs to contain: version : the version of the API used to process the request and format the response.","title":"Service API"},{"location":"api-definitions/service_api/#service-api","text":"This document describes API version 1.1 for HTTP services. It needs to be implemented by services invoked by TDM over HTTP. Services are used by DDDs to invoke actions, invoke queries, recognize entities, and to validate parameters. TDM invokes service methods with an HTTP request to the endpoint specified in service_interface.xml , using the POST method and a JSON body. It expects the status code to be 200 OK. (For other status codes, TDM reports an error to the user.) The request body always contains a version number, specifying the version of the service integration format. The service can use the version in the request to validate that the service implementation is compatible with the request. The service also returns a version number in the response body, corresponding to the version of this API used when implementing the service. If the service returns a version number that is not compatible with the request, TDM reports an error to the user. Responses from services adhere to the JSend specification . See response format for a general description. The exact format of the request and the response depends on the service method and is described below.","title":"Service API"},{"location":"api-definitions/service_api/#action-requests","text":"","title":"Action requests"},{"location":"api-definitions/service_api/#request","text":"Below is an example of a request body for an action called SetTemperature , invoked when the user has requested to set the temperature to 23 degrees: { \"version\" : \"1.1\" , \"session\" : { \"session_id\" : \"0000-abcd-1111-efgh\" }, \"request\" : { \"type\" : \"action\" , \"name\" : \"SetTemperature\" , \"parameters\" : { \"degrees\" : { \"sort\" : \"integer\" , \"value\" : 23 , \"grammar_entry\" : \"23\" } } }, \"context\" : { \"active_ddd\" : \"MyDDD\" , \"facts\" : { \"degrees\" : { \"sort\" : \"integer\" , \"value\" : 23 , \"grammar_entry\" : \"23\" } }, \"language\" : \"eng\" , \"invocation_id\" : \"2222-ijkl-3333-mnop\" } } Format for request : see Request object . Format for session : see Session object . Format for context : see Context object .","title":"Request"},{"location":"api-definitions/service_api/#response","text":"Actions invoked over HTTP can either succeed or fail with an expected reason. Below is the expected response body for the request above, when successful: { \"status\" : \"success\" , \"data\" : { \"version\" : \"1.1\" } } Format for status and data : see Response format . But say that someone tries to set the temperature of a refrigerator to 23 degrees, which is more than it can handle. If there's a failure reason temperature_too_high declared in service_interface.xml , the service can fail expectedly with: { \"status\" : \"fail\" , \"data\" : { \"version\" : \"1.1\" , \"reason\" : \"temperature_too_high\" } } Format for status and data : see Response format . The data object additionally contains these action specific members: reason matching the failure that occurred. It needs to match one of the failure reasons declared for this action in service_interface.xml .","title":"Response"},{"location":"api-definitions/service_api/#query-requests","text":"Queries are invoked by TDM to retrieve information from a service, e.g. in order to be able to respond to a question from a user, or to fetch alternatives for alternative questions.","title":"Query requests"},{"location":"api-definitions/service_api/#request_1","text":"Below is an example of a request body for a query called current_temperature with the parameter location , invoked when the user has asked for the temperature in London: { \"version\" : \"1.1\" , \"session\" : { \"session_id\" : \"0000-abcd-1111-efgh\" }, \"request\" : { \"type\" : \"query\" , \"name\" : \"current_temperature\" , \"parameters\" : { \"location\" : { \"sort\" : \"city\" , \"value\" : \"city_012345\" , \"grammar_entry\" : \"London\" } }, \"min_results\" : 1 , \"max_results\" : 1 }, \"context\" : { \"active_ddd\" : \"MyDDD\" , \"facts\" : { \"location\" : { \"sort\" : \"city\" , \"value\" : \"city_012345\" , \"grammar_entry\" : \"London\" } }, \"language\" : \"eng\" , \"invocation_id\" : \"2222-ijkl-3333-mnop\" } } Format for request : see Request object . The request object additionally contains these query specific members: min_results specifies the minimum number of results that the service should return as a non-negative integer. If the service returns fewer results than specified by min_results , TDM reports an error to the user. max_results specifies the maximum number of results that the service should return. max_results is either a positive integer, or null meaning that there is no upper bound. If the service returns more results than specified by max_results , TDM reports an error to the user. Format for session : see Session object . Format for context : see Context object .","title":"Request"},{"location":"api-definitions/service_api/#response_1","text":"Below is an example of a response body for the request above, when the current temperature in London is 17 degrees: { \"status\" : \"success\" , \"data\" : { \"version\" : \"1.1\" , \"result\" : [ { \"value\" : 17 , \"confidence\" : 1.0 , \"grammar_entry\" : null } ] } } General format for responses: see Response format . data additionally contains these members specific to queries: result : contains a list result items. Each result item is an object with the following members: value can be either a number, string or null , depending on the query's predicate. For predicates of sort integer or real , a number is expected. For predicates of sort datetime , an ISO 8601 string is expected. For predicates of a custom sort, a string is expected, corresponding to the name of the individual. For dynamic sorts, the value null is supported, in which case a grammar entry is required. confidence should normally be set to 1.0. However, when the information is uncertain - e.g. when making a prediction from a user model - confidence can be set to a value from 0.0 to 1.0. grammar_entry can be set to specify a natural-language represention of the result. This is required for dynamic sorts, when value is null .","title":"Response"},{"location":"api-definitions/service_api/#additional-query-example-multiple-results","text":"Below is an example of a request and response for a query called selected_contact which is used to determine whether a single contact can be identified based on a first and last name. In the example, only the first name is known, and the service returns two matching contacts. Request: { \"version\" : \"1.1\" , \"session\" : { \"session_id\" : \"0000-abcd-1111-efgh\" }, \"request\" : { \"type\" : \"query\" , \"name\" : \"selected_contact\" , \"parameters\" : { \"selected_first_name\" : { \"sort\" : \"first_name\" , \"value\" : \"fist_name_john\" , \"grammar_entry\" : \"John\" }, \"selected_last_name\" : null }, \"min_results\" : 0 , \"max_results\" : null }, \"context\" : { \"active_ddd\" : \"MyDDD\" , \"facts\" : { \"selected_first_name\" : { \"sort\" : \"first_name\" , \"value\" : \"fist_name_john\" , \"grammar_entry\" : \"John\" } }, \"language\" : \"eng\" , \"invocation_id\" : \"2222-ijkl-3333-mnop\" } } Response: { \"status\" : \"success\" , \"data\" : { \"version\" : \"1.1\" , \"result\" : [ { \"value\" : \"contact_john_johnson\" , \"confidence\" : 1.0 , \"grammar_entry\" : \"John Johnson\" }, { \"value\" : \"contact_john_thompson\" , \"confidence\" : 1.0 , \"grammar_entry\" : \"John Thompson\" } ] } } Also note that for this request example, the service may return an empty list of results if no matching contacts were found for the given parameters.","title":"Additional query example: Multiple results"},{"location":"api-definitions/service_api/#entity-recognizer-requests","text":"Entity recognizers are invoked by TDM to identify entities in user utterances.","title":"Entity recognizer requests"},{"location":"api-definitions/service_api/#request_2","text":"Below is an example of a request body for an entity recognition invocation when the user has said \"what is the temperature in London\": { \"version\" : \"1.1\" , \"session\" : { \"session_id\" : \"0000-abcd-1111-efgh\" }, \"request\" : { \"type\" : \"entity_recognizer\" , \"name\" : \"LocationRecognizer\" , \"utterance\" : \"what is the temperature in London\" }, \"context\" : { \"active_ddd\" : \"MyDDD\" , \"facts\" : {}, \"language\" : \"eng\" , \"invocation_id\" : \"2222-ijkl-3333-mnop\" } } Format for request : see Request object . The request object additionally contains these members specific to entity recognizers: utterance is the user utterance that should be searched for entities. It's a string. Format for session : see Session object . Format for context : see Context object .","title":"Request"},{"location":"api-definitions/service_api/#response_2","text":"Below is an example of a response body for the request above: { \"status\" : \"success\" , \"data\" : { \"version\" : \"1.1\" , \"result\" : [ { \"grammar_entry\" : \"London\" , \"sort\" : \"city\" , \"value\" : \"city_012345\" } ] } } General format for responses: see Response format . data additionally contains these members specific to entity recognizers: result : contains a list of zero or more result items. Each result item is an object with the following members: grammar_entry : Natural-language representation of the recognized entity. sort : The entity's sort, corresponding to the sort's name in ontology.xml . value : ID or semantic representation of the entity if known, otherwise null . For static (non-dynamic) sorts, the value is mandatory and should correspond to the semantic name of an individual.","title":"Response"},{"location":"api-definitions/service_api/#validator-requests","text":"Validators are invoked by TDM to determine if information provided by the user is valid. If not, relevant feedback is given to the user.","title":"Validator requests"},{"location":"api-definitions/service_api/#request_3","text":"Below is an example of a request body for a validator called RouteValidator with the parameters departure and destination : { \"version\" : \"1.1\" , \"session\" : { \"session_id\" : \"0000-abcd-1111-efgh\" }, \"request\" : { \"type\" : \"validator\" , \"name\" : \"RouteValidator\" , \"parameters\" : { \"departure\" : { \"sort\" : \"city\" , \"value\" : \"city_012345\" , \"grammar_entry\" : \"London\" }, \"destination\" : { \"sort\" : \"city\" , \"value\" : \"city_099998\" , \"grammar_entry\" : \"Chippinghirst\" } } }, \"context\" : { \"active_ddd\" : \"MyDDD\" , \"facts\" : { \"departure\" : { \"sort\" : \"city\" , \"value\" : \"city_012345\" , \"grammar_entry\" : \"London\" }, \"destination\" : { \"sort\" : \"city\" , \"value\" : \"city_099998\" , \"grammar_entry\" : \"Chippinghirst\" } }, \"language\" : \"eng\" , \"invocation_id\" : \"2222-ijkl-3333-mnop\" } } Format for request : see Request object . Format for session : see Session object . Format for context : see Context object .","title":"Request"},{"location":"api-definitions/service_api/#response_3","text":"Below is an example of a response body for the request above: { \"status\" : \"success\" , \"data\" : { \"version\" : \"1.1\" , \"is_valid\" : false } } General format for responses: see Response format . data additionally contains these validator specific members: is_valid : can be either true or false , specifying whether the combination of parameters is valid or not.","title":"Response"},{"location":"api-definitions/service_api/#request-object","text":"In general, the request object contains the following members. It may also contain additional method specific members. type is the method type, e.g. action or query . All methods that can be declared in service_interface.xml are supported. See examples for each of them above. name is the method name, as specified in service_interface.xml . parameters contains values for all parameters that are specified for the method in service_interface.xml . If a parameter is unknown, its value is null . Otherwise it's an object containing: sort : ID of the predicate's sort as defined in the ontology. value : ID of the value. For the sorts integer and real , the ID is a number. For other sorts, e.g. string , datetime and custom sorts, the ID is a string. grammar_entry : Natural-language representation of the value. Example: { \"request\" : { \"type\" : \"validator\" , \"name\" : \"contact_validator\" , \"parameters\" : { \"selected_first_name\" : { \"sort\" : \"first_name\" , \"value\" : \"fist_name_john\" , \"grammar_entry\" : \"John\" }, \"selected_last_name\" : null } } }","title":"Request object"},{"location":"api-definitions/service_api/#session-object","text":"The session object contains the following members: session_id : String representing the current TDM session. Additionally, it contains the same data that was injected in the frontend request to TDM. This way, service calls can utilize frontend-specific session data. For more details, read about the session object in the frontend API docs Example: { \"session\" : { \"session_id\" : \"0000-abcd-1111-efgh\" , \"my_frontend\" : { \"user_id\" : \"123-abc-456-def\" , \"position\" : { \"latitude\" : \"57.699188\" , \"longitude\" : \"11.948313\" } } } }","title":"Session object"},{"location":"api-definitions/service_api/#context-object","text":"The context object contains the following members: active_ddd : The name of the currently active DDD. facts : Information gathered during the conversation (see Facts object ). language : ID of the current language. invocation_id : A unique identifer for the invocation from TDM. This ID can be logged for analytics and issue reporting.","title":"Context object"},{"location":"api-definitions/service_api/#facts-object","text":"The facts object contains a map of key-value pairs for information gathered during the conversation, e.g. from the user. The map may be empty. The key is a string matching a predicate as defined in the ontology. The value is an object with the following members: sort : ID of the predicate's sort as defined in the ontology. value : ID of the value. For the sorts integer and real , the ID is a number. For other sorts, e.g. string , datetime and custom sorts, the ID is a string. grammar_entry : Natural-language representation of the value. Example: { \"facts\" : { \"departure\" : { \"sort\" : \"city\" , \"value\" : \"city_012345\" , \"grammar_entry\" : \"London\" }, \"destination\" : { \"sort\" : \"city\" , \"value\" : \"city_012346\" , \"grammar_entry\" : \"Newcastle\" } } }","title":"Facts object"},{"location":"api-definitions/service_api/#response-format","text":"All service responses adhere to the JSend specification . In general, responses can have one of three appearances, corresponding to the status of the invocation: success , fail and error . See the examples below. Success: { \"status\" : \"success\" , \"data\" : { \"version\" : \"1.1\" } } Successful method invocations need to set their status to success . The data object contains mostly method specific members. All methods need however include: version : the version of the API used to process the request and format the response. If the version is not compatible with the request, TDM reports an error to the user. Fail: { \"status\" : \"fail\" , \"data\" : { \"version\" : \"1.1\" } } Failures cannot be used with queries, entity recognizers or validators, but is supported by actions . If a fail status is not supported or is reported unexpectedly, it is treated as an error . error is however preferred over fail since a helpful message can be provided. TDM will report the error to the user, but will not mention any details. To report a failure, the status need to be set to fail . The data object contains mostly method specific members. All methods need however include: version : the version of the API used to process the request and format the response. Error: { \"status\" : \"error\" , \"message\" : \"Could not communicate with the database.\" , \"code\" : 135 , \"data\" : { \"version\" : \"1.1\" } } When a service encounters an error, i.e. an exception, the status need to be set to error . TDM will report the error to the user, but will not mention any details. message should be a human-readable message, explaining what went wrong. It will be logged but is not exposed to end-users. code (optional) is a numeric code identifying the error, if applicable. The data needs to contain: version : the version of the API used to process the request and format the response.","title":"Response format"},{"location":"api-definitions/shared_objects/","text":"Shared objects \u00b6 This document describes the objects that occur in requests and responses across different APIs. For example, see TDM pipeline API . Natural language input object \u00b6 Speech input example: { \"modality\" : \"speech\" , \"hypotheses\" : [ { \"utterance\" : \"call John\" , \"confidence\" : 0.81 }, { \"utterance\" : \"calling John\" , \"confidence\" : 0.65 }, { \"utterance\" : \"call him John\" , \"confidence\" : 0.31 } ] } Text input example: { \"modality\" : \"text\" , \"utterance\" : \"I'm searching for flights from London to Paris tomorrow\" } The natural language input contains the following members: modality : Should be either speech or text depending on how the input was detected. hypotheses : A list of hypothesis objects which should be provided if modality is speech ; otherwize the field should be omitted. utterance : A string containing the utterance if modality is text ; otherwize the field should be omitted. Hypothesis object \u00b6 A hypothesis object contains information about what the user is believed to have uttered, consisting of the following members: utterance : A string containing the utterance. confidence : A number from 0.0 to 1.0 representing the confidence of the hypothesis. Semantic input object \u00b6 { \"interpretations\" : [ { \"utterance\" : \"call John\" , \"modality\" : \"speech\" , \"moves\" : [ { \"perception_confidence\" : 0.81 , \"understanding_confidence\" : 0.92215 , \"ddd\" : \"phone\" , \"semantic_expression\" : \"request(call)\" }, { \"perception_confidence\" : 0.81 , \"understanding_confidence\" : 0.98532 , \"ddd\" : \"phone\" , \"semantic_expression\" : \"answer(contact_john)\" } ] }, { \"utterance\" : \"calling John\" , \"modality\" : \"speech\" , \"moves\" : [ { \"perception_confidence\" : 0.65 , \"understanding_confidence\" : 0.5234 , \"ddd\" : \"phone\" , \"semantic_expression\" : \"request(call)\" }, { \"perception_confidence\" : 0.65 , \"understanding_confidence\" : 0.98532 , \"ddd\" : \"phone\" , \"semantic_expression\" : \"answer(contact_john)\" } ] }, { \"utterance\" : \"call him John\" , \"modality\" : \"speech\" , \"moves\" : [ { \"perception_confidence\" : 0.31 , \"understanding_confidence\" : 0.2216 , \"ddd\" : \"phone\" , \"semantic_expression\" : \"request(call)\" }, { \"perception_confidence\" : 0.31 , \"understanding_confidence\" : 0.98532 , \"ddd\" : \"phone\" , \"semantic_expression\" : \"answer(contact_john)\" } ] }, { \"utterance\" : \"call him John\" , \"modality\" : \"speech\" , \"moves\" : [ { \"perception_confidence\" : 0.31 , \"understanding_confidence\" : 0.10126 , \"ddd\" : \"phone\" , \"semantic_expression\" : \"ask(?X.phone_number(X))\" }, { \"perception_confidence\" : 0.31 , \"understanding_confidence\" : 0.98532 , \"ddd\" : \"phone\" , \"semantic_expression\" : \"answer(contact_john)\" } ] } ], \"entities\" : [ { \"name\" : \"contact_john\" , \"sort\" : \"contact\" , \"natural_language_form\" : \"John\" } ] } The semantic input contains the following members: interpretations : A list of interpretation objects . TDM will use confidence scores and the context of the current state of the session to decide which interpretation to act upon. entities : (optional) A list of entity objects . TDM can use these entities in interpretations and for natural language generation. The semantic format is different for each of the supported user moves. See the move object for examples. Interpretation object \u00b6 An interpretation translates an utterance into one or several semantic moves. An interpretation object contains: utterance : (optional) A string containing the utterance. modality : The modality that the user used to provide the original input. One of speech , text , haptic , other . moves : A list of move objects . Entity object \u00b6 These entities are needed when entities are not defined in the DDD and can then be used in interpretations and in downstream natural language generation. An entity object contains: name : A string containing the semantic name. This name can be used to reference the entity in interpretations. sort : A string with the entity sort name. natural_language_form : A string containing the natural language or surface form of the entity. ddd : A string with the name of the DDD that the entity belongs to. NLU move object \u00b6 Note Move objects used for NLU differ from those used for NLG . A move object contains information about how a user move was interpreted (see moves ). Its members are: ddd : (optional) A string containing the DDD name. For DDD independent moves (e.g. answer(yes) and request(up) ), this field may be omitted; in which case the currently active DDD will be used to parse the semantic expression. perception_confidence : A float between 0.0 and 1.0 , representing the confidence that a spoken utterance actually matches the textual utterance, for instance when a speech-to-text (STT) component turned it into text. If no perception component was used, the confidence should be set to 1.0 . understanding_confidence : A float between 0.0 and 1.0 , representing the confidence that the textual utterance actually represents this move, for instance when an NLU component interprets the textual utterance. If no understanding component was used, for instance if the user pressed a button, the confidence should be set to 1.0 . semantic_expression : A semantic expression, representing the move itself. Supported moves are request , ask and answer . See examples below for details. Example of a request move: \u00b6 A request move has just one parameter: An action. In this case the call action, which must be defined in the ontology of the phone DDD. { \"ddd\" : \"phone\" , \"semantic_expression\" : \"request(call)\" , \"perception_confidence\" : 0.65 , \"understanding_confidence\" : 0.5234 } Example of builtin request move: \u00b6 The builtin and DDD independent actions top and up can be requested without including the DDD name: { \"semantic_expression\" : \"request(top)\" , \"perception_confidence\" : 0.56 , \"understanding_confidence\" : 0.65305 } Example of ask moves: \u00b6 An ask move contains a question. Questions are expressed with a leading ? . Question in ask moves always contain a predicate that must be defined in the ontology of the DDD. There are two supported types of questions in ask moves: wh-questions (questions about what, when, whom, which etc.) and yes-no questions (that can be answered with a yes or no). Example of an ask move containing a wh-question: \u00b6 Wh-questions are represented in a lambda-like form. In the case below, the question ?X.phone_number(X) means that we're asking what someone's phone number is. { \"ddd\" : \"phone\" , \"semantic_expression\" : \"ask(?X.phone_number(X))\" , \"perception_confidence\" : 0.31 , \"understanding_confidence\" : 0.10126 } Example of an ask move containing a yes-no question: \u00b6 In the case below, the question ?missed_calls means that we're asking whether there are any missed calls (without asking e.g. when or from whom). { \"ddd\" : \"phone\" , \"semantic_expression\" : \"ask(?missed_calls)\" , \"perception_confidence\" : 0.43 , \"understanding_confidence\" : 0.2432 } Example of a sortal answer move: \u00b6 A sortal answer move has an individual as its parameter. In this case, the individual contact_john , must be defined in the ontology of the phone DDD. { \"ddd\" : \"phone\" , \"semantic_expression\" : \"answer(contact_john)\" , \"perception_confidence\" : 0.65 , \"understanding_confidence\" : 0.98532 } Example of a propositional answer move: \u00b6 A propositional answer move has a proposition as its parameter, consisting of a predicate and an individual. In this case, the predicate selected_contact , and the individual contact_john , must be defined in the ontology of the phone DDD. { \"ddd\" : \"phone\" , \"semantic_expression\" : \"answer(selected_contact(contact_john))\" , \"perception_confidence\" : 0.65 , \"understanding_confidence\" : 0.71347 } Example of builtin sortal answer move: \u00b6 The builtin and DDD independent answers yes and no can be used without including the DDD name: { \"semantic_expression\" : \"answer(yes)\" , \"perception_confidence\" : 0.834 , \"understanding_confidence\" : 0.71359 } NLG Move object \u00b6 Note Move objects used for NLG differ from those used for NLU Example: { \"semantic_expression\" : \"ask(?X.selected_contact(X))\" } The Move object contains the following members: semantic_expression : A semantic expression of the expected move, expressed in the dialog formalism .","title":"Shared objects"},{"location":"api-definitions/shared_objects/#shared-objects","text":"This document describes the objects that occur in requests and responses across different APIs. For example, see TDM pipeline API .","title":"Shared objects"},{"location":"api-definitions/shared_objects/#natural-language-input-object","text":"Speech input example: { \"modality\" : \"speech\" , \"hypotheses\" : [ { \"utterance\" : \"call John\" , \"confidence\" : 0.81 }, { \"utterance\" : \"calling John\" , \"confidence\" : 0.65 }, { \"utterance\" : \"call him John\" , \"confidence\" : 0.31 } ] } Text input example: { \"modality\" : \"text\" , \"utterance\" : \"I'm searching for flights from London to Paris tomorrow\" } The natural language input contains the following members: modality : Should be either speech or text depending on how the input was detected. hypotheses : A list of hypothesis objects which should be provided if modality is speech ; otherwize the field should be omitted. utterance : A string containing the utterance if modality is text ; otherwize the field should be omitted.","title":"Natural language input object"},{"location":"api-definitions/shared_objects/#hypothesis-object","text":"A hypothesis object contains information about what the user is believed to have uttered, consisting of the following members: utterance : A string containing the utterance. confidence : A number from 0.0 to 1.0 representing the confidence of the hypothesis.","title":"Hypothesis object"},{"location":"api-definitions/shared_objects/#semantic-input-object","text":"{ \"interpretations\" : [ { \"utterance\" : \"call John\" , \"modality\" : \"speech\" , \"moves\" : [ { \"perception_confidence\" : 0.81 , \"understanding_confidence\" : 0.92215 , \"ddd\" : \"phone\" , \"semantic_expression\" : \"request(call)\" }, { \"perception_confidence\" : 0.81 , \"understanding_confidence\" : 0.98532 , \"ddd\" : \"phone\" , \"semantic_expression\" : \"answer(contact_john)\" } ] }, { \"utterance\" : \"calling John\" , \"modality\" : \"speech\" , \"moves\" : [ { \"perception_confidence\" : 0.65 , \"understanding_confidence\" : 0.5234 , \"ddd\" : \"phone\" , \"semantic_expression\" : \"request(call)\" }, { \"perception_confidence\" : 0.65 , \"understanding_confidence\" : 0.98532 , \"ddd\" : \"phone\" , \"semantic_expression\" : \"answer(contact_john)\" } ] }, { \"utterance\" : \"call him John\" , \"modality\" : \"speech\" , \"moves\" : [ { \"perception_confidence\" : 0.31 , \"understanding_confidence\" : 0.2216 , \"ddd\" : \"phone\" , \"semantic_expression\" : \"request(call)\" }, { \"perception_confidence\" : 0.31 , \"understanding_confidence\" : 0.98532 , \"ddd\" : \"phone\" , \"semantic_expression\" : \"answer(contact_john)\" } ] }, { \"utterance\" : \"call him John\" , \"modality\" : \"speech\" , \"moves\" : [ { \"perception_confidence\" : 0.31 , \"understanding_confidence\" : 0.10126 , \"ddd\" : \"phone\" , \"semantic_expression\" : \"ask(?X.phone_number(X))\" }, { \"perception_confidence\" : 0.31 , \"understanding_confidence\" : 0.98532 , \"ddd\" : \"phone\" , \"semantic_expression\" : \"answer(contact_john)\" } ] } ], \"entities\" : [ { \"name\" : \"contact_john\" , \"sort\" : \"contact\" , \"natural_language_form\" : \"John\" } ] } The semantic input contains the following members: interpretations : A list of interpretation objects . TDM will use confidence scores and the context of the current state of the session to decide which interpretation to act upon. entities : (optional) A list of entity objects . TDM can use these entities in interpretations and for natural language generation. The semantic format is different for each of the supported user moves. See the move object for examples.","title":"Semantic input object"},{"location":"api-definitions/shared_objects/#interpretation-object","text":"An interpretation translates an utterance into one or several semantic moves. An interpretation object contains: utterance : (optional) A string containing the utterance. modality : The modality that the user used to provide the original input. One of speech , text , haptic , other . moves : A list of move objects .","title":"Interpretation object"},{"location":"api-definitions/shared_objects/#entity-object","text":"These entities are needed when entities are not defined in the DDD and can then be used in interpretations and in downstream natural language generation. An entity object contains: name : A string containing the semantic name. This name can be used to reference the entity in interpretations. sort : A string with the entity sort name. natural_language_form : A string containing the natural language or surface form of the entity. ddd : A string with the name of the DDD that the entity belongs to.","title":"Entity object"},{"location":"api-definitions/shared_objects/#nlu-move-object","text":"Note Move objects used for NLU differ from those used for NLG . A move object contains information about how a user move was interpreted (see moves ). Its members are: ddd : (optional) A string containing the DDD name. For DDD independent moves (e.g. answer(yes) and request(up) ), this field may be omitted; in which case the currently active DDD will be used to parse the semantic expression. perception_confidence : A float between 0.0 and 1.0 , representing the confidence that a spoken utterance actually matches the textual utterance, for instance when a speech-to-text (STT) component turned it into text. If no perception component was used, the confidence should be set to 1.0 . understanding_confidence : A float between 0.0 and 1.0 , representing the confidence that the textual utterance actually represents this move, for instance when an NLU component interprets the textual utterance. If no understanding component was used, for instance if the user pressed a button, the confidence should be set to 1.0 . semantic_expression : A semantic expression, representing the move itself. Supported moves are request , ask and answer . See examples below for details.","title":"NLU move object"},{"location":"api-definitions/shared_objects/#example-of-a-request-move","text":"A request move has just one parameter: An action. In this case the call action, which must be defined in the ontology of the phone DDD. { \"ddd\" : \"phone\" , \"semantic_expression\" : \"request(call)\" , \"perception_confidence\" : 0.65 , \"understanding_confidence\" : 0.5234 }","title":"Example of a request move:"},{"location":"api-definitions/shared_objects/#example-of-builtin-request-move","text":"The builtin and DDD independent actions top and up can be requested without including the DDD name: { \"semantic_expression\" : \"request(top)\" , \"perception_confidence\" : 0.56 , \"understanding_confidence\" : 0.65305 }","title":"Example of builtin request move:"},{"location":"api-definitions/shared_objects/#example-of-ask-moves","text":"An ask move contains a question. Questions are expressed with a leading ? . Question in ask moves always contain a predicate that must be defined in the ontology of the DDD. There are two supported types of questions in ask moves: wh-questions (questions about what, when, whom, which etc.) and yes-no questions (that can be answered with a yes or no).","title":"Example of ask moves:"},{"location":"api-definitions/shared_objects/#example-of-an-ask-move-containing-a-wh-question","text":"Wh-questions are represented in a lambda-like form. In the case below, the question ?X.phone_number(X) means that we're asking what someone's phone number is. { \"ddd\" : \"phone\" , \"semantic_expression\" : \"ask(?X.phone_number(X))\" , \"perception_confidence\" : 0.31 , \"understanding_confidence\" : 0.10126 }","title":"Example of an ask move containing a wh-question:"},{"location":"api-definitions/shared_objects/#example-of-an-ask-move-containing-a-yes-no-question","text":"In the case below, the question ?missed_calls means that we're asking whether there are any missed calls (without asking e.g. when or from whom). { \"ddd\" : \"phone\" , \"semantic_expression\" : \"ask(?missed_calls)\" , \"perception_confidence\" : 0.43 , \"understanding_confidence\" : 0.2432 }","title":"Example of an ask move containing a yes-no question:"},{"location":"api-definitions/shared_objects/#example-of-a-sortal-answer-move","text":"A sortal answer move has an individual as its parameter. In this case, the individual contact_john , must be defined in the ontology of the phone DDD. { \"ddd\" : \"phone\" , \"semantic_expression\" : \"answer(contact_john)\" , \"perception_confidence\" : 0.65 , \"understanding_confidence\" : 0.98532 }","title":"Example of a sortal answer move:"},{"location":"api-definitions/shared_objects/#example-of-a-propositional-answer-move","text":"A propositional answer move has a proposition as its parameter, consisting of a predicate and an individual. In this case, the predicate selected_contact , and the individual contact_john , must be defined in the ontology of the phone DDD. { \"ddd\" : \"phone\" , \"semantic_expression\" : \"answer(selected_contact(contact_john))\" , \"perception_confidence\" : 0.65 , \"understanding_confidence\" : 0.71347 }","title":"Example of a propositional answer move:"},{"location":"api-definitions/shared_objects/#example-of-builtin-sortal-answer-move","text":"The builtin and DDD independent answers yes and no can be used without including the DDD name: { \"semantic_expression\" : \"answer(yes)\" , \"perception_confidence\" : 0.834 , \"understanding_confidence\" : 0.71359 }","title":"Example of builtin sortal answer move:"},{"location":"api-definitions/shared_objects/#nlg-move-object","text":"Note Move objects used for NLG differ from those used for NLU Example: { \"semantic_expression\" : \"ask(?X.selected_contact(X))\" } The Move object contains the following members: semantic_expression : A semantic expression of the expected move, expressed in the dialog formalism .","title":"NLG Move object"},{"location":"dialog-domain-description-definition/","text":"This part of the documentation describes how each part of a dialog domain description (DDD) is defined. This is work in progress, especially the domain language.","title":"Introduction"},{"location":"dialog-domain-description-definition/domain/domain/","text":"Dummy domain index (for now).","title":"Introduction"},{"location":"dialog-domain-description-definition/domain/children/ask_feature/","text":"Ask Feature \u00b6 Definition \u00b6 <ask_feature predicate= \"p\" kpq= \"true\" > The element that represents a question about a feature of an individual, that should be asked when using incremental search for finding an individual answer to a question. Attribute Type Description predicate string Required. The predicate must be enumerated in the ontology, and be indicated as feature-of the predicate of the over-arching findout. kpq boolean Optional. Indicates if the question of the ask feature should be asked as a Knowledge Precondition Question Parents \u00b6 <parameters> Children \u00b6 None. Behaviour \u00b6 An ask\\_feature is used in combination with incremental search. Each ask\\_feature represents a question that should be asked in order to find the answer to the question that is subject to incremental search. \"KPQ\" stands for Knowledge Precondition Question, and asks a question on the form \"Do you know ...\", for instance \"Do you know in what city she lives?\". The question can then be answered with \"Yes\", \"No\" or a resolving answer to the embedded question (\"Gothenburg\", \"London\" etc.). Examples \u00b6 A Ask Feature corresponding to the question \"In what city does the person live?\" \u00b6 <ask_feature predicate= \"person_city\" /> A KPQ Ask Feature corresponding to the question \"Do you know in what city the person lives?\" \u00b6 <ask_feature predicate= \"person_city\" kpq= \"true\" />","title":"Ask Feature"},{"location":"dialog-domain-description-definition/domain/children/ask_feature/#ask-feature","text":"","title":"Ask Feature"},{"location":"dialog-domain-description-definition/domain/children/ask_feature/#definition","text":"<ask_feature predicate= \"p\" kpq= \"true\" > The element that represents a question about a feature of an individual, that should be asked when using incremental search for finding an individual answer to a question. Attribute Type Description predicate string Required. The predicate must be enumerated in the ontology, and be indicated as feature-of the predicate of the over-arching findout. kpq boolean Optional. Indicates if the question of the ask feature should be asked as a Knowledge Precondition Question","title":"Definition"},{"location":"dialog-domain-description-definition/domain/children/ask_feature/#parents","text":"<parameters>","title":"Parents"},{"location":"dialog-domain-description-definition/domain/children/ask_feature/#children","text":"None.","title":"Children"},{"location":"dialog-domain-description-definition/domain/children/ask_feature/#behaviour","text":"An ask\\_feature is used in combination with incremental search. Each ask\\_feature represents a question that should be asked in order to find the answer to the question that is subject to incremental search. \"KPQ\" stands for Knowledge Precondition Question, and asks a question on the form \"Do you know ...\", for instance \"Do you know in what city she lives?\". The question can then be answered with \"Yes\", \"No\" or a resolving answer to the embedded question (\"Gothenburg\", \"London\" etc.).","title":"Behaviour"},{"location":"dialog-domain-description-definition/domain/children/ask_feature/#examples","text":"","title":"Examples"},{"location":"dialog-domain-description-definition/domain/children/ask_feature/#a-ask-feature-corresponding-to-the-question-in-what-city-does-the-person-live","text":"<ask_feature predicate= \"person_city\" />","title":"A Ask Feature corresponding to the question \"In what city does the person live?\""},{"location":"dialog-domain-description-definition/domain/children/ask_feature/#a-kpq-ask-feature-corresponding-to-the-question-do-you-know-in-what-city-the-person-lives","text":"<ask_feature predicate= \"person_city\" kpq= \"true\" />","title":"A KPQ Ask Feature corresponding to the question \"Do you know in what city the person lives?\""},{"location":"dialog-domain-description-definition/domain/children/assume_issue/","text":"Assume Issue \u00b6 Definition \u00b6 <assume_issue type= \"question_type\" predicate= \"p\" > The plan item that assumes that a question is relevant to the user. Defines a question that should be assumed. Attribute Type Description type string Required. The type can take one of the values \"wh_question\" or \"yn_question\". predicate string Required. This attribute specifies the predicate of the raised question. Parents \u00b6 <plan> Children \u00b6 None. Behaviour \u00b6 Using the element has exactly the same effect as if the user would have asked the question. The element defines a question through its attributes. The issue (or question) that is assumed, must have a resolve-goal in the domain file. Examples \u00b6 Assume-issue entry for assuming the issue about the departure time (which is the resolve goal of another plan): \u00b6 <assume_issue type= \"wh_question\" predicate= \"flight_departure\" />","title":"Assume Issue"},{"location":"dialog-domain-description-definition/domain/children/assume_issue/#assume-issue","text":"","title":"Assume Issue"},{"location":"dialog-domain-description-definition/domain/children/assume_issue/#definition","text":"<assume_issue type= \"question_type\" predicate= \"p\" > The plan item that assumes that a question is relevant to the user. Defines a question that should be assumed. Attribute Type Description type string Required. The type can take one of the values \"wh_question\" or \"yn_question\". predicate string Required. This attribute specifies the predicate of the raised question.","title":"Definition"},{"location":"dialog-domain-description-definition/domain/children/assume_issue/#parents","text":"<plan>","title":"Parents"},{"location":"dialog-domain-description-definition/domain/children/assume_issue/#children","text":"None.","title":"Children"},{"location":"dialog-domain-description-definition/domain/children/assume_issue/#behaviour","text":"Using the element has exactly the same effect as if the user would have asked the question. The element defines a question through its attributes. The issue (or question) that is assumed, must have a resolve-goal in the domain file.","title":"Behaviour"},{"location":"dialog-domain-description-definition/domain/children/assume_issue/#examples","text":"","title":"Examples"},{"location":"dialog-domain-description-definition/domain/children/assume_issue/#assume-issue-entry-for-assuming-the-issue-about-the-departure-time-which-is-the-resolve-goal-of-another-plan","text":"<assume_issue type= \"wh_question\" predicate= \"flight_departure\" />","title":"Assume-issue entry for assuming the issue about the departure time (which is the resolve goal of another plan):"},{"location":"dialog-domain-description-definition/domain/children/assume_system_belief/","text":"Assume System Belief \u00b6 Definition \u00b6 <assume_system_belief> <proposition predicate= \"p\" value= \"a\" /> </assume_system_belief> The plan item that assumes a proposition. The proposition will be a part of the system's private beliefs. Attribute Type Description None. - - Parents \u00b6 <plan> Children \u00b6 <proposition> Behaviour \u00b6 Using the element has the effect of adding the assumed proposition to the private beliefs of the system. This means that it is available as an answer to a question, or as a parameter to a service call. Assumptions will not be validated by user defined validators, and only propositions over individuals already known to the system can be made (e.g. static individuals). Examples \u00b6 Assume_System_Belief element for assuming that the user is an adult \u00b6 <assume_system_belief> <proposition predicate= \"user_age_category\" value= \"adult\" /> </assume_system_belief>","title":"Assume System Belief"},{"location":"dialog-domain-description-definition/domain/children/assume_system_belief/#assume-system-belief","text":"","title":"Assume System Belief"},{"location":"dialog-domain-description-definition/domain/children/assume_system_belief/#definition","text":"<assume_system_belief> <proposition predicate= \"p\" value= \"a\" /> </assume_system_belief> The plan item that assumes a proposition. The proposition will be a part of the system's private beliefs. Attribute Type Description None. - -","title":"Definition"},{"location":"dialog-domain-description-definition/domain/children/assume_system_belief/#parents","text":"<plan>","title":"Parents"},{"location":"dialog-domain-description-definition/domain/children/assume_system_belief/#children","text":"<proposition>","title":"Children"},{"location":"dialog-domain-description-definition/domain/children/assume_system_belief/#behaviour","text":"Using the element has the effect of adding the assumed proposition to the private beliefs of the system. This means that it is available as an answer to a question, or as a parameter to a service call. Assumptions will not be validated by user defined validators, and only propositions over individuals already known to the system can be made (e.g. static individuals).","title":"Behaviour"},{"location":"dialog-domain-description-definition/domain/children/assume_system_belief/#examples","text":"","title":"Examples"},{"location":"dialog-domain-description-definition/domain/children/assume_system_belief/#assume_system_belief-element-for-assuming-that-the-user-is-an-adult","text":"<assume_system_belief> <proposition predicate= \"user_age_category\" value= \"adult\" /> </assume_system_belief>","title":"Assume_System_Belief element for assuming that the user is an adult"},{"location":"dialog-domain-description-definition/domain/children/bind/","text":"Bind \u00b6 Definition \u00b6 <bind question_type= \"type\" predicate= \"p\" > The element defines a question that can be answered by the user, but will not be asked by the system. Attribute Type Description question_type string Required. Must be one of goal , wh_question , alt_question or yn_question . predicate string Optional. Required if question_type is wh_question or yn_question . Parents \u00b6 <plan> Children \u00b6 <alt> Behaviour \u00b6 The element defines a question that can be answered by the user, but will not be asked by the system, thereby `binding' that answer to the goal in question. This makes it possible to take into consideration optional and unrequested parameters. Examples \u00b6 Binding a WH question about price range (e.g. in a travel booking application) \u00b6 <bind type= \"wh_question\" predicate= \"price-class\" />","title":"Bind"},{"location":"dialog-domain-description-definition/domain/children/bind/#bind","text":"","title":"Bind"},{"location":"dialog-domain-description-definition/domain/children/bind/#definition","text":"<bind question_type= \"type\" predicate= \"p\" > The element defines a question that can be answered by the user, but will not be asked by the system. Attribute Type Description question_type string Required. Must be one of goal , wh_question , alt_question or yn_question . predicate string Optional. Required if question_type is wh_question or yn_question .","title":"Definition"},{"location":"dialog-domain-description-definition/domain/children/bind/#parents","text":"<plan>","title":"Parents"},{"location":"dialog-domain-description-definition/domain/children/bind/#children","text":"<alt>","title":"Children"},{"location":"dialog-domain-description-definition/domain/children/bind/#behaviour","text":"The element defines a question that can be answered by the user, but will not be asked by the system, thereby `binding' that answer to the goal in question. This makes it possible to take into consideration optional and unrequested parameters.","title":"Behaviour"},{"location":"dialog-domain-description-definition/domain/children/bind/#examples","text":"","title":"Examples"},{"location":"dialog-domain-description-definition/domain/children/bind/#binding-a-wh-question-about-price-range-eg-in-a-travel-booking-application","text":"<bind type= \"wh_question\" predicate= \"price-class\" />","title":"Binding a WH question about price range (e.g. in a travel booking application)"},{"location":"dialog-domain-description-definition/domain/children/downdate_condition/","text":"Downdate Condition \u00b6 Definition \u00b6 <downdate_condition> The element that specifies the conditions for downdating a particular perform goal. Attribute Type Description Parents \u00b6 <goal> Children \u00b6 <has_value> <is_shared_fact> <proposition> Behaviour \u00b6 If the condition embedded in a downdate_condition element evaluates to true, the goal is considered to be fulfilled, and the goal is downdated -- which means that the plan associated with the goal will no longer be running. More than one downdate_condition can be specified for each goal. If more than one condition is present, they will be treated as a logical or: any condition evaluated to true is enough for downdating the goal. Examples \u00b6 Downdate Condition for defining that once the departure time of a flight is known, the goal is considered to be fulfilled: \u00b6 <downdate_condition> <has_value predicate= \"flight_departure\" /> </downdate_condition> Downdate_condition for defining that if the flight departure is late, the goal is considered to be fulfilled: <downdate_condition> <is_shared_fact> <proposition predicate= \"flight_departure\" value= \"late\" /> </is_shared_fact> </downdate_condition>","title":"Downdate Condition"},{"location":"dialog-domain-description-definition/domain/children/downdate_condition/#downdate-condition","text":"","title":"Downdate Condition"},{"location":"dialog-domain-description-definition/domain/children/downdate_condition/#definition","text":"<downdate_condition> The element that specifies the conditions for downdating a particular perform goal. Attribute Type Description","title":"Definition"},{"location":"dialog-domain-description-definition/domain/children/downdate_condition/#parents","text":"<goal>","title":"Parents"},{"location":"dialog-domain-description-definition/domain/children/downdate_condition/#children","text":"<has_value> <is_shared_fact> <proposition>","title":"Children"},{"location":"dialog-domain-description-definition/domain/children/downdate_condition/#behaviour","text":"If the condition embedded in a downdate_condition element evaluates to true, the goal is considered to be fulfilled, and the goal is downdated -- which means that the plan associated with the goal will no longer be running. More than one downdate_condition can be specified for each goal. If more than one condition is present, they will be treated as a logical or: any condition evaluated to true is enough for downdating the goal.","title":"Behaviour"},{"location":"dialog-domain-description-definition/domain/children/downdate_condition/#examples","text":"","title":"Examples"},{"location":"dialog-domain-description-definition/domain/children/downdate_condition/#downdate-condition-for-defining-that-once-the-departure-time-of-a-flight-is-known-the-goal-is-considered-to-be-fulfilled","text":"<downdate_condition> <has_value predicate= \"flight_departure\" /> </downdate_condition> Downdate_condition for defining that if the flight departure is late, the goal is considered to be fulfilled: <downdate_condition> <is_shared_fact> <proposition predicate= \"flight_departure\" value= \"late\" /> </is_shared_fact> </downdate_condition>","title":"Downdate Condition for defining that once the departure time of a flight is known, the goal is considered to be fulfilled:"},{"location":"dialog-domain-description-definition/domain/children/findout/","text":"Findout \u00b6 Definition \u00b6 <findout question_type= \"type\" predicate= \"p\" > The element defines a question that should be answered, either by the user, or by some service connected to TDM capable of answering it. Attribute Type Description question_type string Required. Must be one of goal , wh_question , alt_question or yn_question . predicate string Optional. Required if question_type is wh_question or yn_question . allow_answer_from_pcom string Optional. Defaults to false . If set to true , this allows TDM to recycle an old answer that the user has previously provided. Parents \u00b6 <plan> Children \u00b6 <alt> Behaviour \u00b6 Examples \u00b6 A findout to ask the user what they want to do \u00b6 <findout type= \"goal\" /> A findout about a WH question, \"which colour would you like?\" \u00b6 <findout type= \"wh_question\" predicate= \"colour\" /> A findout about a Yes/No question, \"Would you like some fries with that?\" \u00b6 <findout type= \"yn_question\" predicate= \"side_order_fries\" /> A findout about a WH question, \"What is your destination?\", where the answer can be recycled from old answers \u00b6 <findout type= \"wh_question\" predicate= \"destination\" allow_answer_from_pcom= \"true\" /> A findout about an alt question, \"Would you like to calculate the monthly payment or would you like to know the interest rate?\" \u00b6 <findout type= \"alt_question\" > <alt> <resolve type= \"wh_question\" predicate= \"monthly_payment\" /> </alt> <alt> <resolve type= \"wh_question\" predicate= \"interest_rate\" /> </alt> </findout>","title":"Findout"},{"location":"dialog-domain-description-definition/domain/children/findout/#findout","text":"","title":"Findout"},{"location":"dialog-domain-description-definition/domain/children/findout/#definition","text":"<findout question_type= \"type\" predicate= \"p\" > The element defines a question that should be answered, either by the user, or by some service connected to TDM capable of answering it. Attribute Type Description question_type string Required. Must be one of goal , wh_question , alt_question or yn_question . predicate string Optional. Required if question_type is wh_question or yn_question . allow_answer_from_pcom string Optional. Defaults to false . If set to true , this allows TDM to recycle an old answer that the user has previously provided.","title":"Definition"},{"location":"dialog-domain-description-definition/domain/children/findout/#parents","text":"<plan>","title":"Parents"},{"location":"dialog-domain-description-definition/domain/children/findout/#children","text":"<alt>","title":"Children"},{"location":"dialog-domain-description-definition/domain/children/findout/#behaviour","text":"","title":"Behaviour"},{"location":"dialog-domain-description-definition/domain/children/findout/#examples","text":"","title":"Examples"},{"location":"dialog-domain-description-definition/domain/children/findout/#a-findout-to-ask-the-user-what-they-want-to-do","text":"<findout type= \"goal\" />","title":"A findout to ask the user what they want to do"},{"location":"dialog-domain-description-definition/domain/children/findout/#a-findout-about-a-wh-question-which-colour-would-you-like","text":"<findout type= \"wh_question\" predicate= \"colour\" />","title":"A findout about a WH question, \"which colour would you like?\""},{"location":"dialog-domain-description-definition/domain/children/findout/#a-findout-about-a-yesno-question-would-you-like-some-fries-with-that","text":"<findout type= \"yn_question\" predicate= \"side_order_fries\" />","title":"A findout about a Yes/No question, \"Would you like some fries with that?\""},{"location":"dialog-domain-description-definition/domain/children/findout/#a-findout-about-a-wh-question-what-is-your-destination-where-the-answer-can-be-recycled-from-old-answers","text":"<findout type= \"wh_question\" predicate= \"destination\" allow_answer_from_pcom= \"true\" />","title":"A findout about a WH question, \"What is your destination?\", where the answer can be recycled from old answers"},{"location":"dialog-domain-description-definition/domain/children/findout/#a-findout-about-an-alt-question-would-you-like-to-calculate-the-monthly-payment-or-would-you-like-to-know-the-interest-rate","text":"<findout type= \"alt_question\" > <alt> <resolve type= \"wh_question\" predicate= \"monthly_payment\" /> </alt> <alt> <resolve type= \"wh_question\" predicate= \"interest_rate\" /> </alt> </findout>","title":"A findout about an alt question, \"Would you like to calculate the monthly payment or would you like to know the interest rate?\""},{"location":"dialog-domain-description-definition/domain/children/has_value/","text":"Has Value \u00b6 Definition \u00b6 <has_value predicate= \"p\" > The condition that evaluates to true if there is a shared fact that is a proposition using the predicate p , and false otherwise. Attribute Type Description predicate string Required. This attribute specifies the predicate of the proposition. Parents \u00b6 <downdate_condition> Children \u00b6 None. Behaviour \u00b6 The condition that evaluates to true if there is a shared fact that is a proposition using the predicate p , and false otherwise. It is a child element of the downdate_condition element. has_value element for defining the condition that evaluates to true once the departure of a flight is known: \u00b6 <has_value predicate= \"flight_departure\" />","title":"Has Value"},{"location":"dialog-domain-description-definition/domain/children/has_value/#has-value","text":"","title":"Has Value"},{"location":"dialog-domain-description-definition/domain/children/has_value/#definition","text":"<has_value predicate= \"p\" > The condition that evaluates to true if there is a shared fact that is a proposition using the predicate p , and false otherwise. Attribute Type Description predicate string Required. This attribute specifies the predicate of the proposition.","title":"Definition"},{"location":"dialog-domain-description-definition/domain/children/has_value/#parents","text":"<downdate_condition>","title":"Parents"},{"location":"dialog-domain-description-definition/domain/children/has_value/#children","text":"None.","title":"Children"},{"location":"dialog-domain-description-definition/domain/children/has_value/#behaviour","text":"The condition that evaluates to true if there is a shared fact that is a proposition using the predicate p , and false otherwise. It is a child element of the downdate_condition element.","title":"Behaviour"},{"location":"dialog-domain-description-definition/domain/children/has_value/#has_value-element-for-defining-the-condition-that-evaluates-to-true-once-the-departure-of-a-flight-is-known","text":"<has_value predicate= \"flight_departure\" />","title":"has_value element for defining the condition that evaluates to true once the departure of a flight is known:"},{"location":"dialog-domain-description-definition/domain/children/invoke_service_action/","text":"Invoke Service Action \u00b6 Definition \u00b6 <invoke-service-action name= \"alpha\" > Calls for an action to be performed by a service. Attribute Type Description name string Required. The name of the Action as defined in the Service Interface. preconfirm string Optional. Can be set to \"assertive\" or \"interrogative\". If defined, causes system to ask for a confirmation from the user before performing the action. postconfirm boolean Optional. If set to `True', causes the system to report on the status of the action downdate_plan boolean Optional. If set to `True', causes the system to regard the action as done once the device has been called to carry out the action. Parents \u00b6 <plan> Children \u00b6 None. Behaviour \u00b6 An element calls for an action to be performed by a service. The action needs to be defined by the Service Interface . If defined, the `preconfirm' attribute causes system to give the user the opportunity to confirm (or abort) an action before it is performed. Can be set to \"assertive\" (e.g., \"Do you want to call John\") or \"interrogative\" (e.g. \"I will call John\"), depending on whether the preconfirmation should take the form of an assertion (which the user can respond, but if they do not, the system will go ahead and perform the action) or a question (requiring an answer from the user). The natural language form of the preconfirmation is defined in the grammar, see Preconfirm . The natural language form can be configured to include parameters of the action. If set to True', the postconfirm' attribute causes the system to report on the status of the action after calling on the device to carry out the action. The natural language form of the postconfirmation is defined in the grammar, see Report . If set to `True', the 'downdate_plan' element causes the system to regard the action as done once the device has been called to carry out the action. Otherwise, it will not regard the action as done until it has been explicitly reported to be done. The latter may be useful for actions that need to succeed. Examples \u00b6 Invoke service action entry for calling a person, first confirming that the parameters are correct, and reporting again when the call has been made: \u00b6 <invoke_service_action name= \"Call\" preconfirm= interrogative postconfirm= True downdate_plan= False/ >","title":"Invoke Service Action"},{"location":"dialog-domain-description-definition/domain/children/invoke_service_action/#invoke-service-action","text":"","title":"Invoke Service Action"},{"location":"dialog-domain-description-definition/domain/children/invoke_service_action/#definition","text":"<invoke-service-action name= \"alpha\" > Calls for an action to be performed by a service. Attribute Type Description name string Required. The name of the Action as defined in the Service Interface. preconfirm string Optional. Can be set to \"assertive\" or \"interrogative\". If defined, causes system to ask for a confirmation from the user before performing the action. postconfirm boolean Optional. If set to `True', causes the system to report on the status of the action downdate_plan boolean Optional. If set to `True', causes the system to regard the action as done once the device has been called to carry out the action.","title":"Definition"},{"location":"dialog-domain-description-definition/domain/children/invoke_service_action/#parents","text":"<plan>","title":"Parents"},{"location":"dialog-domain-description-definition/domain/children/invoke_service_action/#children","text":"None.","title":"Children"},{"location":"dialog-domain-description-definition/domain/children/invoke_service_action/#behaviour","text":"An element calls for an action to be performed by a service. The action needs to be defined by the Service Interface . If defined, the `preconfirm' attribute causes system to give the user the opportunity to confirm (or abort) an action before it is performed. Can be set to \"assertive\" (e.g., \"Do you want to call John\") or \"interrogative\" (e.g. \"I will call John\"), depending on whether the preconfirmation should take the form of an assertion (which the user can respond, but if they do not, the system will go ahead and perform the action) or a question (requiring an answer from the user). The natural language form of the preconfirmation is defined in the grammar, see Preconfirm . The natural language form can be configured to include parameters of the action. If set to True', the postconfirm' attribute causes the system to report on the status of the action after calling on the device to carry out the action. The natural language form of the postconfirmation is defined in the grammar, see Report . If set to `True', the 'downdate_plan' element causes the system to regard the action as done once the device has been called to carry out the action. Otherwise, it will not regard the action as done until it has been explicitly reported to be done. The latter may be useful for actions that need to succeed.","title":"Behaviour"},{"location":"dialog-domain-description-definition/domain/children/invoke_service_action/#examples","text":"","title":"Examples"},{"location":"dialog-domain-description-definition/domain/children/invoke_service_action/#invoke-service-action-entry-for-calling-a-person-first-confirming-that-the-parameters-are-correct-and-reporting-again-when-the-call-has-been-made","text":"<invoke_service_action name= \"Call\" preconfirm= interrogative postconfirm= True downdate_plan= False/ >","title":"Invoke service action entry for calling a person, first confirming that the parameters are correct, and reporting again when the call has been made:"},{"location":"dialog-domain-description-definition/domain/children/invoke_service_query/","text":"Invoke Service Query \u00b6 Definition \u00b6 <invoke_service_query type= \"wh_question\" predicate= \"p\" /> <invoke_service_query type= \"yn_question\" > <proposition predicate= \"p\" > </invoke_service_query> Calls for an query to be sent to a service. Attribute Type Description type string Required. The value is one of \"yn_question\" and \"wh_question\". predicate string Required if type=\"wh_question\". This attribute specifies the predicate of the question sent to the service. Parents \u00b6 <plan> Children \u00b6 <proposition> Behaviour \u00b6 An element calls for a query to be sent to a service, which (if successful) returns an answer. The answer first becomes known to the system, and if the system knows the answer and the question is a goal question, this will trigger the system providing the answer to the user. Examples \u00b6 Invoke service query for getting the price of a trip. \u00b6 <invoke_service_query type= \"wh_question\" predicate= \"price\" /> Invoke service query for checking if a person needs a visa. \u00b6 <invoke_service_query type= \"yn_question\" > <proposition predicate= \"need_visa\" /> </invoke_service_query>","title":"Invoke Service Query"},{"location":"dialog-domain-description-definition/domain/children/invoke_service_query/#invoke-service-query","text":"","title":"Invoke Service Query"},{"location":"dialog-domain-description-definition/domain/children/invoke_service_query/#definition","text":"<invoke_service_query type= \"wh_question\" predicate= \"p\" /> <invoke_service_query type= \"yn_question\" > <proposition predicate= \"p\" > </invoke_service_query> Calls for an query to be sent to a service. Attribute Type Description type string Required. The value is one of \"yn_question\" and \"wh_question\". predicate string Required if type=\"wh_question\". This attribute specifies the predicate of the question sent to the service.","title":"Definition"},{"location":"dialog-domain-description-definition/domain/children/invoke_service_query/#parents","text":"<plan>","title":"Parents"},{"location":"dialog-domain-description-definition/domain/children/invoke_service_query/#children","text":"<proposition>","title":"Children"},{"location":"dialog-domain-description-definition/domain/children/invoke_service_query/#behaviour","text":"An element calls for a query to be sent to a service, which (if successful) returns an answer. The answer first becomes known to the system, and if the system knows the answer and the question is a goal question, this will trigger the system providing the answer to the user.","title":"Behaviour"},{"location":"dialog-domain-description-definition/domain/children/invoke_service_query/#examples","text":"","title":"Examples"},{"location":"dialog-domain-description-definition/domain/children/invoke_service_query/#invoke-service-query-for-getting-the-price-of-a-trip","text":"<invoke_service_query type= \"wh_question\" predicate= \"price\" />","title":"Invoke service query for getting the price of a trip."},{"location":"dialog-domain-description-definition/domain/children/invoke_service_query/#invoke-service-query-for-checking-if-a-person-needs-a-visa","text":"<invoke_service_query type= \"yn_question\" > <proposition predicate= \"need_visa\" /> </invoke_service_query>","title":"Invoke service query for checking if a person needs a visa."},{"location":"dialog-domain-description-definition/domain/children/is_shared_fact/","text":"Is Shared Fact \u00b6 Definition \u00b6 <is_shared_fact> The condition that evaluates to true if there is a shared fact that is identical to the proposition that is the child of this element. Attribute Type Description None. Parents \u00b6 <downdate_condition> Children \u00b6 <proposition> Behaviour \u00b6 The condition that evaluates to true if there is a shared fact that is identical to the proposition that is the child of this element and false otherwise. It is the child element of the downdate_condition element. Examples \u00b6 is_shared_fact which will evaluate to true if the departure is late: \u00b6 <is_shared_fact> <proposition predicate= \"flight_departure\" value= \"late\" /> </is_shared_fact>","title":"Is Shared Fact"},{"location":"dialog-domain-description-definition/domain/children/is_shared_fact/#is-shared-fact","text":"","title":"Is Shared Fact"},{"location":"dialog-domain-description-definition/domain/children/is_shared_fact/#definition","text":"<is_shared_fact> The condition that evaluates to true if there is a shared fact that is identical to the proposition that is the child of this element. Attribute Type Description None.","title":"Definition"},{"location":"dialog-domain-description-definition/domain/children/is_shared_fact/#parents","text":"<downdate_condition>","title":"Parents"},{"location":"dialog-domain-description-definition/domain/children/is_shared_fact/#children","text":"<proposition>","title":"Children"},{"location":"dialog-domain-description-definition/domain/children/is_shared_fact/#behaviour","text":"The condition that evaluates to true if there is a shared fact that is identical to the proposition that is the child of this element and false otherwise. It is the child element of the downdate_condition element.","title":"Behaviour"},{"location":"dialog-domain-description-definition/domain/children/is_shared_fact/#examples","text":"","title":"Examples"},{"location":"dialog-domain-description-definition/domain/children/is_shared_fact/#is_shared_fact-which-will-evaluate-to-true-if-the-departure-is-late","text":"<is_shared_fact> <proposition predicate= \"flight_departure\" value= \"late\" /> </is_shared_fact>","title":"is_shared_fact which will evaluate to true if the departure is late:"},{"location":"dialog-domain-description-definition/domain/children/log/","text":"Log \u00b6 Definition \u00b6 <log message= \"This is a log message\" > The plan item logs a message on DEBUG level. Attribute Type Description message string Required. The value of the message attribute is currently the only thing that is logged. Parents \u00b6 <plan> Children \u00b6 None Behaviour \u00b6 Using the element will log the message on debug level. The log entry will contain the following: { \"message\" : \"This is a log message\" , \"event\" : \"Executing <log> element in domain.xml\" } Examples \u00b6 Log element for logging a string: \u00b6 <log message= \"This is a log message\" >","title":"Log"},{"location":"dialog-domain-description-definition/domain/children/log/#log","text":"","title":"Log"},{"location":"dialog-domain-description-definition/domain/children/log/#definition","text":"<log message= \"This is a log message\" > The plan item logs a message on DEBUG level. Attribute Type Description message string Required. The value of the message attribute is currently the only thing that is logged.","title":"Definition"},{"location":"dialog-domain-description-definition/domain/children/log/#parents","text":"<plan>","title":"Parents"},{"location":"dialog-domain-description-definition/domain/children/log/#children","text":"None","title":"Children"},{"location":"dialog-domain-description-definition/domain/children/log/#behaviour","text":"Using the element will log the message on debug level. The log entry will contain the following: { \"message\" : \"This is a log message\" , \"event\" : \"Executing <log> element in domain.xml\" }","title":"Behaviour"},{"location":"dialog-domain-description-definition/domain/children/log/#examples","text":"","title":"Examples"},{"location":"dialog-domain-description-definition/domain/children/log/#log-element-for-logging-a-string","text":"<log message= \"This is a log message\" >","title":"Log element for logging a string:"},{"location":"dialog-domain-description-definition/domain/children/plan/","text":"Plan \u00b6 Definition \u00b6 <plan> ... </plan> A dialogue plan, consisting of a sequence of plan items. Parents \u00b6 <goal> Children \u00b6 <forget> <forget_all> <log> <invoke_service_query> <invoke_service_action> <findout> <raise> <bind> <get_done> <assume_issue> <assume_shared> <assume_system_belief> <if> <jumpto> Behaviour \u00b6 To resolve questions, or perform actions, TDM executes a dialogue plan. In some cases the plan is equivalent to a form with slots and values that need to be filled, after which the requested action can be carried out, or the asked question can be answered by the system. However, dialogue plans are more powerful than forms in the kinds of dialogue behaviours they can produce. Examples \u00b6 Plan for asking a sequence of questions and getting the price of a trip. \u00b6 <plan> <findout type= \"wh_question\" predicate= \"means_of_transport\" /> <findout type= \"wh_question\" predicate= \"dest_city\" /> <findout type= \"wh_question\" predicate= \"dept_city\" /> <findout type= \"wh_question\" predicate= \"dept_month\" /> <findout type= \"wh_question\" predicate= \"dept_day\" /> <findout type= \"wh_question\" predicate= \"class\" /> <invoke_service_query type= \"wh_question\" predicate= \"price\" /> </plan>","title":"Plan"},{"location":"dialog-domain-description-definition/domain/children/plan/#plan","text":"","title":"Plan"},{"location":"dialog-domain-description-definition/domain/children/plan/#definition","text":"<plan> ... </plan> A dialogue plan, consisting of a sequence of plan items.","title":"Definition"},{"location":"dialog-domain-description-definition/domain/children/plan/#parents","text":"<goal>","title":"Parents"},{"location":"dialog-domain-description-definition/domain/children/plan/#children","text":"<forget> <forget_all> <log> <invoke_service_query> <invoke_service_action> <findout> <raise> <bind> <get_done> <assume_issue> <assume_shared> <assume_system_belief> <if> <jumpto>","title":"Children"},{"location":"dialog-domain-description-definition/domain/children/plan/#behaviour","text":"To resolve questions, or perform actions, TDM executes a dialogue plan. In some cases the plan is equivalent to a form with slots and values that need to be filled, after which the requested action can be carried out, or the asked question can be answered by the system. However, dialogue plans are more powerful than forms in the kinds of dialogue behaviours they can produce.","title":"Behaviour"},{"location":"dialog-domain-description-definition/domain/children/plan/#examples","text":"","title":"Examples"},{"location":"dialog-domain-description-definition/domain/children/plan/#plan-for-asking-a-sequence-of-questions-and-getting-the-price-of-a-trip","text":"<plan> <findout type= \"wh_question\" predicate= \"means_of_transport\" /> <findout type= \"wh_question\" predicate= \"dest_city\" /> <findout type= \"wh_question\" predicate= \"dept_city\" /> <findout type= \"wh_question\" predicate= \"dept_month\" /> <findout type= \"wh_question\" predicate= \"dept_day\" /> <findout type= \"wh_question\" predicate= \"class\" /> <invoke_service_query type= \"wh_question\" predicate= \"price\" /> </plan>","title":"Plan for asking a sequence of questions and getting the price of a trip."},{"location":"dialog-domain-description-definition/domain/children/proposition/","text":"Proposition \u00b6 Definition \u00b6 <proposition predicate= \"p\" value= \"a\" > The element that represents a proposition, consisting of a predicate on an individual. Attribute Type Description predicate string Required. The value must be enumerated in the ontology. value string Required. The value must be known to TDM e.g. by being a static individual enumerated in the ontology. Parents \u00b6 <is_shared_fact> Children \u00b6 None. Behaviour \u00b6 The proposition is used in conditional constructs in the domain language. Examples \u00b6 Proposition for the colour blue: \u00b6 <proposition predicate= \"color\" value= \"blue\" />","title":"Proposition"},{"location":"dialog-domain-description-definition/domain/children/proposition/#proposition","text":"","title":"Proposition"},{"location":"dialog-domain-description-definition/domain/children/proposition/#definition","text":"<proposition predicate= \"p\" value= \"a\" > The element that represents a proposition, consisting of a predicate on an individual. Attribute Type Description predicate string Required. The value must be enumerated in the ontology. value string Required. The value must be known to TDM e.g. by being a static individual enumerated in the ontology.","title":"Definition"},{"location":"dialog-domain-description-definition/domain/children/proposition/#parents","text":"<is_shared_fact>","title":"Parents"},{"location":"dialog-domain-description-definition/domain/children/proposition/#children","text":"None.","title":"Children"},{"location":"dialog-domain-description-definition/domain/children/proposition/#behaviour","text":"The proposition is used in conditional constructs in the domain language.","title":"Behaviour"},{"location":"dialog-domain-description-definition/domain/children/proposition/#examples","text":"","title":"Examples"},{"location":"dialog-domain-description-definition/domain/children/proposition/#proposition-for-the-colour-blue","text":"<proposition predicate= \"color\" value= \"blue\" />","title":"Proposition for the colour blue:"},{"location":"dialog-domain-description-definition/domain/elements/goal/","text":"Parameters \u00b6 Definition \u00b6 <goal type= \"...\" ... > Attribute Type Description type string Required. Needs to be one of resolve or perform . action string Optional. Needed if the type is perform . The action needs to be declared in ontology.xml . question_type string Optional. Needed if the type is resolve . Needs to be one of wh_question or yn_question . In case of an yn_question the goal needs a proposition child. predicate string Optional. Needed if the type is wh_question . The predicate needs to be declared in ontology.xml . accommodate_without_feedback boolean Optional. Indicates whether the default system behavior to give feedback when accommodating the goal, e.g. uttering \"Book a travel\" in response to \"From London to Paris tomorrow\", should be disabled. reraise_on_resume boolean Optional. Indicates whether the default system behavior to give feedback when reraising the goal, e.g. \"Returning to booking a travel\", should be disabled. restart_on_completion boolean Optional. Indicates if the goal should be restarted immediately after completion. This can be handy when a dialogue system is designed to perform a single task again and again. max_answers integer Optional. Defines the maximum number of answers that the system can give, when the user asks a question about several alternatives at once, e.g. \"How old are they?\" By default, max_answers has the value 1, meaning that user questions about several alternatives are not supported. alternatives_predicate string Optional. If max_answers>1, alternatives_predicate is required and provides the name of predicate that distinguishes the alternatives, e.g. \"person\" if the question concerns several persons. Parents \u00b6 <domain> Children \u00b6 <proposition> <plan> <downdate_condition> <postplan> <preferred> <superaction> Behaviour \u00b6 The element defines a goal, including the plan to achieve the goal. This is the basic building block of a DDD. It defines a goal, which must be of one of the types perform or resolve . A perform goal indicates that something should be performed, while a resolve goal indicates that a question should be answered. Although there is nothing preventing the plan of a perform goal to actually answer a question, it is considered good practice to leave that to resolve goals. Examples \u00b6 A perform goal that will quietly be restarted \u00b6 <goal type= \"perform\" action= \"adjust_temperature\" reraise_on_resume= \"false\" > <plan> <findout type= \"wh_question\" predicate= \"desired_temperature\" /> <invoke_service_query type= \"wh_question\" predicate= \"current_temperature\" /> <invoke_service_action name= \"SetTemperature\" postconfirm= \"true\" /> </plan> </goal>","title":"Goal"},{"location":"dialog-domain-description-definition/domain/elements/goal/#parameters","text":"","title":"Parameters"},{"location":"dialog-domain-description-definition/domain/elements/goal/#definition","text":"<goal type= \"...\" ... > Attribute Type Description type string Required. Needs to be one of resolve or perform . action string Optional. Needed if the type is perform . The action needs to be declared in ontology.xml . question_type string Optional. Needed if the type is resolve . Needs to be one of wh_question or yn_question . In case of an yn_question the goal needs a proposition child. predicate string Optional. Needed if the type is wh_question . The predicate needs to be declared in ontology.xml . accommodate_without_feedback boolean Optional. Indicates whether the default system behavior to give feedback when accommodating the goal, e.g. uttering \"Book a travel\" in response to \"From London to Paris tomorrow\", should be disabled. reraise_on_resume boolean Optional. Indicates whether the default system behavior to give feedback when reraising the goal, e.g. \"Returning to booking a travel\", should be disabled. restart_on_completion boolean Optional. Indicates if the goal should be restarted immediately after completion. This can be handy when a dialogue system is designed to perform a single task again and again. max_answers integer Optional. Defines the maximum number of answers that the system can give, when the user asks a question about several alternatives at once, e.g. \"How old are they?\" By default, max_answers has the value 1, meaning that user questions about several alternatives are not supported. alternatives_predicate string Optional. If max_answers>1, alternatives_predicate is required and provides the name of predicate that distinguishes the alternatives, e.g. \"person\" if the question concerns several persons.","title":"Definition"},{"location":"dialog-domain-description-definition/domain/elements/goal/#parents","text":"<domain>","title":"Parents"},{"location":"dialog-domain-description-definition/domain/elements/goal/#children","text":"<proposition> <plan> <downdate_condition> <postplan> <preferred> <superaction>","title":"Children"},{"location":"dialog-domain-description-definition/domain/elements/goal/#behaviour","text":"The element defines a goal, including the plan to achieve the goal. This is the basic building block of a DDD. It defines a goal, which must be of one of the types perform or resolve . A perform goal indicates that something should be performed, while a resolve goal indicates that a question should be answered. Although there is nothing preventing the plan of a perform goal to actually answer a question, it is considered good practice to leave that to resolve goals.","title":"Behaviour"},{"location":"dialog-domain-description-definition/domain/elements/goal/#examples","text":"","title":"Examples"},{"location":"dialog-domain-description-definition/domain/elements/goal/#a-perform-goal-that-will-quietly-be-restarted","text":"<goal type= \"perform\" action= \"adjust_temperature\" reraise_on_resume= \"false\" > <plan> <findout type= \"wh_question\" predicate= \"desired_temperature\" /> <invoke_service_query type= \"wh_question\" predicate= \"current_temperature\" /> <invoke_service_action name= \"SetTemperature\" postconfirm= \"true\" /> </plan> </goal>","title":"A perform goal that will quietly be restarted"},{"location":"dialog-domain-description-definition/domain/elements/parameters/","text":"Parameters \u00b6 Definition \u00b6 <parameters question_type= \"type\" predicate= \"p\" > The element defines parameters to a particular question. Attribute Type Description verbalize boolean Optional. Describes whether a question should be verbalized or not by the system. incremental boolean Optional. If set to true, the question is subject to \"incremental search\", i.e. that the answer to the question is specified step-by-step by the user graphical_type string Optional. For historical reasons, the graphical type of a question must be set to \"list\" for incremental search to work. allow_goal_accommodation boolean Optional. max_spoken_alts integer Optional. The maximum number of possible answers the the question that are read out to the user. Used in connection with incremental search. max_reported_hit_count integer Optional. The maximum number of hits that are reported to the user. Used in connection with incremental search. source string Optional. One of the values \"domain\" or \"service\" is expected. Used in connection with incremental search. Parents \u00b6 <domain> Children \u00b6 <ask_feature> Behaviour \u00b6 Examples \u00b6 A parameter set designed to do incremental search for a person. \u00b6 The question that is supposed to get an answer from a findout is the WH-question over the predicate \"person\". The parameter source is set to service, which means that a http service query will be used to find possible answers to the question. Incremental search is activated. The maximum number of hits that will be reported to the user is 10. <parameters question_type= \"wh_question\" predicate= \"person\" graphical_type= \"list\" source= \"service\" incremental= \"true\" max_reported_hit_count= \"10\" > <ask_feature predicate= \"person_name\" /> <ask_feature predicate= \"person_city\" kpq= \"true\" /> <ask_feature predicate= \"person_area\" /> </parameters>","title":"Parameters"},{"location":"dialog-domain-description-definition/domain/elements/parameters/#parameters","text":"","title":"Parameters"},{"location":"dialog-domain-description-definition/domain/elements/parameters/#definition","text":"<parameters question_type= \"type\" predicate= \"p\" > The element defines parameters to a particular question. Attribute Type Description verbalize boolean Optional. Describes whether a question should be verbalized or not by the system. incremental boolean Optional. If set to true, the question is subject to \"incremental search\", i.e. that the answer to the question is specified step-by-step by the user graphical_type string Optional. For historical reasons, the graphical type of a question must be set to \"list\" for incremental search to work. allow_goal_accommodation boolean Optional. max_spoken_alts integer Optional. The maximum number of possible answers the the question that are read out to the user. Used in connection with incremental search. max_reported_hit_count integer Optional. The maximum number of hits that are reported to the user. Used in connection with incremental search. source string Optional. One of the values \"domain\" or \"service\" is expected. Used in connection with incremental search.","title":"Definition"},{"location":"dialog-domain-description-definition/domain/elements/parameters/#parents","text":"<domain>","title":"Parents"},{"location":"dialog-domain-description-definition/domain/elements/parameters/#children","text":"<ask_feature>","title":"Children"},{"location":"dialog-domain-description-definition/domain/elements/parameters/#behaviour","text":"","title":"Behaviour"},{"location":"dialog-domain-description-definition/domain/elements/parameters/#examples","text":"","title":"Examples"},{"location":"dialog-domain-description-definition/domain/elements/parameters/#a-parameter-set-designed-to-do-incremental-search-for-a-person","text":"The question that is supposed to get an answer from a findout is the WH-question over the predicate \"person\". The parameter source is set to service, which means that a http service query will be used to find possible answers to the question. Incremental search is activated. The maximum number of hits that will be reported to the user is 10. <parameters question_type= \"wh_question\" predicate= \"person\" graphical_type= \"list\" source= \"service\" incremental= \"true\" max_reported_hit_count= \"10\" > <ask_feature predicate= \"person_name\" /> <ask_feature predicate= \"person_city\" kpq= \"true\" /> <ask_feature predicate= \"person_area\" /> </parameters>","title":"A parameter set designed to do incremental search for a person."},{"location":"dialog-domain-description-definition/grammar/grammar/","text":"Dummy grammar index (for now).","title":"Introduction"},{"location":"dialog-domain-description-definition/grammar/children/item/","text":"Item \u00b6 Definition \u00b6 <item> The grammar entry of items. Each item contains a separate phrase that can be used by the system or the user to speak about the parent element. Parents \u00b6 <one-of> Children \u00b6 <slot> <vp> <infinitive> <imperative> <ing-form> <object> Behaviour \u00b6 In the grammar, <item> is the child of the <one-of> tag. It has no attributes and can contain <slot> tags. Each <item> tag contains one phrase that can be used by the system or user to speak about the parent element that it belongs to. This parent element could be an <action> , a <question> , an <answer> , a <report> , or an <individual> . <item> tags can also contain a <vp> tag, which specifies the verb of an expression in different grammatical moods and inflected forms for use in Grammatical Framework to generate grammatical forms. See <vp> for further information. Examples \u00b6 Action example with three types of <item> tags: basic, with <slot>, and with <vp>. \u00b6 <action name= \"set_alarm\" > <one-of> <item> <vp> <infinitive> set </infinitive> <imperative> set </imperative> <ing-form> setting </ing-form> <object> the alarm </object> </vp> </item> <item> set alarm </item> <item> set the alarm to <slot predicate= \"time_to_set\" type= \"individual\" /></item> </one-of> </action>","title":"Item"},{"location":"dialog-domain-description-definition/grammar/children/item/#item","text":"","title":"Item"},{"location":"dialog-domain-description-definition/grammar/children/item/#definition","text":"<item> The grammar entry of items. Each item contains a separate phrase that can be used by the system or the user to speak about the parent element.","title":"Definition"},{"location":"dialog-domain-description-definition/grammar/children/item/#parents","text":"<one-of>","title":"Parents"},{"location":"dialog-domain-description-definition/grammar/children/item/#children","text":"<slot> <vp> <infinitive> <imperative> <ing-form> <object>","title":"Children"},{"location":"dialog-domain-description-definition/grammar/children/item/#behaviour","text":"In the grammar, <item> is the child of the <one-of> tag. It has no attributes and can contain <slot> tags. Each <item> tag contains one phrase that can be used by the system or user to speak about the parent element that it belongs to. This parent element could be an <action> , a <question> , an <answer> , a <report> , or an <individual> . <item> tags can also contain a <vp> tag, which specifies the verb of an expression in different grammatical moods and inflected forms for use in Grammatical Framework to generate grammatical forms. See <vp> for further information.","title":"Behaviour"},{"location":"dialog-domain-description-definition/grammar/children/item/#examples","text":"","title":"Examples"},{"location":"dialog-domain-description-definition/grammar/children/item/#action-example-with-three-types-of-item-tags-basic-with-slot-and-with-vp","text":"<action name= \"set_alarm\" > <one-of> <item> <vp> <infinitive> set </infinitive> <imperative> set </imperative> <ing-form> setting </ing-form> <object> the alarm </object> </vp> </item> <item> set alarm </item> <item> set the alarm to <slot predicate= \"time_to_set\" type= \"individual\" /></item> </one-of> </action>","title":"Action example with three types of &lt;item> tags: basic, with &lt;slot>, and with &lt;vp>."},{"location":"dialog-domain-description-definition/grammar/children/one-of/","text":"One-of \u00b6 Definition \u00b6 <item> The <one-of> grammar entry. Each <one-of> tag contains a set of <item> tags that can be used by the system or the user to speak about the parent element. Parents \u00b6 <action> <question> Children \u00b6 <item> <slot> <vp> <infinitive> <imperative> <ing-form> <object> Behaviour \u00b6 In the grammar, the <one-of> tag is used to provide a number of ways in which the system and the user can speak about actions, questions, answers, reports, and individuals. It is the child of these aforementioned parent elements in the cases where these elements should have more than one possible phrase that can be used to speak about them. It has no attributes. <one-of> tags always contain <item> tags that each contain one phrase that can be used by the system or user to speak about the parent element that it belongs to. This parent element could be an action, a question, an answer, a report, or an individual. Examples \u00b6 Action example with three types of <item> tags: basic, with <slot>, and with <vp>. \u00b6 <action name= \"set_alarm\" > <one-of> <item> <vp> <infinitive> set </infinitive> <imperative> set </imperative> <ing-form> setting </ing-form> <object> the alarm </object> </vp> </item> <item> set alarm </item> <item> set the alarm to <slot predicate= \"time_to_set\" type= \"individual\" /></item> </one-of> </action>","title":"One-of"},{"location":"dialog-domain-description-definition/grammar/children/one-of/#one-of","text":"","title":"One-of"},{"location":"dialog-domain-description-definition/grammar/children/one-of/#definition","text":"<item> The <one-of> grammar entry. Each <one-of> tag contains a set of <item> tags that can be used by the system or the user to speak about the parent element.","title":"Definition"},{"location":"dialog-domain-description-definition/grammar/children/one-of/#parents","text":"<action> <question>","title":"Parents"},{"location":"dialog-domain-description-definition/grammar/children/one-of/#children","text":"<item> <slot> <vp> <infinitive> <imperative> <ing-form> <object>","title":"Children"},{"location":"dialog-domain-description-definition/grammar/children/one-of/#behaviour","text":"In the grammar, the <one-of> tag is used to provide a number of ways in which the system and the user can speak about actions, questions, answers, reports, and individuals. It is the child of these aforementioned parent elements in the cases where these elements should have more than one possible phrase that can be used to speak about them. It has no attributes. <one-of> tags always contain <item> tags that each contain one phrase that can be used by the system or user to speak about the parent element that it belongs to. This parent element could be an action, a question, an answer, a report, or an individual.","title":"Behaviour"},{"location":"dialog-domain-description-definition/grammar/children/one-of/#examples","text":"","title":"Examples"},{"location":"dialog-domain-description-definition/grammar/children/one-of/#action-example-with-three-types-of-item-tags-basic-with-slot-and-with-vp","text":"<action name= \"set_alarm\" > <one-of> <item> <vp> <infinitive> set </infinitive> <imperative> set </imperative> <ing-form> setting </ing-form> <object> the alarm </object> </vp> </item> <item> set alarm </item> <item> set the alarm to <slot predicate= \"time_to_set\" type= \"individual\" /></item> </one-of> </action>","title":"Action example with three types of &lt;item> tags: basic, with &lt;slot>, and with &lt;vp>."},{"location":"dialog-domain-description-definition/grammar/children/slot/","text":"Slot \u00b6 Definition \u00b6 <slot predicate= \"predicate_name\" > The grammar entry of the verb phrase (VP) child of the <item> element. Attributes Type Description predicate string Required. Specifies the name of the predicate from which the slot is filled. Predicate names are written using lowercase separated by underscores, e.g. 'current_temperature'. Parents \u00b6 <answer> <report> <validity> <item> Behaviour \u00b6 The <slot> element in the grammar occurs inside its various parent tags and serves as a slot for data from the given predicate, which the system gets from the predicate's <question> . Parent elements can contain multiple <slot> elements if necessary. The <slot> attribute predicate indicates which predicate that the slot gets its data from. Examples \u00b6 <slot> inside <item> tags: \u00b6 <action name= \"browse_restaurants\" > <one-of> ... <item> i want to browse <slot sort= \"type_food\" /> restaurants </item> <item> browse <slot sort= \"type_food\" /></item> <item> i would like to eat <slot sort= \"type_food\" /></item> <item> i want <slot sort= \"type_food\" /></item> <item> i want to eat <slot sort= \"type_food\" /></item> ... </one-of> </action> Multiple <slot> tags inside an <answer> tag: \u00b6 <answer predicate= \"next_membership_level\" speaker= \"system\" > you need <slot predicate= \"next_membership_points\" type= \"individual\" /> points to reach <slot predicate= \"next_membership_level\" type= \"individual\" /> level </answer> <slot> inside a <report> tag: \u00b6 <report action= \"AddToBasketDairy\" status= \"ended\" > Ok. We will add <slot predicate= \"selected_dairy\" /> to the order. </report> <slot> inside a <validity> tag: \u00b6 <validity name= \"CityValidity\" > invalid parameters <slot predicate= \"dest_city\" type= \"individual\" /></validity>","title":"Slot"},{"location":"dialog-domain-description-definition/grammar/children/slot/#slot","text":"","title":"Slot"},{"location":"dialog-domain-description-definition/grammar/children/slot/#definition","text":"<slot predicate= \"predicate_name\" > The grammar entry of the verb phrase (VP) child of the <item> element. Attributes Type Description predicate string Required. Specifies the name of the predicate from which the slot is filled. Predicate names are written using lowercase separated by underscores, e.g. 'current_temperature'.","title":"Definition"},{"location":"dialog-domain-description-definition/grammar/children/slot/#parents","text":"<answer> <report> <validity> <item>","title":"Parents"},{"location":"dialog-domain-description-definition/grammar/children/slot/#behaviour","text":"The <slot> element in the grammar occurs inside its various parent tags and serves as a slot for data from the given predicate, which the system gets from the predicate's <question> . Parent elements can contain multiple <slot> elements if necessary. The <slot> attribute predicate indicates which predicate that the slot gets its data from.","title":"Behaviour"},{"location":"dialog-domain-description-definition/grammar/children/slot/#examples","text":"","title":"Examples"},{"location":"dialog-domain-description-definition/grammar/children/slot/#slot-inside-item-tags","text":"<action name= \"browse_restaurants\" > <one-of> ... <item> i want to browse <slot sort= \"type_food\" /> restaurants </item> <item> browse <slot sort= \"type_food\" /></item> <item> i would like to eat <slot sort= \"type_food\" /></item> <item> i want <slot sort= \"type_food\" /></item> <item> i want to eat <slot sort= \"type_food\" /></item> ... </one-of> </action>","title":"&lt;slot> inside &lt;item> tags:"},{"location":"dialog-domain-description-definition/grammar/children/slot/#multiple-slot-tags-inside-an-answer-tag","text":"<answer predicate= \"next_membership_level\" speaker= \"system\" > you need <slot predicate= \"next_membership_points\" type= \"individual\" /> points to reach <slot predicate= \"next_membership_level\" type= \"individual\" /> level </answer>","title":"Multiple &lt;slot> tags inside an &lt;answer> tag:"},{"location":"dialog-domain-description-definition/grammar/children/slot/#slot-inside-a-report-tag","text":"<report action= \"AddToBasketDairy\" status= \"ended\" > Ok. We will add <slot predicate= \"selected_dairy\" /> to the order. </report>","title":"&lt;slot> inside a &lt;report> tag:"},{"location":"dialog-domain-description-definition/grammar/children/slot/#slot-inside-a-validity-tag","text":"<validity name= \"CityValidity\" > invalid parameters <slot predicate= \"dest_city\" type= \"individual\" /></validity>","title":"&lt;slot> inside a &lt;validity> tag:"},{"location":"dialog-domain-description-definition/grammar/children/vp/","text":"VP \u00b6 Definition \u00b6 <vp> The grammar entry of the verb phrase (VP) child of the <item> element. Attributes Type Description N/A N/A N/A Parents \u00b6 <item> Children \u00b6 <infinitive> <imperative> <ing-form> <object> Behaviour \u00b6 The <vp> element in the grammar defines the way in which the system can speak about a given <item>. It defines a basic utterance for the <item>'s parent element in three grammatical forms: infinitive, imperative, and ing-form to be used by the NLG in generating expressions, such as for grounding. Children \u00b6 <infinitive\\> \u00b6 Contains the infinitive form of the verb used in the <vp>, e.g. \"make\" from the sentence \"make a reservation\". <imperative\\> \u00b6 Contains the imperative form of the verb used in the <vp>, e.g. \"make\" from the sentence \"make a reservation\". <ing-form\\> \u00b6 Contains the ing-form (gerund) form of the verb used in the <vp>, e.g. \"making\" from the sentence \"making a reservation\". <object\\> \u00b6 Contains the object of the sentence in the <vp>, e.g. \"a reservation\" from the sentence \"make/making a reservation\". Examples \u00b6 <action name= \"make_reservation\" > <one-of> <item> <vp> <infinitive> make </infinitive> <imperative> make </imperative> <ing-form> making </ing-form> <object> a reservation </object> </vp> </item> <item> ... </item> </one-of> </action>","title":"VP"},{"location":"dialog-domain-description-definition/grammar/children/vp/#vp","text":"","title":"VP"},{"location":"dialog-domain-description-definition/grammar/children/vp/#definition","text":"<vp> The grammar entry of the verb phrase (VP) child of the <item> element. Attributes Type Description N/A N/A N/A","title":"Definition"},{"location":"dialog-domain-description-definition/grammar/children/vp/#parents","text":"<item>","title":"Parents"},{"location":"dialog-domain-description-definition/grammar/children/vp/#children","text":"<infinitive> <imperative> <ing-form> <object>","title":"Children"},{"location":"dialog-domain-description-definition/grammar/children/vp/#behaviour","text":"The <vp> element in the grammar defines the way in which the system can speak about a given <item>. It defines a basic utterance for the <item>'s parent element in three grammatical forms: infinitive, imperative, and ing-form to be used by the NLG in generating expressions, such as for grounding.","title":"Behaviour"},{"location":"dialog-domain-description-definition/grammar/children/vp/#children_1","text":"","title":"Children"},{"location":"dialog-domain-description-definition/grammar/children/vp/#infinitive","text":"Contains the infinitive form of the verb used in the <vp>, e.g. \"make\" from the sentence \"make a reservation\".","title":"&lt;infinitive\\&gt;"},{"location":"dialog-domain-description-definition/grammar/children/vp/#imperative","text":"Contains the imperative form of the verb used in the <vp>, e.g. \"make\" from the sentence \"make a reservation\".","title":"&lt;imperative\\&gt;"},{"location":"dialog-domain-description-definition/grammar/children/vp/#ing-form","text":"Contains the ing-form (gerund) form of the verb used in the <vp>, e.g. \"making\" from the sentence \"making a reservation\".","title":"&lt;ing-form\\&gt;"},{"location":"dialog-domain-description-definition/grammar/children/vp/#object","text":"Contains the object of the sentence in the <vp>, e.g. \"a reservation\" from the sentence \"make/making a reservation\".","title":"&lt;object\\&gt;"},{"location":"dialog-domain-description-definition/grammar/children/vp/#examples","text":"<action name= \"make_reservation\" > <one-of> <item> <vp> <infinitive> make </infinitive> <imperative> make </imperative> <ing-form> making </ing-form> <object> a reservation </object> </vp> </item> <item> ... </item> </one-of> </action>","title":"Examples"},{"location":"dialog-domain-description-definition/grammar/elements/action/","text":"Action \u00b6 Definition \u00b6 <action name= \"action_name\" > The grammar entry of an action. Defines how the system and the user can speak about and request actions. Attribute Type Description name string Required. Should match the name of the corresponding action in ontology. The action names in elements are written using lowercase separated by underscores, e.g. 'set_temperature'. Children \u00b6 <one-of> <item> <slot> <vp> <infinitive> <imperative> <ing-form> <object> Behaviour \u00b6 The <action> element in the grammar defines the way in which the system and users can speak about a given action. The attribute name indicates which action in the ontology the grammar entry is for. An action entry in the grammar should cover the different ways a user could speak about the action, such as different expressions and word choices. These options are given using the <one-of> tag, where each alternative expression is an <item> . <item> tags can contain <vp> or <slot> tags. Examples \u00b6 Action entry for setting an alarm with three different expressions: \u00b6 <action name= \"set_alarm\" > <one-of> <item> set the alarm </item> <item> set alarm </item> <item> alarm </item> </one-of> </action> Action entry containing expression with <slot> tag: \u00b6 <action name= \"set_alarm\" > <one-of> <item> set the alarm </item> <item> set alarm </item> <item> set the alarm to <slot predicate= \"time_to_set\" type= \"individual\" /></item> </one-of> </action> Action entry containing expression with <vp> tag: \u00b6 <action name= \"set_alarm\" > <one-of> <item> <vp> <infinitive> set </infinitive> <imperative> set </imperative> <ing-form> setting </ing-form> <object> the alarm </object> </vp> </item> <item> set alarm </item> <item> set the alarm to <slot predicate= \"time_to_set\" type= \"individual\" /></item> </one-of> </action>","title":"Action"},{"location":"dialog-domain-description-definition/grammar/elements/action/#action","text":"","title":"Action"},{"location":"dialog-domain-description-definition/grammar/elements/action/#definition","text":"<action name= \"action_name\" > The grammar entry of an action. Defines how the system and the user can speak about and request actions. Attribute Type Description name string Required. Should match the name of the corresponding action in ontology. The action names in elements are written using lowercase separated by underscores, e.g. 'set_temperature'.","title":"Definition"},{"location":"dialog-domain-description-definition/grammar/elements/action/#children","text":"<one-of> <item> <slot> <vp> <infinitive> <imperative> <ing-form> <object>","title":"Children"},{"location":"dialog-domain-description-definition/grammar/elements/action/#behaviour","text":"The <action> element in the grammar defines the way in which the system and users can speak about a given action. The attribute name indicates which action in the ontology the grammar entry is for. An action entry in the grammar should cover the different ways a user could speak about the action, such as different expressions and word choices. These options are given using the <one-of> tag, where each alternative expression is an <item> . <item> tags can contain <vp> or <slot> tags.","title":"Behaviour"},{"location":"dialog-domain-description-definition/grammar/elements/action/#examples","text":"","title":"Examples"},{"location":"dialog-domain-description-definition/grammar/elements/action/#action-entry-for-setting-an-alarm-with-three-different-expressions","text":"<action name= \"set_alarm\" > <one-of> <item> set the alarm </item> <item> set alarm </item> <item> alarm </item> </one-of> </action>","title":"Action entry for setting an alarm with three different expressions:"},{"location":"dialog-domain-description-definition/grammar/elements/action/#action-entry-containing-expression-with-slot-tag","text":"<action name= \"set_alarm\" > <one-of> <item> set the alarm </item> <item> set alarm </item> <item> set the alarm to <slot predicate= \"time_to_set\" type= \"individual\" /></item> </one-of> </action>","title":"Action entry containing expression with &lt;slot> tag:"},{"location":"dialog-domain-description-definition/grammar/elements/action/#action-entry-containing-expression-with-vp-tag","text":"<action name= \"set_alarm\" > <one-of> <item> <vp> <infinitive> set </infinitive> <imperative> set </imperative> <ing-form> setting </ing-form> <object> the alarm </object> </vp> </item> <item> set alarm </item> <item> set the alarm to <slot predicate= \"time_to_set\" type= \"individual\" /></item> </one-of> </action>","title":"Action entry containing expression with &lt;vp> tag:"},{"location":"dialog-domain-description-definition/grammar/elements/answer/","text":"Answer \u00b6 Definition \u00b6 <answer speaker= \"speaker\" predicate= \"predicate_name\" polarity= \"polarity\" > The grammar entry of an answer given by the system or the user. Attributes Type Description speaker string Required. Specifies the speaker of the utterance. Available options: system user predicate string Optional. Specifies the name of the predicate to which the grammar entry refers. Predicate names are written using lowercase separated by underscores, e.g. 'current_temperature'. polarity string Optional. Specifies whether an answer has positive or negative polarity. Available options: positive negative Children \u00b6 <one-of> <item> <slot> Behaviour \u00b6 The <answer> element in the grammar defines the way in which the system and users can give answers to questions. The attribute polarity specifies whether the answer is positive or negative, the attribute predicate indicates which predicate in the ontology the grammar entry is for, and the attribute speaker specifies the speaker of the answer. An answer entry in the grammar should cover the different ways in which the system and users can answer questions, such as different expressions and word choices. These options are given using the <one-of> tag, where each alternative expression is an <item> , which in turn can contain <slot> tags. System answers can make use of the attribute polarity in situations where a question could have different answers depending on whether the answer is positive or negative. An example of this is the possible answers to the question \"Are there rooms available?\" from a user wanting to book a hotel room. polarity attribute choices: \u00b6 Positive \u00b6 Indicates that an answer about a particular predicate is of positive polarity, e.g. if the user asks whether they are qualified for membership and the answer is \"Yes, you have 50 points and are qualified for membership\". If there is a positive polarity answer for a predicate, there is typically a negative polarity answer present in the grammar as well. Negative \u00b6 Indicates that an answer about a particular predicate is of negative polarity, e.g. if the user asks whether they are qualified for membership and the answer is \"No, you need 20 points to be qualified for membership\". speaker attribute choices: \u00b6 User \u00b6 Indicates that the <answer> element contains possible answers that the user can give the system in response to a system question prompted by a <findout> in domain.xml . System \u00b6 Indicates that the <answer> element contains phrases used by the system to give an answer about the predicate specified. It is prompted by a <invoke_service_query> in domain.xml . Examples \u00b6 User \u00b6 This user <answer> entry contains the ways in which a user can answer certain questions in a travel booking DDD, specifically how many passengers of a certain type to add, and the destination city that the user wants to travel to. <answer speaker= \"user\" > <one-of> <item><slot predicate= \"passenger_quantity_to_add\" type= \"individual\" /> <slot sort= \"passenger_type\" /></item> <item> to <slot predicate= \"dest_city\" /></item> </one-of> </answer> System \u00b6 This system <answer> entry contains the phrase the system would use to answer a question from the user about the next membership level and its requirements. <answer predicate= \"next_membership_level\" speaker= \"system\" > you need <slot predicate= \"next_membership_points\" type= \"individual\" /> points to reach <slot predicate= \"next_membership_level\" type= \"individual\" /> level </answer> The following <answer> entries show an example of a positive and a negative polarity answer from the system to a user question concerning the availability of rooms for booking in a hotel. <answer polarity= \"positive\" predicate= \"rooms_available\" speaker= \"system\" > There are rooms available </answer> <answer polarity= \"negative\" predicate= \"rooms_available\" speaker= \"system\" > Unfortunately, there are no rooms available to book at this time </answer>","title":"Answer"},{"location":"dialog-domain-description-definition/grammar/elements/answer/#answer","text":"","title":"Answer"},{"location":"dialog-domain-description-definition/grammar/elements/answer/#definition","text":"<answer speaker= \"speaker\" predicate= \"predicate_name\" polarity= \"polarity\" > The grammar entry of an answer given by the system or the user. Attributes Type Description speaker string Required. Specifies the speaker of the utterance. Available options: system user predicate string Optional. Specifies the name of the predicate to which the grammar entry refers. Predicate names are written using lowercase separated by underscores, e.g. 'current_temperature'. polarity string Optional. Specifies whether an answer has positive or negative polarity. Available options: positive negative","title":"Definition"},{"location":"dialog-domain-description-definition/grammar/elements/answer/#children","text":"<one-of> <item> <slot>","title":"Children"},{"location":"dialog-domain-description-definition/grammar/elements/answer/#behaviour","text":"The <answer> element in the grammar defines the way in which the system and users can give answers to questions. The attribute polarity specifies whether the answer is positive or negative, the attribute predicate indicates which predicate in the ontology the grammar entry is for, and the attribute speaker specifies the speaker of the answer. An answer entry in the grammar should cover the different ways in which the system and users can answer questions, such as different expressions and word choices. These options are given using the <one-of> tag, where each alternative expression is an <item> , which in turn can contain <slot> tags. System answers can make use of the attribute polarity in situations where a question could have different answers depending on whether the answer is positive or negative. An example of this is the possible answers to the question \"Are there rooms available?\" from a user wanting to book a hotel room.","title":"Behaviour"},{"location":"dialog-domain-description-definition/grammar/elements/answer/#polarity-attribute-choices","text":"","title":"polarity attribute choices:"},{"location":"dialog-domain-description-definition/grammar/elements/answer/#positive","text":"Indicates that an answer about a particular predicate is of positive polarity, e.g. if the user asks whether they are qualified for membership and the answer is \"Yes, you have 50 points and are qualified for membership\". If there is a positive polarity answer for a predicate, there is typically a negative polarity answer present in the grammar as well.","title":"Positive"},{"location":"dialog-domain-description-definition/grammar/elements/answer/#negative","text":"Indicates that an answer about a particular predicate is of negative polarity, e.g. if the user asks whether they are qualified for membership and the answer is \"No, you need 20 points to be qualified for membership\".","title":"Negative"},{"location":"dialog-domain-description-definition/grammar/elements/answer/#speaker-attribute-choices","text":"","title":"speaker attribute choices:"},{"location":"dialog-domain-description-definition/grammar/elements/answer/#user","text":"Indicates that the <answer> element contains possible answers that the user can give the system in response to a system question prompted by a <findout> in domain.xml .","title":"User"},{"location":"dialog-domain-description-definition/grammar/elements/answer/#system","text":"Indicates that the <answer> element contains phrases used by the system to give an answer about the predicate specified. It is prompted by a <invoke_service_query> in domain.xml .","title":"System"},{"location":"dialog-domain-description-definition/grammar/elements/answer/#examples","text":"","title":"Examples"},{"location":"dialog-domain-description-definition/grammar/elements/answer/#user_1","text":"This user <answer> entry contains the ways in which a user can answer certain questions in a travel booking DDD, specifically how many passengers of a certain type to add, and the destination city that the user wants to travel to. <answer speaker= \"user\" > <one-of> <item><slot predicate= \"passenger_quantity_to_add\" type= \"individual\" /> <slot sort= \"passenger_type\" /></item> <item> to <slot predicate= \"dest_city\" /></item> </one-of> </answer>","title":"User"},{"location":"dialog-domain-description-definition/grammar/elements/answer/#system_1","text":"This system <answer> entry contains the phrase the system would use to answer a question from the user about the next membership level and its requirements. <answer predicate= \"next_membership_level\" speaker= \"system\" > you need <slot predicate= \"next_membership_points\" type= \"individual\" /> points to reach <slot predicate= \"next_membership_level\" type= \"individual\" /> level </answer> The following <answer> entries show an example of a positive and a negative polarity answer from the system to a user question concerning the availability of rooms for booking in a hotel. <answer polarity= \"positive\" predicate= \"rooms_available\" speaker= \"system\" > There are rooms available </answer> <answer polarity= \"negative\" predicate= \"rooms_available\" speaker= \"system\" > Unfortunately, there are no rooms available to book at this time </answer>","title":"System"},{"location":"dialog-domain-description-definition/grammar/elements/greeting/","text":"Greeting \u00b6 Definition \u00b6 <greeting> The grammar entry of the system greeting. Defines in what way the system will greet the user. Behaviour \u00b6 The <greeting> element in the grammar defines the way in which the system greets the user. This grammar entry should only exist once in a DDD and should contain the phrase the system should use when greeting the user at the beginning of the interaction. Examples \u00b6 <greeting> Welcome to the Travel Agency! </greeting>","title":"Greeting"},{"location":"dialog-domain-description-definition/grammar/elements/greeting/#greeting","text":"","title":"Greeting"},{"location":"dialog-domain-description-definition/grammar/elements/greeting/#definition","text":"<greeting> The grammar entry of the system greeting. Defines in what way the system will greet the user.","title":"Definition"},{"location":"dialog-domain-description-definition/grammar/elements/greeting/#behaviour","text":"The <greeting> element in the grammar defines the way in which the system greets the user. This grammar entry should only exist once in a DDD and should contain the phrase the system should use when greeting the user at the beginning of the interaction.","title":"Behaviour"},{"location":"dialog-domain-description-definition/grammar/elements/greeting/#examples","text":"<greeting> Welcome to the Travel Agency! </greeting>","title":"Examples"},{"location":"dialog-domain-description-definition/grammar/elements/individual/","text":"Individual \u00b6 Definition \u00b6 <individual name= \"individual_name\" > The grammar entry of an individual. Defines how the system and the user can speak about individuals. Attribute Type Description name string Required. Should match the name of the corresponding individual in ontology. The individual names in elements are written using lowercase separated by underscores, e.g. 'set_temperature'. Children \u00b6 <one-of> <item> Behaviour \u00b6 The <individual> element in the grammar defines the way in which the system and users can speak about a given individual. The attribute name indicates which individual in the ontology the grammar entry is for. Individuals are typically nouns or names of e.g. places, people, etc. An individual entry in the grammar should contain at least one phrase which can be used to refer to the individual in question. It is also possible to specify multiple ways of referring to the same individual. Multiple options, when used, are given using the <one-of> tag, where each alternative expression is an <item> . Examples \u00b6 Basic individual entry. \u00b6 <individual name= \"london\" > London </individual> Individual entry with <one-of> and <item> . \u00b6 <individual name= \"united_kingdom\" > <one-of> <item> The UK </item> <item> United Kingdom </item> <item> Great Britain </item> </one-of> </individual>","title":"Individual"},{"location":"dialog-domain-description-definition/grammar/elements/individual/#individual","text":"","title":"Individual"},{"location":"dialog-domain-description-definition/grammar/elements/individual/#definition","text":"<individual name= \"individual_name\" > The grammar entry of an individual. Defines how the system and the user can speak about individuals. Attribute Type Description name string Required. Should match the name of the corresponding individual in ontology. The individual names in elements are written using lowercase separated by underscores, e.g. 'set_temperature'.","title":"Definition"},{"location":"dialog-domain-description-definition/grammar/elements/individual/#children","text":"<one-of> <item>","title":"Children"},{"location":"dialog-domain-description-definition/grammar/elements/individual/#behaviour","text":"The <individual> element in the grammar defines the way in which the system and users can speak about a given individual. The attribute name indicates which individual in the ontology the grammar entry is for. Individuals are typically nouns or names of e.g. places, people, etc. An individual entry in the grammar should contain at least one phrase which can be used to refer to the individual in question. It is also possible to specify multiple ways of referring to the same individual. Multiple options, when used, are given using the <one-of> tag, where each alternative expression is an <item> .","title":"Behaviour"},{"location":"dialog-domain-description-definition/grammar/elements/individual/#examples","text":"","title":"Examples"},{"location":"dialog-domain-description-definition/grammar/elements/individual/#basic-individual-entry","text":"<individual name= \"london\" > London </individual>","title":"Basic individual entry."},{"location":"dialog-domain-description-definition/grammar/elements/individual/#individual-entry-with-one-of-and-item","text":"<individual name= \"united_kingdom\" > <one-of> <item> The UK </item> <item> United Kingdom </item> <item> Great Britain </item> </one-of> </individual>","title":"Individual entry with &lt;one-of> and &lt;item>."},{"location":"dialog-domain-description-definition/grammar/elements/preconfirm/","text":"Preconfirm \u00b6 Definition \u00b6 <preconfirm action= \"ActionName\" > The grammar entry of preconfirmations for actions. Defines how the system can ask the user for confirmation about performing an action. Attributes Type Description action string Required. Specifies which action the preconfirmation is for. This name should match the corresponding action name in service_interface. The action names in <preconfirm> tags are written according to the PascalCase convention, e.g. 'SetTemperature'. Children \u00b6 <slot> Behaviour \u00b6 The <preconfirm> element in the grammar ... The attribute action specifies the action for which this entry makes preconfirmation possible. A preconfirm entry in the grammar has one phrase which the system uses to preconfirm with the user whether an action should be performed. Said phrase can contain <slot> tags. Examples \u00b6 <preconfirm action= \"RemoveAlarm\" > remove the alarm </preconfirm> <preconfirm action= \"BookHousing\" > book this hotel </preconfirm>","title":"Preconfirm"},{"location":"dialog-domain-description-definition/grammar/elements/preconfirm/#preconfirm","text":"","title":"Preconfirm"},{"location":"dialog-domain-description-definition/grammar/elements/preconfirm/#definition","text":"<preconfirm action= \"ActionName\" > The grammar entry of preconfirmations for actions. Defines how the system can ask the user for confirmation about performing an action. Attributes Type Description action string Required. Specifies which action the preconfirmation is for. This name should match the corresponding action name in service_interface. The action names in <preconfirm> tags are written according to the PascalCase convention, e.g. 'SetTemperature'.","title":"Definition"},{"location":"dialog-domain-description-definition/grammar/elements/preconfirm/#children","text":"<slot>","title":"Children"},{"location":"dialog-domain-description-definition/grammar/elements/preconfirm/#behaviour","text":"The <preconfirm> element in the grammar ... The attribute action specifies the action for which this entry makes preconfirmation possible. A preconfirm entry in the grammar has one phrase which the system uses to preconfirm with the user whether an action should be performed. Said phrase can contain <slot> tags.","title":"Behaviour"},{"location":"dialog-domain-description-definition/grammar/elements/preconfirm/#examples","text":"<preconfirm action= \"RemoveAlarm\" > remove the alarm </preconfirm> <preconfirm action= \"BookHousing\" > book this hotel </preconfirm>","title":"Examples"},{"location":"dialog-domain-description-definition/grammar/elements/question/","text":"Question \u00b6 Definition \u00b6 <question speaker= \"speaker\" predicate= \"predicate_name\" type= \"type\" > The grammar entry of a question asked by the system or the user. Attributes Type Description speaker string Required. Specifies the speaker of the utterance. Available options: system user all predicate string Required. Specifies the name of the predicate to which the grammar entry refers. Predicate names are written using lowercase separated by underscores, e.g. 'current_temperature'. type string Required only when speaker is system. Specifies which type of question is asked by the system. Available options: wh_question Children \u00b6 <one-of> <item> <slot> <vp> <infinitive> <imperative> <ing-form> <object> Behaviour \u00b6 The <question> element in the grammar defines the way in which the system and users can speak about a given question. The attribute predicate indicates which predicate in the ontology that the grammar entry is for, the attribute speaker specifies the speaker of the question, and the attribute type specifies the type of question when speaker is set to system . speaker attribute choices: \u00b6 User \u00b6 Indicates that the <question> element contains possible questions that the user can ask the system in order to resolve a <goal> in domain.xml . System \u00b6 Indicates that the <question> element contains a phrase used by the system to ask about the predicate specified. It is prompted by a <findout> in domain.xml . All \u00b6 Indicates that the <question> element contains a phrase used by both system and user in questions. Regardless of who is speaking, when asking or talking about a question of the specified predicate , they can use this phrase. type attribute choices: \u00b6 Wh-question \u00b6 Type of question that starts with or contains wh-words such as 'what', 'when', 'which', 'who', etc.. Examples \u00b6 User \u00b6 The user can ask for a phone number as following. <question speaker= \"user\" predicate= \"phone_number_of_contact\" > <one-of> <item> tell me a phone number </item> <item> what is <slot predicate= \"selected_contact\" type= \"individual\" /> 's number </item> <item> tell me <slot predicate= \"selected_contact\" type= \"individual\" /> 's number </item> </one-of> </question> System \u00b6 The system can ask for the name of the individual if the user has not specified it in the question above. <question speaker= \"system\" predicate= \"selected_contact\" type= \"wh_question\" > whose number </question> All \u00b6 Both the user and the system can use this phrase to ask about a phone number. For example, to ask for a phone number, the user can say \"What is the phone number?\". When returning to discussing this question after talking about something else, the system can say \"Returning to the phone number\". <question speaker= \"all\" predicate= \"selected_contact\" > the phone number </question>","title":"Question"},{"location":"dialog-domain-description-definition/grammar/elements/question/#question","text":"","title":"Question"},{"location":"dialog-domain-description-definition/grammar/elements/question/#definition","text":"<question speaker= \"speaker\" predicate= \"predicate_name\" type= \"type\" > The grammar entry of a question asked by the system or the user. Attributes Type Description speaker string Required. Specifies the speaker of the utterance. Available options: system user all predicate string Required. Specifies the name of the predicate to which the grammar entry refers. Predicate names are written using lowercase separated by underscores, e.g. 'current_temperature'. type string Required only when speaker is system. Specifies which type of question is asked by the system. Available options: wh_question","title":"Definition"},{"location":"dialog-domain-description-definition/grammar/elements/question/#children","text":"<one-of> <item> <slot> <vp> <infinitive> <imperative> <ing-form> <object>","title":"Children"},{"location":"dialog-domain-description-definition/grammar/elements/question/#behaviour","text":"The <question> element in the grammar defines the way in which the system and users can speak about a given question. The attribute predicate indicates which predicate in the ontology that the grammar entry is for, the attribute speaker specifies the speaker of the question, and the attribute type specifies the type of question when speaker is set to system .","title":"Behaviour"},{"location":"dialog-domain-description-definition/grammar/elements/question/#speaker-attribute-choices","text":"","title":"speaker attribute choices:"},{"location":"dialog-domain-description-definition/grammar/elements/question/#user","text":"Indicates that the <question> element contains possible questions that the user can ask the system in order to resolve a <goal> in domain.xml .","title":"User"},{"location":"dialog-domain-description-definition/grammar/elements/question/#system","text":"Indicates that the <question> element contains a phrase used by the system to ask about the predicate specified. It is prompted by a <findout> in domain.xml .","title":"System"},{"location":"dialog-domain-description-definition/grammar/elements/question/#all","text":"Indicates that the <question> element contains a phrase used by both system and user in questions. Regardless of who is speaking, when asking or talking about a question of the specified predicate , they can use this phrase.","title":"All"},{"location":"dialog-domain-description-definition/grammar/elements/question/#type-attribute-choices","text":"","title":"type attribute choices:"},{"location":"dialog-domain-description-definition/grammar/elements/question/#wh-question","text":"Type of question that starts with or contains wh-words such as 'what', 'when', 'which', 'who', etc..","title":"Wh-question"},{"location":"dialog-domain-description-definition/grammar/elements/question/#examples","text":"","title":"Examples"},{"location":"dialog-domain-description-definition/grammar/elements/question/#user_1","text":"The user can ask for a phone number as following. <question speaker= \"user\" predicate= \"phone_number_of_contact\" > <one-of> <item> tell me a phone number </item> <item> what is <slot predicate= \"selected_contact\" type= \"individual\" /> 's number </item> <item> tell me <slot predicate= \"selected_contact\" type= \"individual\" /> 's number </item> </one-of> </question>","title":"User"},{"location":"dialog-domain-description-definition/grammar/elements/question/#system_1","text":"The system can ask for the name of the individual if the user has not specified it in the question above. <question speaker= \"system\" predicate= \"selected_contact\" type= \"wh_question\" > whose number </question>","title":"System"},{"location":"dialog-domain-description-definition/grammar/elements/question/#all_1","text":"Both the user and the system can use this phrase to ask about a phone number. For example, to ask for a phone number, the user can say \"What is the phone number?\". When returning to discussing this question after talking about something else, the system can say \"Returning to the phone number\". <question speaker= \"all\" predicate= \"selected_contact\" > the phone number </question>","title":"All"},{"location":"dialog-domain-description-definition/grammar/elements/report/","text":"Report \u00b6 Definition \u00b6 <report action= \"ActionName\" status= \"status\" > The grammar entry of a report given by the system. Attributes Type Description action string Required. Specifies the name of the action the report entry is for. This name should match the corresponding action name in service_interface. The action names in <report> tags are written according to the PascalCase convention, e.g. 'SetTemperature'. status string Required. Specifies the status of the action the report entry is for. Available options: started ended failed reason string Optional, used together with status=\"failed\". Specifies the reason for the failure to perform an action. Children \u00b6 <one-of selection=\"...\"> <item> <slot> Behaviour \u00b6 The <report> element in the grammar defines the way in which the system makes reports about actions before or after performing them. The attribute action specifies which action the report is for, and the attribute status specifies the outcome of the performed action. A report action can contain one of more phrases which are used by the system to report the result of the report's specified action. These phrases can also contain <slot> tags. When a <report> element contains multiple phrases, these are specified in <item> tags inside a <one-of> tag. In the case of <report>, these <one-of> tags have an attribute called 'selection' which specifies the order in which the contained items are used. Reports can make use of the attribute reason in situations where the system reports on an action failure that could be due to multiple different reasons. An example of this is a situation where the action \"CancelReservation\" fails as the user is trying to cancel their booking of a hotel room. The reasons could for instance be that the user has no booked hotel room to cancel, or that the user is trying to cancel the reservation less than 24 hours before when this is not allowed. status attribute choices: \u00b6 Started \u00b6 Indicates that the report's specified action has been initialized. The report phrase should inform the user about this. Ended \u00b6 Indicates that the report's specified action was successfully completed and has been finalized. The report phrase should inform the user about this. Failed \u00b6 Indicates that the report's specified action was failed and was not completed. The report phrase should inform the user about the action failure and the reasons for said failure. Examples \u00b6 Started \u00b6 This <report> entry contains the phrase the system would use to report to the user that it has started the process of cancelling a booking. In this case, the system lets the user know that it is looking for reservations to cancel. <report action= \"CancelReservation\" status= \"started\" > checking for reservations. </report> Ended \u00b6 This <report> entry contains the phrase the system would use to report to the user that it has successfully cancelled the user's hotel room reservation. <report action= \"CancelReservation\" status= \"ended\" > your reservation has been cancelled. </report> Failed \u00b6 The following <report> entries show two examples of reports for cases where the system failed to perform the cancellation of the user's hotel room reservation. The two examples have different reasons for failure, the first being that the user has no booked hotel room to cancel and the second being that the user is trying to cancel a reservation less than 24 hours before the booking begins, when this is not allowed. <report action= \"CancelReservation\" status= \"failed\" reason= \"no_reservation_exists\" > there is no reservation to cancel. </report> <report action= \"CancelReservation\" status= \"failed\" reason= \"too_late_to_cancel\" > you cannot cancel your reservation less than 24 hours before your booking begins. </report> With <one-of> \u00b6 This <report> entry shows an example of a report with multiple phrases that the system can use. In this case, the report is the result of the user asking the system to tell a joke. <report action= \"Jokes\" status= \"ended\" > <one-of selection= \"cyclic\" > <item> Why don't teddy bears ever order dessert? Because they're always stuffed </item> <item> What's the difference between snowmen and snow-women? Snowballs </item> <item> Why can't you trust an atom? Because they make up literally everything </item> <item> Why did the robot cross the road? It was programmed to be a chicken </item> <item> Why did the robot go to the shopping mall? It had hardware and software, but it needed underware </item> </one-of> </report>","title":"Report"},{"location":"dialog-domain-description-definition/grammar/elements/report/#report","text":"","title":"Report"},{"location":"dialog-domain-description-definition/grammar/elements/report/#definition","text":"<report action= \"ActionName\" status= \"status\" > The grammar entry of a report given by the system. Attributes Type Description action string Required. Specifies the name of the action the report entry is for. This name should match the corresponding action name in service_interface. The action names in <report> tags are written according to the PascalCase convention, e.g. 'SetTemperature'. status string Required. Specifies the status of the action the report entry is for. Available options: started ended failed reason string Optional, used together with status=\"failed\". Specifies the reason for the failure to perform an action.","title":"Definition"},{"location":"dialog-domain-description-definition/grammar/elements/report/#children","text":"<one-of selection=\"...\"> <item> <slot>","title":"Children"},{"location":"dialog-domain-description-definition/grammar/elements/report/#behaviour","text":"The <report> element in the grammar defines the way in which the system makes reports about actions before or after performing them. The attribute action specifies which action the report is for, and the attribute status specifies the outcome of the performed action. A report action can contain one of more phrases which are used by the system to report the result of the report's specified action. These phrases can also contain <slot> tags. When a <report> element contains multiple phrases, these are specified in <item> tags inside a <one-of> tag. In the case of <report>, these <one-of> tags have an attribute called 'selection' which specifies the order in which the contained items are used. Reports can make use of the attribute reason in situations where the system reports on an action failure that could be due to multiple different reasons. An example of this is a situation where the action \"CancelReservation\" fails as the user is trying to cancel their booking of a hotel room. The reasons could for instance be that the user has no booked hotel room to cancel, or that the user is trying to cancel the reservation less than 24 hours before when this is not allowed.","title":"Behaviour"},{"location":"dialog-domain-description-definition/grammar/elements/report/#status-attribute-choices","text":"","title":"status attribute choices:"},{"location":"dialog-domain-description-definition/grammar/elements/report/#started","text":"Indicates that the report's specified action has been initialized. The report phrase should inform the user about this.","title":"Started"},{"location":"dialog-domain-description-definition/grammar/elements/report/#ended","text":"Indicates that the report's specified action was successfully completed and has been finalized. The report phrase should inform the user about this.","title":"Ended"},{"location":"dialog-domain-description-definition/grammar/elements/report/#failed","text":"Indicates that the report's specified action was failed and was not completed. The report phrase should inform the user about the action failure and the reasons for said failure.","title":"Failed"},{"location":"dialog-domain-description-definition/grammar/elements/report/#examples","text":"","title":"Examples"},{"location":"dialog-domain-description-definition/grammar/elements/report/#started_1","text":"This <report> entry contains the phrase the system would use to report to the user that it has started the process of cancelling a booking. In this case, the system lets the user know that it is looking for reservations to cancel. <report action= \"CancelReservation\" status= \"started\" > checking for reservations. </report>","title":"Started"},{"location":"dialog-domain-description-definition/grammar/elements/report/#ended_1","text":"This <report> entry contains the phrase the system would use to report to the user that it has successfully cancelled the user's hotel room reservation. <report action= \"CancelReservation\" status= \"ended\" > your reservation has been cancelled. </report>","title":"Ended"},{"location":"dialog-domain-description-definition/grammar/elements/report/#failed_1","text":"The following <report> entries show two examples of reports for cases where the system failed to perform the cancellation of the user's hotel room reservation. The two examples have different reasons for failure, the first being that the user has no booked hotel room to cancel and the second being that the user is trying to cancel a reservation less than 24 hours before the booking begins, when this is not allowed. <report action= \"CancelReservation\" status= \"failed\" reason= \"no_reservation_exists\" > there is no reservation to cancel. </report> <report action= \"CancelReservation\" status= \"failed\" reason= \"too_late_to_cancel\" > you cannot cancel your reservation less than 24 hours before your booking begins. </report>","title":"Failed"},{"location":"dialog-domain-description-definition/grammar/elements/report/#with-one-of","text":"This <report> entry shows an example of a report with multiple phrases that the system can use. In this case, the report is the result of the user asking the system to tell a joke. <report action= \"Jokes\" status= \"ended\" > <one-of selection= \"cyclic\" > <item> Why don't teddy bears ever order dessert? Because they're always stuffed </item> <item> What's the difference between snowmen and snow-women? Snowballs </item> <item> Why can't you trust an atom? Because they make up literally everything </item> <item> Why did the robot cross the road? It was programmed to be a chicken </item> <item> Why did the robot go to the shopping mall? It had hardware and software, but it needed underware </item> </one-of> </report>","title":"With &lt;one-of>"},{"location":"dialog-domain-description-definition/grammar/elements/validity/","text":"Validity \u00b6 Definition \u00b6 <validity name= \"ValidityName\" > The grammar entry specifying how the system reports to the user that one or more of their given parameters are invalid. . Attributes Type Description name string Required. Specifies the name of the Validity, which should match the corresponding validator in service_interface. The validity names in <validity> tags are written according to the PascalCase convention, e.g. 'SetTemperature'. Children \u00b6 <slot> Behaviour \u00b6 The <validity> element in the grammar defines the way in which the system informs users about the parameters they have given being invalid. The attribute name specifies the name of the validator and needs to match the name of the corresponding validator in service_interface. A validity entry in the grammar contains one phrase which the system can use to inform the user of invalid parameters. This phrase can contain <slot> tags. Examples \u00b6 <validity name= \"HourValidity\" > cannot set the hour to <slot predicate= \"hour_to_set\" /> . </validity> <validity name= \"MinuteValidity\" > cannot set the minute to <slot predicate= \"minute_to_set\" /> . </validity>","title":"Validity"},{"location":"dialog-domain-description-definition/grammar/elements/validity/#validity","text":"","title":"Validity"},{"location":"dialog-domain-description-definition/grammar/elements/validity/#definition","text":"<validity name= \"ValidityName\" > The grammar entry specifying how the system reports to the user that one or more of their given parameters are invalid. . Attributes Type Description name string Required. Specifies the name of the Validity, which should match the corresponding validator in service_interface. The validity names in <validity> tags are written according to the PascalCase convention, e.g. 'SetTemperature'.","title":"Definition"},{"location":"dialog-domain-description-definition/grammar/elements/validity/#children","text":"<slot>","title":"Children"},{"location":"dialog-domain-description-definition/grammar/elements/validity/#behaviour","text":"The <validity> element in the grammar defines the way in which the system informs users about the parameters they have given being invalid. The attribute name specifies the name of the validator and needs to match the name of the corresponding validator in service_interface. A validity entry in the grammar contains one phrase which the system can use to inform the user of invalid parameters. This phrase can contain <slot> tags.","title":"Behaviour"},{"location":"dialog-domain-description-definition/grammar/elements/validity/#examples","text":"<validity name= \"HourValidity\" > cannot set the hour to <slot predicate= \"hour_to_set\" /> . </validity> <validity name= \"MinuteValidity\" > cannot set the minute to <slot predicate= \"minute_to_set\" /> . </validity>","title":"Examples"},{"location":"dialog-domain-description-definition/ontology/ontology/","text":"Ontology \u00b6 Definition \u00b6 <ontology name= \"n\" > ... </ontology> An ontology is an inventory of the things one can talk about in an application, consisting of (semantic) sorts, individuals, predicates and actions. Attribute Type Description name string Required. The name of the ontology. Parents \u00b6 None. Elements \u00b6 <sort> <individual> <predicate> <action> Children \u00b6 None. Behaviour \u00b6 The ontology element is the root element of the ontology file. Examples \u00b6 Partial ontology for a phone application \u00b6 <ontology name= \"phone\" > <sort name= \"number_type\" /> <predicate name= \"number_type_to_call\" sort= \"number_type\" /> <action name= \"make_call\" /> <individual name= \"mobile\" sort= \"number_type\" /> <individual name= \"home\" sort= \"number_type\" /> <individual name= \"work\" sort= \"number_type\" /> </ontology>","title":"Introduction"},{"location":"dialog-domain-description-definition/ontology/ontology/#ontology","text":"","title":"Ontology"},{"location":"dialog-domain-description-definition/ontology/ontology/#definition","text":"<ontology name= \"n\" > ... </ontology> An ontology is an inventory of the things one can talk about in an application, consisting of (semantic) sorts, individuals, predicates and actions. Attribute Type Description name string Required. The name of the ontology.","title":"Definition"},{"location":"dialog-domain-description-definition/ontology/ontology/#parents","text":"None.","title":"Parents"},{"location":"dialog-domain-description-definition/ontology/ontology/#elements","text":"<sort> <individual> <predicate> <action>","title":"Elements"},{"location":"dialog-domain-description-definition/ontology/ontology/#children","text":"None.","title":"Children"},{"location":"dialog-domain-description-definition/ontology/ontology/#behaviour","text":"The ontology element is the root element of the ontology file.","title":"Behaviour"},{"location":"dialog-domain-description-definition/ontology/ontology/#examples","text":"","title":"Examples"},{"location":"dialog-domain-description-definition/ontology/ontology/#partial-ontology-for-a-phone-application","text":"<ontology name= \"phone\" > <sort name= \"number_type\" /> <predicate name= \"number_type_to_call\" sort= \"number_type\" /> <action name= \"make_call\" /> <individual name= \"mobile\" sort= \"number_type\" /> <individual name= \"home\" sort= \"number_type\" /> <individual name= \"work\" sort= \"number_type\" /> </ontology>","title":"Partial ontology for a phone application"},{"location":"dialog-domain-description-definition/ontology/elements/action/","text":"Action \u00b6 Definition \u00b6 <action name= \"alpha\" /> The action element describes an action in the domain of the application. Attribute Type Description name string Required. The name of the action. Parents \u00b6 <ontology> Children \u00b6 None. Behaviour \u00b6 The action element describes an action in the domain of the application. An action could be to show a particular menu, or to carry out a device action. Actions are part of perform goals. Examples \u00b6 Action to make a call \u00b6 <action name= \"make_call\" />","title":"Action"},{"location":"dialog-domain-description-definition/ontology/elements/action/#action","text":"","title":"Action"},{"location":"dialog-domain-description-definition/ontology/elements/action/#definition","text":"<action name= \"alpha\" /> The action element describes an action in the domain of the application. Attribute Type Description name string Required. The name of the action.","title":"Definition"},{"location":"dialog-domain-description-definition/ontology/elements/action/#parents","text":"<ontology>","title":"Parents"},{"location":"dialog-domain-description-definition/ontology/elements/action/#children","text":"None.","title":"Children"},{"location":"dialog-domain-description-definition/ontology/elements/action/#behaviour","text":"The action element describes an action in the domain of the application. An action could be to show a particular menu, or to carry out a device action. Actions are part of perform goals.","title":"Behaviour"},{"location":"dialog-domain-description-definition/ontology/elements/action/#examples","text":"","title":"Examples"},{"location":"dialog-domain-description-definition/ontology/elements/action/#action-to-make-a-call","text":"<action name= \"make_call\" />","title":"Action to make a call"},{"location":"dialog-domain-description-definition/ontology/elements/individual/","text":"Individual \u00b6 Definition \u00b6 <individual name= \"i\" sort= \"s\" /> The individual element describes a thing that one can talk about. Attribute Type Description name string Required. The name of the individual. sort string Required. The sort of the individual. Parents \u00b6 <ontology> Children \u00b6 None. Behaviour \u00b6 The individual element describes a thing that one can talk about - an entity in the domain that the ontology is describing. All individuals are of a sort, and all predicates take individuals (of a specific sort) as arguments. Known limitations: Note that individuals cannot be numbers. Examples \u00b6 Months \u00b6 <individual name= \"january\" sort= \"month\" /> <individual name= \"february\" sort= \"month\" /> <individual name= \"march\" sort= \"month\" /> ... <individual name= \"december\" sort= \"month\" />","title":"Individual"},{"location":"dialog-domain-description-definition/ontology/elements/individual/#individual","text":"","title":"Individual"},{"location":"dialog-domain-description-definition/ontology/elements/individual/#definition","text":"<individual name= \"i\" sort= \"s\" /> The individual element describes a thing that one can talk about. Attribute Type Description name string Required. The name of the individual. sort string Required. The sort of the individual.","title":"Definition"},{"location":"dialog-domain-description-definition/ontology/elements/individual/#parents","text":"<ontology>","title":"Parents"},{"location":"dialog-domain-description-definition/ontology/elements/individual/#children","text":"None.","title":"Children"},{"location":"dialog-domain-description-definition/ontology/elements/individual/#behaviour","text":"The individual element describes a thing that one can talk about - an entity in the domain that the ontology is describing. All individuals are of a sort, and all predicates take individuals (of a specific sort) as arguments. Known limitations: Note that individuals cannot be numbers.","title":"Behaviour"},{"location":"dialog-domain-description-definition/ontology/elements/individual/#examples","text":"","title":"Examples"},{"location":"dialog-domain-description-definition/ontology/elements/individual/#months","text":"<individual name= \"january\" sort= \"month\" /> <individual name= \"february\" sort= \"month\" /> <individual name= \"march\" sort= \"month\" /> ... <individual name= \"december\" sort= \"month\" />","title":"Months"},{"location":"dialog-domain-description-definition/ontology/elements/predicate/","text":"Predicate \u00b6 Definition \u00b6 <predicate name= \"r\" sort= \"s\" /> A predicate ascribes some property to an individual. This individual is the argument of the predicate. A predicate requires its arguments to be of a specific sort. Attribute Type Description name string Required. The name of the predicate. sort string Required. The semantic sort of arguments to the predicate. feature_of string Optional. The predicate of which this predicate is a feature (if any). Parents \u00b6 <ontology> Children \u00b6 None. Behaviour \u00b6 A predicate ascribes some property to an individual. This individual is the argument of the predicate. A predicate requires its arguments to be of a specific sort. If there is a sort hour , whose individuals are integers in the range 0-23, there can be one predicate current_hour , and another one alarm_hour , of the sort hour . The first one is a part of the description of the current time, the sencond one i a part of the description of the current alarm time. Predicates in TDM typically take a single argument of a specified sort (i.e. they have arity 1). Predicates that do not take an argument (arity 0), have sort Boolean . Predicates can be features of other predicates. This is particularly useful for incremental search dialogue. For example, if each product belongs to a product category, one might want to search for products based on their category (among other things). To do this, the predicate for product category is defined as a feature of the predicate for products. Examples \u00b6 Name of person to call \u00b6 <predicate name= \"name_to_call\" sort= \"name\" > Selected product predicate, with a feature predicate for product category \u00b6 <predicate name= \"selected_product\" sort= \"product\" /> <predicate name= \"selected_category\" sort= \"category\" feature_of= \"selected_product\" />","title":"Predicate"},{"location":"dialog-domain-description-definition/ontology/elements/predicate/#predicate","text":"","title":"Predicate"},{"location":"dialog-domain-description-definition/ontology/elements/predicate/#definition","text":"<predicate name= \"r\" sort= \"s\" /> A predicate ascribes some property to an individual. This individual is the argument of the predicate. A predicate requires its arguments to be of a specific sort. Attribute Type Description name string Required. The name of the predicate. sort string Required. The semantic sort of arguments to the predicate. feature_of string Optional. The predicate of which this predicate is a feature (if any).","title":"Definition"},{"location":"dialog-domain-description-definition/ontology/elements/predicate/#parents","text":"<ontology>","title":"Parents"},{"location":"dialog-domain-description-definition/ontology/elements/predicate/#children","text":"None.","title":"Children"},{"location":"dialog-domain-description-definition/ontology/elements/predicate/#behaviour","text":"A predicate ascribes some property to an individual. This individual is the argument of the predicate. A predicate requires its arguments to be of a specific sort. If there is a sort hour , whose individuals are integers in the range 0-23, there can be one predicate current_hour , and another one alarm_hour , of the sort hour . The first one is a part of the description of the current time, the sencond one i a part of the description of the current alarm time. Predicates in TDM typically take a single argument of a specified sort (i.e. they have arity 1). Predicates that do not take an argument (arity 0), have sort Boolean . Predicates can be features of other predicates. This is particularly useful for incremental search dialogue. For example, if each product belongs to a product category, one might want to search for products based on their category (among other things). To do this, the predicate for product category is defined as a feature of the predicate for products.","title":"Behaviour"},{"location":"dialog-domain-description-definition/ontology/elements/predicate/#examples","text":"","title":"Examples"},{"location":"dialog-domain-description-definition/ontology/elements/predicate/#name-of-person-to-call","text":"<predicate name= \"name_to_call\" sort= \"name\" >","title":"Name of person to call"},{"location":"dialog-domain-description-definition/ontology/elements/predicate/#selected-product-predicate-with-a-feature-predicate-for-product-category","text":"<predicate name= \"selected_product\" sort= \"product\" /> <predicate name= \"selected_category\" sort= \"category\" feature_of= \"selected_product\" />","title":"Selected product predicate, with a feature predicate for product category"},{"location":"dialog-domain-description-definition/ontology/elements/sort/","text":"Sort \u00b6 Definition \u00b6 <sort name= \"s\" /> The sort element describes a kind of thing that one can talk about. One can also think of it as a datatype declaration. All individuals are of a sort, and all predicates take arguments (individuals) of a specific sort. Attribute Type Description name string Required. The name of the sort. dynamic boolean Optional. If set to \"True\" , new individuals of the sort can be added during runtime. Parents \u00b6 <ontology> Children \u00b6 None. Behaviour \u00b6 Sorts can be dynamic or static. For dynamic sorts, new individuals of the sort can be added during runtime. Sorts can be user-defined or pre-defined. Only user-defined sorts need to be declared in the ontology. Pre-defined sorts in TDM are: Boolean : True or False Integer Real : Real numbers represented as floats String : Strings of characters.This is primarily used for literal answers dictated by the user, e.g. messages or names. Image : String representing a URL of an image Webview : String representing the URL of a webview Domain : The name of an other domain. This allows one to talk explicitly about domains, and can be thus used for meta dialogues, e.g. switching between domains. Examples \u00b6 Sort for telephone number type \u00b6 <sort name= \"number_type\" /> Sort for album title in music playing app \u00b6 <sort name= \"album_name\" dynamic= \"True\" />","title":"Sort"},{"location":"dialog-domain-description-definition/ontology/elements/sort/#sort","text":"","title":"Sort"},{"location":"dialog-domain-description-definition/ontology/elements/sort/#definition","text":"<sort name= \"s\" /> The sort element describes a kind of thing that one can talk about. One can also think of it as a datatype declaration. All individuals are of a sort, and all predicates take arguments (individuals) of a specific sort. Attribute Type Description name string Required. The name of the sort. dynamic boolean Optional. If set to \"True\" , new individuals of the sort can be added during runtime.","title":"Definition"},{"location":"dialog-domain-description-definition/ontology/elements/sort/#parents","text":"<ontology>","title":"Parents"},{"location":"dialog-domain-description-definition/ontology/elements/sort/#children","text":"None.","title":"Children"},{"location":"dialog-domain-description-definition/ontology/elements/sort/#behaviour","text":"Sorts can be dynamic or static. For dynamic sorts, new individuals of the sort can be added during runtime. Sorts can be user-defined or pre-defined. Only user-defined sorts need to be declared in the ontology. Pre-defined sorts in TDM are: Boolean : True or False Integer Real : Real numbers represented as floats String : Strings of characters.This is primarily used for literal answers dictated by the user, e.g. messages or names. Image : String representing a URL of an image Webview : String representing the URL of a webview Domain : The name of an other domain. This allows one to talk explicitly about domains, and can be thus used for meta dialogues, e.g. switching between domains.","title":"Behaviour"},{"location":"dialog-domain-description-definition/ontology/elements/sort/#examples","text":"","title":"Examples"},{"location":"dialog-domain-description-definition/ontology/elements/sort/#sort-for-telephone-number-type","text":"<sort name= \"number_type\" />","title":"Sort for telephone number type"},{"location":"dialog-domain-description-definition/ontology/elements/sort/#sort-for-album-title-in-music-playing-app","text":"<sort name= \"album_name\" dynamic= \"True\" />","title":"Sort for album title in music playing app"},{"location":"dialog-domain-description-definition/service_interface/service_interface/","text":"Service Interface \u00b6 Definition \u00b6 The Service Interface ( service_interface.xml ) forwards an <action> , <query> , <entity_recognizer> or <validator> , to a frontend service, http_service or device module.","title":"Introduction"},{"location":"dialog-domain-description-definition/service_interface/service_interface/#service-interface","text":"","title":"Service Interface"},{"location":"dialog-domain-description-definition/service_interface/service_interface/#definition","text":"The Service Interface ( service_interface.xml ) forwards an <action> , <query> , <entity_recognizer> or <validator> , to a frontend service, http_service or device module.","title":"Definition"},{"location":"dialog-domain-description-definition/service_interface/children/failure_reasons/","text":"Failure Reasons \u00b6 Definition \u00b6 <failure_reasons> <failure_reason name= \"failure_reason_name\" /> </failure_reasons> Specifies the reasons for an <action> to return a failure. Attribute Type Description name string Required. The name of the failure reason. The names are written using lowercase separated by underscores, e.g. 'temperature_too_high'. Children \u00b6 <failure_reason> Behaviour \u00b6 The <failure_reasons> element in the service interface contains all the possible reasons for the <target> service inside an <action> to return a fail status in its response. Each of the reasons must be passed in a <failure_reason> child. For each <failure_reason>, the response from the target service must also contain a reason that matches the name of the <failure_reason>. It is possible for an <action> to not contain any <failure_reason>, in which case the <action> is expected to always return a \"status\": \"success\" . The \"status\": \"fail\" (and the <failure_reason>) is meant for action failures expected by the DDD developer. Such a failure could be, for instance, an action receiving a parameter with an invalid value (see the example below). This will trigger the system to report to the user why the action has failed. The failure utterance will need to be defined in the grammar . Examples \u00b6 Set temperature with a failure reason \u00b6 If the action in the target http_service receives a value for the parameter degrees above a specific threshold (e.g. \"27 degrees\"), the http_service sends back a response with \"status\": \"fail\" and the \"reason\": \"temperature_too_high\" . <action name= \"SetTemperature\" > <parameters> <parameter predicate= \"degrees\" format= \"value\" /> </parameters> <failure_reasons> <failure_reason name= \"temperature_too_high\" /> </failure_reasons> <target> <http endpoint= \"http://127.0.0.1:10100/set_temperature\" /> </target> </action>","title":"Failure Reasons"},{"location":"dialog-domain-description-definition/service_interface/children/failure_reasons/#failure-reasons","text":"","title":"Failure Reasons"},{"location":"dialog-domain-description-definition/service_interface/children/failure_reasons/#definition","text":"<failure_reasons> <failure_reason name= \"failure_reason_name\" /> </failure_reasons> Specifies the reasons for an <action> to return a failure. Attribute Type Description name string Required. The name of the failure reason. The names are written using lowercase separated by underscores, e.g. 'temperature_too_high'.","title":"Definition"},{"location":"dialog-domain-description-definition/service_interface/children/failure_reasons/#children","text":"<failure_reason>","title":"Children"},{"location":"dialog-domain-description-definition/service_interface/children/failure_reasons/#behaviour","text":"The <failure_reasons> element in the service interface contains all the possible reasons for the <target> service inside an <action> to return a fail status in its response. Each of the reasons must be passed in a <failure_reason> child. For each <failure_reason>, the response from the target service must also contain a reason that matches the name of the <failure_reason>. It is possible for an <action> to not contain any <failure_reason>, in which case the <action> is expected to always return a \"status\": \"success\" . The \"status\": \"fail\" (and the <failure_reason>) is meant for action failures expected by the DDD developer. Such a failure could be, for instance, an action receiving a parameter with an invalid value (see the example below). This will trigger the system to report to the user why the action has failed. The failure utterance will need to be defined in the grammar .","title":"Behaviour"},{"location":"dialog-domain-description-definition/service_interface/children/failure_reasons/#examples","text":"","title":"Examples"},{"location":"dialog-domain-description-definition/service_interface/children/failure_reasons/#set-temperature-with-a-failure-reason","text":"If the action in the target http_service receives a value for the parameter degrees above a specific threshold (e.g. \"27 degrees\"), the http_service sends back a response with \"status\": \"fail\" and the \"reason\": \"temperature_too_high\" . <action name= \"SetTemperature\" > <parameters> <parameter predicate= \"degrees\" format= \"value\" /> </parameters> <failure_reasons> <failure_reason name= \"temperature_too_high\" /> </failure_reasons> <target> <http endpoint= \"http://127.0.0.1:10100/set_temperature\" /> </target> </action>","title":"Set temperature with a failure reason"},{"location":"dialog-domain-description-definition/service_interface/children/parameters/","text":"Parameters \u00b6 Definition \u00b6 <parameters> <parameter predicate= \"predicate_name\" format= \"format\" default= \"default\" /> </parameters> Specifies the parameters to be used as arguments by the target service. Attribute Type Description predicate string Required. The name of the predicate that is used as a parameter. Should match the name of the corresponding predicate declared in the Ontology. Predicate names are written using lowercase separated by underscores, e.g. 'current_temperature'. format string Required. Specifies the field in the request from which the parameter should be taken. Available options: value grammar_entry default string Optional. Default 'value' or 'grammar_entry' for the predicate used as a parameter. Children \u00b6 <parameter> Behaviour \u00b6 The <parameters> element in the service interface contains all the parameters sent as arguments to the <target> service. Each of the parameters used by the specified target must be passed in a <parameter> child. Format attribute \u00b6 The format attribute specifies if the parameter passed to the target service has to be taken from the 'value' or 'grammar_entry' field of the request. Default attribute \u00b6 The default attribute contains a string that is used as a 'value' or 'grammar_entry' if the predicate in the <parameter> doesn't have any content in that 'value' or 'grammar_entry' (the one specified in the format attribute). This attribute is necessary when the parameter is resolved in the Domain with a <bind> or a <raise> element since the user doesn't need to answer to these. If the user didn't answer those and a default value hasn't been specified, the predicate would be empty. Examples \u00b6 Forward a Call to a frontend with a selected contact and phone \u00b6 <action name= \"Call\" > <parameters> <parameter predicate= \"selected_contact\" format= \"value\" /> <parameter predicate= \"selected_phone\" format= \"grammar_entry\" default= \"mobile\" /> </parameters> <failure_reasons/> <target> <frontend/> </target> </action>","title":"Parameters"},{"location":"dialog-domain-description-definition/service_interface/children/parameters/#parameters","text":"","title":"Parameters"},{"location":"dialog-domain-description-definition/service_interface/children/parameters/#definition","text":"<parameters> <parameter predicate= \"predicate_name\" format= \"format\" default= \"default\" /> </parameters> Specifies the parameters to be used as arguments by the target service. Attribute Type Description predicate string Required. The name of the predicate that is used as a parameter. Should match the name of the corresponding predicate declared in the Ontology. Predicate names are written using lowercase separated by underscores, e.g. 'current_temperature'. format string Required. Specifies the field in the request from which the parameter should be taken. Available options: value grammar_entry default string Optional. Default 'value' or 'grammar_entry' for the predicate used as a parameter.","title":"Definition"},{"location":"dialog-domain-description-definition/service_interface/children/parameters/#children","text":"<parameter>","title":"Children"},{"location":"dialog-domain-description-definition/service_interface/children/parameters/#behaviour","text":"The <parameters> element in the service interface contains all the parameters sent as arguments to the <target> service. Each of the parameters used by the specified target must be passed in a <parameter> child.","title":"Behaviour"},{"location":"dialog-domain-description-definition/service_interface/children/parameters/#format-attribute","text":"The format attribute specifies if the parameter passed to the target service has to be taken from the 'value' or 'grammar_entry' field of the request.","title":"Format attribute"},{"location":"dialog-domain-description-definition/service_interface/children/parameters/#default-attribute","text":"The default attribute contains a string that is used as a 'value' or 'grammar_entry' if the predicate in the <parameter> doesn't have any content in that 'value' or 'grammar_entry' (the one specified in the format attribute). This attribute is necessary when the parameter is resolved in the Domain with a <bind> or a <raise> element since the user doesn't need to answer to these. If the user didn't answer those and a default value hasn't been specified, the predicate would be empty.","title":"Default attribute"},{"location":"dialog-domain-description-definition/service_interface/children/parameters/#examples","text":"","title":"Examples"},{"location":"dialog-domain-description-definition/service_interface/children/parameters/#forward-a-call-to-a-frontend-with-a-selected-contact-and-phone","text":"<action name= \"Call\" > <parameters> <parameter predicate= \"selected_contact\" format= \"value\" /> <parameter predicate= \"selected_phone\" format= \"grammar_entry\" default= \"mobile\" /> </parameters> <failure_reasons/> <target> <frontend/> </target> </action>","title":"Forward a Call to a frontend with a selected contact and phone"},{"location":"dialog-domain-description-definition/service_interface/children/target/","text":"Target \u00b6 Definition \u00b6 <target> <http endpoint= \"http://127.0.0.1:10100/function_name\" /> </target> <target> <frontend/> </target> <target> <device_module device= \"NameDevice\" /> </target> Specifies the target service. \u00b6 Attribute Type Description endpoint string Required. The url of the http_service endpoint followed by the name of the function it should run in that endpoint, e.g. 'http://127.0.0.1:10100/set_temperature'. \u00b6 Attribute Type Description device string Required. The name of the device module to run. Children \u00b6 <http> <frontend> <device_module> Behaviour \u00b6 The <target> element in the service interface specifies the target service that will handle its parent <action> , <query> , <validator> or <entity_recognizer> . \u00b6 Points the parent element to a function of an http_service served on a Flask instance. The DDD sends a request to the http_service, performs the function in it and returns a response. \u00b6 Points the parent <action> to an integrated frontend service such as Twilio or Alexa. This allows for performing actions like forwarding a call using a frontend service. \u00b6 Points the parent element to a device module. This will run a class inside the device module which must have the same name as the parent <action> , <query> , etc. Examples \u00b6 Set the temperature to a specific value using an http_service \u00b6 <action name= \"SetTemperature\" > <parameters> <parameter predicate= \"degrees\" format= \"value\" /> </parameters> <failure_reasons> <failure_reason name= \"temperature_too_high\" /> </failure_reasons> <target> <http endpoint= \"http://127.0.0.1:10100/set_temperature\" /> </target> </action> Forward a Call action to a frontend service \u00b6 <action name= \"Call\" > <parameters> <parameter predicate= \"phone_number\" format= \"grammar_entry\" /> </parameters> <failure_reasons/> <target> <frontend/> </target> </action> Query a device module about the current temperature in a location \u00b6 <query name= \"current_temperature\" > <parameters> <parameter predicate= \"location\" format= \"grammar_entry\" /> </parameters> <target> <device_module device= \"ClimateDevice\" /> </target> </query>","title":"Target"},{"location":"dialog-domain-description-definition/service_interface/children/target/#target","text":"","title":"Target"},{"location":"dialog-domain-description-definition/service_interface/children/target/#definition","text":"<target> <http endpoint= \"http://127.0.0.1:10100/function_name\" /> </target> <target> <frontend/> </target> <target> <device_module device= \"NameDevice\" /> </target> Specifies the target service.","title":"Definition"},{"location":"dialog-domain-description-definition/service_interface/children/target/#_1","text":"Attribute Type Description endpoint string Required. The url of the http_service endpoint followed by the name of the function it should run in that endpoint, e.g. 'http://127.0.0.1:10100/set_temperature'.","title":""},{"location":"dialog-domain-description-definition/service_interface/children/target/#_2","text":"Attribute Type Description device string Required. The name of the device module to run.","title":""},{"location":"dialog-domain-description-definition/service_interface/children/target/#children","text":"<http> <frontend> <device_module>","title":"Children"},{"location":"dialog-domain-description-definition/service_interface/children/target/#behaviour","text":"The <target> element in the service interface specifies the target service that will handle its parent <action> , <query> , <validator> or <entity_recognizer> .","title":"Behaviour"},{"location":"dialog-domain-description-definition/service_interface/children/target/#_3","text":"Points the parent element to a function of an http_service served on a Flask instance. The DDD sends a request to the http_service, performs the function in it and returns a response.","title":""},{"location":"dialog-domain-description-definition/service_interface/children/target/#_4","text":"Points the parent <action> to an integrated frontend service such as Twilio or Alexa. This allows for performing actions like forwarding a call using a frontend service.","title":""},{"location":"dialog-domain-description-definition/service_interface/children/target/#_5","text":"Points the parent element to a device module. This will run a class inside the device module which must have the same name as the parent <action> , <query> , etc.","title":""},{"location":"dialog-domain-description-definition/service_interface/children/target/#examples","text":"","title":"Examples"},{"location":"dialog-domain-description-definition/service_interface/children/target/#set-the-temperature-to-a-specific-value-using-an-http_service","text":"<action name= \"SetTemperature\" > <parameters> <parameter predicate= \"degrees\" format= \"value\" /> </parameters> <failure_reasons> <failure_reason name= \"temperature_too_high\" /> </failure_reasons> <target> <http endpoint= \"http://127.0.0.1:10100/set_temperature\" /> </target> </action>","title":"Set the temperature to a specific value using an http_service"},{"location":"dialog-domain-description-definition/service_interface/children/target/#forward-a-call-action-to-a-frontend-service","text":"<action name= \"Call\" > <parameters> <parameter predicate= \"phone_number\" format= \"grammar_entry\" /> </parameters> <failure_reasons/> <target> <frontend/> </target> </action>","title":"Forward a Call action to a frontend service"},{"location":"dialog-domain-description-definition/service_interface/children/target/#query-a-device-module-about-the-current-temperature-in-a-location","text":"<query name= \"current_temperature\" > <parameters> <parameter predicate= \"location\" format= \"grammar_entry\" /> </parameters> <target> <device_module device= \"ClimateDevice\" /> </target> </query>","title":"Query a device module about the current temperature in a location"},{"location":"dialog-domain-description-definition/service_interface/elements/action/","text":"Action \u00b6 Definition \u00b6 <action name= \"ActionName\" > Performs an action in http_service, device module or frontend service. Attribute Type Description name string Required. The name of the action. Action names are written according to the PascalCase convention, e.g. 'SetTemperature'. Children \u00b6 <parameters> <parameter> <failure_reasons> <failure_reason> <target> <http> <device_module> <frontend> Behaviour \u00b6 The <action> element in the service interface connects the corresponding <invoke_service_action> element in the domain to a specific service action inside <target> . The target service must be either an http_service, device module or frontend service, which would return either success or fail status inside an action response. Each of the parameters used by the specified <target> must be passed under <parameters> . If the <action> contains a <failure_reason> , the target service must be able to return a fail status with the reason name in the response. Check the documentation of this child element for more information. Examples \u00b6 Set temperature \u00b6 <action name= \"SetTemperature\" > <parameters> <parameter predicate= \"degrees\" format= \"value\" /> </parameters> <failure_reasons> <failure_reason name= \"temperature_too_high\" /> </failure_reasons> <target> <http endpoint= \"http://127.0.0.1:10100/set_temperature\" /> </target> </action> Forward a Call \u00b6 <action name= \"Call\" > <parameters> <parameter predicate= \"phone_number\" format= \"grammar_entry\" /> </parameters> <failure_reasons/> <target> <frontend/> </target> </action>","title":"Action"},{"location":"dialog-domain-description-definition/service_interface/elements/action/#action","text":"","title":"Action"},{"location":"dialog-domain-description-definition/service_interface/elements/action/#definition","text":"<action name= \"ActionName\" > Performs an action in http_service, device module or frontend service. Attribute Type Description name string Required. The name of the action. Action names are written according to the PascalCase convention, e.g. 'SetTemperature'.","title":"Definition"},{"location":"dialog-domain-description-definition/service_interface/elements/action/#children","text":"<parameters> <parameter> <failure_reasons> <failure_reason> <target> <http> <device_module> <frontend>","title":"Children"},{"location":"dialog-domain-description-definition/service_interface/elements/action/#behaviour","text":"The <action> element in the service interface connects the corresponding <invoke_service_action> element in the domain to a specific service action inside <target> . The target service must be either an http_service, device module or frontend service, which would return either success or fail status inside an action response. Each of the parameters used by the specified <target> must be passed under <parameters> . If the <action> contains a <failure_reason> , the target service must be able to return a fail status with the reason name in the response. Check the documentation of this child element for more information.","title":"Behaviour"},{"location":"dialog-domain-description-definition/service_interface/elements/action/#examples","text":"","title":"Examples"},{"location":"dialog-domain-description-definition/service_interface/elements/action/#set-temperature","text":"<action name= \"SetTemperature\" > <parameters> <parameter predicate= \"degrees\" format= \"value\" /> </parameters> <failure_reasons> <failure_reason name= \"temperature_too_high\" /> </failure_reasons> <target> <http endpoint= \"http://127.0.0.1:10100/set_temperature\" /> </target> </action>","title":"Set temperature"},{"location":"dialog-domain-description-definition/service_interface/elements/action/#forward-a-call","text":"<action name= \"Call\" > <parameters> <parameter predicate= \"phone_number\" format= \"grammar_entry\" /> </parameters> <failure_reasons/> <target> <frontend/> </target> </action>","title":"Forward a Call"},{"location":"dialog-domain-description-definition/service_interface/elements/entity_recognizer/","text":"Entity Recognizer \u00b6 Definition \u00b6 <entity_recognizer name= \"EntityRecognizerName\" > Requests entities from an http_service or a device module. Attribute Type Description name string Required. The name of the entity recognizer. Names are written according to the PascalCase convention, e.g. 'CityRecognizer'. Children \u00b6 <target> <http> <device_module> Behaviour \u00b6 The <entity_recognizer> element in the service interface requests entities from the <target> http_service or device module. The endpoint function will collect the entities and return each of the entities' value , grammar_entry and sort in the response. Examples \u00b6 Request for cities to an http_service \u00b6 <entity_recognizer name= \"CityRecognizer\" > <target> <http endpoint= \"http://127.0.0.1:10100/city_recognizer\" /> </target> </entity_recognizer>","title":"Entity Recognizer"},{"location":"dialog-domain-description-definition/service_interface/elements/entity_recognizer/#entity-recognizer","text":"","title":"Entity Recognizer"},{"location":"dialog-domain-description-definition/service_interface/elements/entity_recognizer/#definition","text":"<entity_recognizer name= \"EntityRecognizerName\" > Requests entities from an http_service or a device module. Attribute Type Description name string Required. The name of the entity recognizer. Names are written according to the PascalCase convention, e.g. 'CityRecognizer'.","title":"Definition"},{"location":"dialog-domain-description-definition/service_interface/elements/entity_recognizer/#children","text":"<target> <http> <device_module>","title":"Children"},{"location":"dialog-domain-description-definition/service_interface/elements/entity_recognizer/#behaviour","text":"The <entity_recognizer> element in the service interface requests entities from the <target> http_service or device module. The endpoint function will collect the entities and return each of the entities' value , grammar_entry and sort in the response.","title":"Behaviour"},{"location":"dialog-domain-description-definition/service_interface/elements/entity_recognizer/#examples","text":"","title":"Examples"},{"location":"dialog-domain-description-definition/service_interface/elements/entity_recognizer/#request-for-cities-to-an-http_service","text":"<entity_recognizer name= \"CityRecognizer\" > <target> <http endpoint= \"http://127.0.0.1:10100/city_recognizer\" /> </target> </entity_recognizer>","title":"Request for cities to an http_service"},{"location":"dialog-domain-description-definition/service_interface/elements/query/","text":"Query \u00b6 Definition \u00b6 <query name= \"query_name\" > Requests information from an http_service or a device module. Attribute Type Description name string Required. The name of the predicate that is requesting the information. Should match the name of the corresponding predicate of the invoke_service_query in the domain. Query names are written using lowercase separated by underscores, e.g. 'current_temperature'. Children \u00b6 <parameters> <parameter> <target> <http> <device_module> Behaviour \u00b6 The <query> element in the service interface connects the corresponding <invoke_service_query> element in the domain to a specific service query inside <target> . The target service must be either a http_service or a device module which returns a query response. Each of the parameters used by the specified <target> must be passed under <parameters> . Examples \u00b6 Query a device module about the current temperature in a location \u00b6 <query name= \"current_temperature\" > <parameters> <parameter predicate= \"location\" format= \"grammar_entry\" /> </parameters> <target> <http endpoint= \"http://127.0.0.1:10100/current_temperature\" /> </target> </query>","title":"Query"},{"location":"dialog-domain-description-definition/service_interface/elements/query/#query","text":"","title":"Query"},{"location":"dialog-domain-description-definition/service_interface/elements/query/#definition","text":"<query name= \"query_name\" > Requests information from an http_service or a device module. Attribute Type Description name string Required. The name of the predicate that is requesting the information. Should match the name of the corresponding predicate of the invoke_service_query in the domain. Query names are written using lowercase separated by underscores, e.g. 'current_temperature'.","title":"Definition"},{"location":"dialog-domain-description-definition/service_interface/elements/query/#children","text":"<parameters> <parameter> <target> <http> <device_module>","title":"Children"},{"location":"dialog-domain-description-definition/service_interface/elements/query/#behaviour","text":"The <query> element in the service interface connects the corresponding <invoke_service_query> element in the domain to a specific service query inside <target> . The target service must be either a http_service or a device module which returns a query response. Each of the parameters used by the specified <target> must be passed under <parameters> .","title":"Behaviour"},{"location":"dialog-domain-description-definition/service_interface/elements/query/#examples","text":"","title":"Examples"},{"location":"dialog-domain-description-definition/service_interface/elements/query/#query-a-device-module-about-the-current-temperature-in-a-location","text":"<query name= \"current_temperature\" > <parameters> <parameter predicate= \"location\" format= \"grammar_entry\" /> </parameters> <target> <http endpoint= \"http://127.0.0.1:10100/current_temperature\" /> </target> </query>","title":"Query a device module about the current temperature in a location"},{"location":"dialog-domain-description-definition/service_interface/elements/validator/","text":"Validator \u00b6 Definition \u00b6 <validator name= \"ValidatorName\" > Checks the validity of some predicate in an http_service or a device module. Attribute Type Description name string Required. The name of the validator class. Names are written according to the PascalCase convention, e.g. 'CityRecognizer'. Children \u00b6 <parameters> <parameter> <target> <http> <device_module> Behaviour \u00b6 The <validator> element in the service interface checks the validity of a parameter using the specified module in <target> . The target service must be either an http_service or a device module, which would return either true or false as the value for \"is_valid\" inside a validator response. If the target module returns a \"is_valid\": false , that will trigger the system to reject the user utterance, and explain to the user why the parameter was rejected. The rejecting utterance will need to be defined in the grammar . Examples \u00b6 Check in an http_service if the value and grammar entry for the destination city are valid \u00b6 <validator name= \"CityValidity\" > <parameters> <parameter predicate= \"dest_city\" format= \"value\" /> <parameter predicate= \"dest_city\" format= \"grammar_entry\" /> </parameters> <target> <http endpoint= \"http://127.0.0.1:10100/city_validity\" /> </target> </validator>","title":"Validator"},{"location":"dialog-domain-description-definition/service_interface/elements/validator/#validator","text":"","title":"Validator"},{"location":"dialog-domain-description-definition/service_interface/elements/validator/#definition","text":"<validator name= \"ValidatorName\" > Checks the validity of some predicate in an http_service or a device module. Attribute Type Description name string Required. The name of the validator class. Names are written according to the PascalCase convention, e.g. 'CityRecognizer'.","title":"Definition"},{"location":"dialog-domain-description-definition/service_interface/elements/validator/#children","text":"<parameters> <parameter> <target> <http> <device_module>","title":"Children"},{"location":"dialog-domain-description-definition/service_interface/elements/validator/#behaviour","text":"The <validator> element in the service interface checks the validity of a parameter using the specified module in <target> . The target service must be either an http_service or a device module, which would return either true or false as the value for \"is_valid\" inside a validator response. If the target module returns a \"is_valid\": false , that will trigger the system to reject the user utterance, and explain to the user why the parameter was rejected. The rejecting utterance will need to be defined in the grammar .","title":"Behaviour"},{"location":"dialog-domain-description-definition/service_interface/elements/validator/#examples","text":"","title":"Examples"},{"location":"dialog-domain-description-definition/service_interface/elements/validator/#check-in-an-http_service-if-the-value-and-grammar-entry-for-the-destination-city-are-valid","text":"<validator name= \"CityValidity\" > <parameters> <parameter predicate= \"dest_city\" format= \"value\" /> <parameter predicate= \"dest_city\" format= \"grammar_entry\" /> </parameters> <target> <http endpoint= \"http://127.0.0.1:10100/city_validity\" /> </target> </validator>","title":"Check in an http_service if the value and grammar entry for the destination city are valid"},{"location":"for-dialog-designers/","text":"Introduction \u00b6 The task of the dialog designer is to define and design the dialog domain and the flow of the conversations in that domain, which will result in building a domain-specific dialog system. Thanks to the principle of separation of concerns that underpins TDM, where knowledge about the domain (e.g., a phone book domain or a navigation domain) is separated from general knowledge about dialog, dialog designers can focus on defining domain-specific knowledge, such as information about concepts. Designers can also focus on what words should be used to talk about these concepts, although specific languages are contained in grammars that are themselves separated from both domain and dialog knowledge in order to simplify expansion to even more languages. General dialog capabilities such as: ensuring that users can say anything at anytime the handling of questions and answers providing feedback grounding topic switching incremental search are all built into TDM and do not need to be provided by dialog designers. This makes it easier to build dialog systems since general dialog strategies need not be reinvented each time a new system is built. It allows the dialog designer to focus on domain-specific design. Dialog Domain Descriptions \u00b6 In TDM a domain-specific application is implemented in the form of a Dialog Domain Description (DDD). A DDD is a declarative description of a particular dialog domain. Firstly, it contains an ontology specifying all the things ( actions , predicates and individuals ) that we want to be able to talk about. Secondly, a domain contains dialog plans representing the desired flow of the dialog. Thirdly, a grammar defines the words and expressions that the user and system can use in talking about the domain. Lastly, through a service interface we can connect the information in the dialog to the real world and vice versa.","title":"Introduction"},{"location":"for-dialog-designers/#introduction","text":"The task of the dialog designer is to define and design the dialog domain and the flow of the conversations in that domain, which will result in building a domain-specific dialog system. Thanks to the principle of separation of concerns that underpins TDM, where knowledge about the domain (e.g., a phone book domain or a navigation domain) is separated from general knowledge about dialog, dialog designers can focus on defining domain-specific knowledge, such as information about concepts. Designers can also focus on what words should be used to talk about these concepts, although specific languages are contained in grammars that are themselves separated from both domain and dialog knowledge in order to simplify expansion to even more languages. General dialog capabilities such as: ensuring that users can say anything at anytime the handling of questions and answers providing feedback grounding topic switching incremental search are all built into TDM and do not need to be provided by dialog designers. This makes it easier to build dialog systems since general dialog strategies need not be reinvented each time a new system is built. It allows the dialog designer to focus on domain-specific design.","title":"Introduction"},{"location":"for-dialog-designers/#dialog-domain-descriptions","text":"In TDM a domain-specific application is implemented in the form of a Dialog Domain Description (DDD). A DDD is a declarative description of a particular dialog domain. Firstly, it contains an ontology specifying all the things ( actions , predicates and individuals ) that we want to be able to talk about. Secondly, a domain contains dialog plans representing the desired flow of the dialog. Thirdly, a grammar defines the words and expressions that the user and system can use in talking about the domain. Lastly, through a service interface we can connect the information in the dialog to the real world and vice versa.","title":"Dialog Domain Descriptions"},{"location":"for-dialog-designers/examples/","text":"Examples \u00b6 Below are examples for you to imitate. Find one that matches your desired functionality and start stealing ideas. Remember to work test driven, adding one test at a time, then making it work, according to the tutorial . Basic action \u00b6 This example is featured in the tutorial . Let your user do an action, using an entity recognizer for its findout . In this case, call a contact where the contact name is the recognized entity. U> Call John S> Calling John. This is an example of the basic action , answer and feedback concepts in TDM. It shows what is needed in order to perform an action that you implement yourself in the python service interface . In addition, it uses an entity recognizer to recognize contacts during run time. The source code is available on Github . Basic query \u00b6 Let your user ask a question. While similar to the basic action example, a query lets the system speak an answer to a question rather than performing an action. In this case, it answers what phone number a contact has. U> What is John's number? S> John's number is 0701234567. This is an example of the basic query and answer concepts in TDM. It shows what is needed in order to ask a query that is answered by the system. You implement the answer logic yourself in the python service interface . The source code is available on Github . Parameter validation \u00b6 Should some actions or questions be unavailable, disallowed or prohibited for your user? Parameter validation makes it easy to decide at run-time. This example is based on the basic action example , disallowing phone calls to contacts with no phone number. U> Call Andy S> Andy has no phone number. When a service is queried for parameters to actions and queries, the parameter is validated against all matching validators. If invalid, a specific grammar entry is used to provide system feedback and the answer is neglected. The source code is available on Github . Incremental search \u00b6 Is your user looking for a single item in a set of many? Make sure your application asks just the perfect amount of questions to find one and only one match. In this case, contacts to call are searched with first and last names. U> Call John S> What's his last name? U> Johnson S> Calling John Johnson at 0702446698. Incremental search utilizes predicate features, which are declared in the ontology of the DDD. When a service is queried for individuals of the predicate, the features need to match. By asking the user to specify more features, the search can be narrowed down to finally match a single individual. The source code is available on Github . Android \u00b6 Is your Android device placing the calls for your users? Forward your actions to the Android frontend and do the job there. U> Call John S> Calling John. This example combines the examples of action, query, parameter validation and entity recognition into one DDD and forwards the 'Call' action to the frontend. It can be used together with the android-example , an Android app to showcase how your frontend hears, speaks and thinks. The source code is available on Github .","title":"Examples"},{"location":"for-dialog-designers/examples/#examples","text":"Below are examples for you to imitate. Find one that matches your desired functionality and start stealing ideas. Remember to work test driven, adding one test at a time, then making it work, according to the tutorial .","title":"Examples"},{"location":"for-dialog-designers/examples/#basic-action","text":"This example is featured in the tutorial . Let your user do an action, using an entity recognizer for its findout . In this case, call a contact where the contact name is the recognized entity. U> Call John S> Calling John. This is an example of the basic action , answer and feedback concepts in TDM. It shows what is needed in order to perform an action that you implement yourself in the python service interface . In addition, it uses an entity recognizer to recognize contacts during run time. The source code is available on Github .","title":"Basic action"},{"location":"for-dialog-designers/examples/#basic-query","text":"Let your user ask a question. While similar to the basic action example, a query lets the system speak an answer to a question rather than performing an action. In this case, it answers what phone number a contact has. U> What is John's number? S> John's number is 0701234567. This is an example of the basic query and answer concepts in TDM. It shows what is needed in order to ask a query that is answered by the system. You implement the answer logic yourself in the python service interface . The source code is available on Github .","title":"Basic query"},{"location":"for-dialog-designers/examples/#parameter-validation","text":"Should some actions or questions be unavailable, disallowed or prohibited for your user? Parameter validation makes it easy to decide at run-time. This example is based on the basic action example , disallowing phone calls to contacts with no phone number. U> Call Andy S> Andy has no phone number. When a service is queried for parameters to actions and queries, the parameter is validated against all matching validators. If invalid, a specific grammar entry is used to provide system feedback and the answer is neglected. The source code is available on Github .","title":"Parameter validation"},{"location":"for-dialog-designers/examples/#incremental-search","text":"Is your user looking for a single item in a set of many? Make sure your application asks just the perfect amount of questions to find one and only one match. In this case, contacts to call are searched with first and last names. U> Call John S> What's his last name? U> Johnson S> Calling John Johnson at 0702446698. Incremental search utilizes predicate features, which are declared in the ontology of the DDD. When a service is queried for individuals of the predicate, the features need to match. By asking the user to specify more features, the search can be narrowed down to finally match a single individual. The source code is available on Github .","title":"Incremental search"},{"location":"for-dialog-designers/examples/#android","text":"Is your Android device placing the calls for your users? Forward your actions to the Android frontend and do the job there. U> Call John S> Calling John. This example combines the examples of action, query, parameter validation and entity recognition into one DDD and forwards the 'Call' action to the frontend. It can be used together with the android-example , an Android app to showcase how your frontend hears, speaks and thinks. The source code is available on Github .","title":"Android"},{"location":"for-dialog-designers/rasa_nlu/","text":"Using Rasa NLU \u00b6 For better language coverage of your DDDs, you may want to enable the machine-learning based Rasa NLU. This guide is written for version 0.14.6 of Rasa NLU. Before getting started, make sure to use hosted a Rasa NLU with the necessary dependencies installed. For instance, if you plan on using a Spacy pipeline, ensure that it has the appropriate language models and Spacy itself installed. For more information, read up on the Rasa NLU documentation . We recommend running it in Docker . Generate training data \u00b6 In order to use Rasa NLU with TDM, we need to train the model. The Tala SDK can be used to generate training data for your DDD: tala generate rasa my-ddd eng > training_data.yml . Configure the pipeline \u00b6 The generated training data comes with the spacy_sklearn pipeline by default. At the head of the training data we find: language: \"en\" pipeline: \"spacy_sklearn\" data: | ... Here, the pre-configured spacy_sklearn pipeline will be used, but there are others to choose from too . It's also possible to configure the pipeline oneself, by listing the components explicitly. For instance, this is the spacy_sklearn pipeline: pipeline: - name: \"SpacyNLP\" - name: \"SpacyTokenizer\" - name: \"RegexFeaturizer\" - name: \"SpacyFeaturizer\" - name: \"CRFEntityExtractor\" - name: \"EntitySynonymMapper\" - name: \"SklearnIntentClassifier\" Add pre-trained named entity recognizers (NERs) \u00b6 Rasa NLU supports pre-trained NERs to be part of the pipeline, for instance the NERs from Duckling and Spacy which can be used together with TDM. Duckling \u00b6 In this version of TDM, the following Duckling entities are supported: number : maps to the integer sort. time : maps to the datetime sort. To enable Duckling, make sure it's available to the Rasa server and add its component to an explicit pipeline: - name: \"DucklingHTTPExtractor\" url: \"http://duckling:8000\" Here, Duckling is available to the Rasa server at http://duckling:8000 . The spacy_sklearn pipeline with the addition of Duckling then becomes: pipeline: - name: \"SpacyNLP\" - name: \"SpacyTokenizer\" - name: \"RegexFeaturizer\" - name: \"SpacyFeaturizer\" - name: \"CRFEntityExtractor\" - name: \"EntitySynonymMapper\" - name: \"SklearnIntentClassifier\" - name: \"DucklingHTTPExtractor\" url: \"http://duckling:8000\" Spacy \u00b6 In this version of TDM, the following Spacy entity types are supported: PERSON and PER : map to the person_name sort. To enable Spacy, make sure it's available to the Rasa server and use a pipeline that contains SpacyEntityExtractor , e.g. pipeline: - name: \"SpacyNLP\" - name: \"SpacyTokenizer\" - name: \"RegexFeaturizer\" - name: \"SpacyFeaturizer\" - name: \"CRFEntityExtractor\" - name: \"EntitySynonymMapper\" - name: \"SklearnIntentClassifier\" - name: \"SpacyEntityExtractor\" Train the model \u00b6 Once the training data and pipeline are configured, train your model according to the Rasa NLU HTTP API . For instance with: curl -XPOST -H 'Content-Type: application/x-yml' 'http://my-rasa-nlu.my-cloud.com:5000/train?project=my-ddd&model=my-model' --data-binary @training_data.yml In this case, the URL, project and model also need to be specified in the DDD config in the next step. Configure the DDD \u00b6 Make sure to configure Rasa NLU in the DDD config, for instance at my_ddd/ddd.config.json , by adding language specific rasa_nlu objects. For instance, for English: { \"rasa_nlu\" : { \"eng\" : { \"url\" : \"http://my-rasa-nlu.my-cloud.com:5000/parse\" , \"config\" : { \"project\" : \"my-ddd\" , \"model\" : \"my-model\" } } } } The rasa_nlu object contains the following fields: url : A string URL, pointing to the /parse endpoint of a Rasa NLU server . config : An object sent in the JSON payload when TDM posts it to the url . It can contain for instance project and model , as specified by the Rasa NLU HTTP API . TDM also adds the field \"q\": \"<user utterance>\" . If Rasa NLU should not be used for a particular language, remove the language altogether: { \"rasa_nlu\" : {} }","title":"Using Rasa NLU"},{"location":"for-dialog-designers/rasa_nlu/#using-rasa-nlu","text":"For better language coverage of your DDDs, you may want to enable the machine-learning based Rasa NLU. This guide is written for version 0.14.6 of Rasa NLU. Before getting started, make sure to use hosted a Rasa NLU with the necessary dependencies installed. For instance, if you plan on using a Spacy pipeline, ensure that it has the appropriate language models and Spacy itself installed. For more information, read up on the Rasa NLU documentation . We recommend running it in Docker .","title":"Using Rasa NLU"},{"location":"for-dialog-designers/rasa_nlu/#generate-training-data","text":"In order to use Rasa NLU with TDM, we need to train the model. The Tala SDK can be used to generate training data for your DDD: tala generate rasa my-ddd eng > training_data.yml .","title":"Generate training data"},{"location":"for-dialog-designers/rasa_nlu/#configure-the-pipeline","text":"The generated training data comes with the spacy_sklearn pipeline by default. At the head of the training data we find: language: \"en\" pipeline: \"spacy_sklearn\" data: | ... Here, the pre-configured spacy_sklearn pipeline will be used, but there are others to choose from too . It's also possible to configure the pipeline oneself, by listing the components explicitly. For instance, this is the spacy_sklearn pipeline: pipeline: - name: \"SpacyNLP\" - name: \"SpacyTokenizer\" - name: \"RegexFeaturizer\" - name: \"SpacyFeaturizer\" - name: \"CRFEntityExtractor\" - name: \"EntitySynonymMapper\" - name: \"SklearnIntentClassifier\"","title":"Configure the pipeline"},{"location":"for-dialog-designers/rasa_nlu/#add-pre-trained-named-entity-recognizers-ners","text":"Rasa NLU supports pre-trained NERs to be part of the pipeline, for instance the NERs from Duckling and Spacy which can be used together with TDM.","title":"Add pre-trained named entity recognizers (NERs)"},{"location":"for-dialog-designers/rasa_nlu/#duckling","text":"In this version of TDM, the following Duckling entities are supported: number : maps to the integer sort. time : maps to the datetime sort. To enable Duckling, make sure it's available to the Rasa server and add its component to an explicit pipeline: - name: \"DucklingHTTPExtractor\" url: \"http://duckling:8000\" Here, Duckling is available to the Rasa server at http://duckling:8000 . The spacy_sklearn pipeline with the addition of Duckling then becomes: pipeline: - name: \"SpacyNLP\" - name: \"SpacyTokenizer\" - name: \"RegexFeaturizer\" - name: \"SpacyFeaturizer\" - name: \"CRFEntityExtractor\" - name: \"EntitySynonymMapper\" - name: \"SklearnIntentClassifier\" - name: \"DucklingHTTPExtractor\" url: \"http://duckling:8000\"","title":"Duckling"},{"location":"for-dialog-designers/rasa_nlu/#spacy","text":"In this version of TDM, the following Spacy entity types are supported: PERSON and PER : map to the person_name sort. To enable Spacy, make sure it's available to the Rasa server and use a pipeline that contains SpacyEntityExtractor , e.g. pipeline: - name: \"SpacyNLP\" - name: \"SpacyTokenizer\" - name: \"RegexFeaturizer\" - name: \"SpacyFeaturizer\" - name: \"CRFEntityExtractor\" - name: \"EntitySynonymMapper\" - name: \"SklearnIntentClassifier\" - name: \"SpacyEntityExtractor\"","title":"Spacy"},{"location":"for-dialog-designers/rasa_nlu/#train-the-model","text":"Once the training data and pipeline are configured, train your model according to the Rasa NLU HTTP API . For instance with: curl -XPOST -H 'Content-Type: application/x-yml' 'http://my-rasa-nlu.my-cloud.com:5000/train?project=my-ddd&model=my-model' --data-binary @training_data.yml In this case, the URL, project and model also need to be specified in the DDD config in the next step.","title":"Train the model"},{"location":"for-dialog-designers/rasa_nlu/#configure-the-ddd","text":"Make sure to configure Rasa NLU in the DDD config, for instance at my_ddd/ddd.config.json , by adding language specific rasa_nlu objects. For instance, for English: { \"rasa_nlu\" : { \"eng\" : { \"url\" : \"http://my-rasa-nlu.my-cloud.com:5000/parse\" , \"config\" : { \"project\" : \"my-ddd\" , \"model\" : \"my-model\" } } } } The rasa_nlu object contains the following fields: url : A string URL, pointing to the /parse endpoint of a Rasa NLU server . config : An object sent in the JSON payload when TDM posts it to the url . It can contain for instance project and model , as specified by the Rasa NLU HTTP API . TDM also adds the field \"q\": \"<user utterance>\" . If Rasa NLU should not be used for a particular language, remove the language altogether: { \"rasa_nlu\" : {} }","title":"Configure the DDD"},{"location":"for-dialog-designers/tutorial/","text":"Tutorial \u00b6 This tutorial covers the steps needed to design a basic dialog domain description (DDD). Step 1. Create the boilerplate \u00b6 First we need to create the DDD boilerplate. mkdir ddd_root ; cd ddd_root tdm create-ddd basic_action Before your DDD can be used, it needs to be built. tdm build To make sure your DDD and all dependencies are working as intended, let's run interaction tests. tdm test eng Ran 1 test in 0 .386s OK The test reports OK. We're ready to start adding dialogue to our DDD. Step 2. Interaction test \u00b6 Since we're working test driven, let's add an interaction test first. Interaction tests verifiy the dialogue, providing user utterances and specifying the expected system responses. Modify basic_action/test/interaction_tests_eng.txt , add a test for the new dialogue that we want to support. We proceed one step at a time, starting with a very simple dialogue. --- call S> What would you like to do? U> call S> Who do you want to call? Let's run the tests again to verify that they fail. (We don't need to rebuild after only modifying tests.) tdm test eng TDM will complain that it does not understand instead the user. On line 7 of basic_action/test/interaction_tests_eng.txt, expected: S> Who do you want to call? but got: S> I heard you say call. I don't understand. So, What would you like to do? This happens because there's no notion of calling in the DDD. Step 3. Ontology \u00b6 The ontology declares what users can do and talk about, much like header files. In order to call someone we need to add the notion of calling, and the notion of people, to the ontology. Our boilerplate ontology is basically empty, in basic_action/ontology.xml . <?xml version=\"1.0\" encoding=\"utf-8\"?> <ontology name= \"BasicActionOntology\" > </ontology> We extend it with an action to make calls: <?xml version=\"1.0\" encoding=\"utf-8\"?> <ontology name= \"BasicActionOntology\" > <action name= \"call\" /> </ontology> Let's build and run the tests again to see if we missed something. tdm build We now receive a warning. Generating models for DDD 'basic_action'. [eng] Cleaning build directory 'build/eng'...Done. [eng] Generating grammar. Missing grammar entry: How do speakers talk about the action 'call'? Possible contents of the <action> element: <verb-phrase> <noun-phrase> <one-of> [eng] Finished generating grammar. Finished generating models for DDD 'basic_action'. Training models for DDD 'basic_action'. [eng] Asserting that language grammar is lower case...Done. [eng] Compiling generated grammar. [eng] Finished compiling generated grammar. [eng] No ASR specified, will not build language model. [eng] Copying ASR language modules from '/private/tmp/ddd_root/basic_action/grammar/build/eng' to ddd directory...Done. [eng] Not using word list correction, will not generate word list. Apparently, ontology entries require their corresponding grammar entries. Step 4. Grammar \u00b6 The grammar defines what our users and system can say. Our previous build attempt told us to add an entry for the call action. Let's extend basic_action/grammar/grammar_eng.xml with the call action. <?xml version=\"1.0\" encoding=\"utf-8\"?> <grammar> <action name= \"call\" > <verb-phrase> <verb ref= \"call\" /> </verb-phrase> </action> <lexicon> <verb id= \"call\" > <infinitive> call </infinitive> </verb> </lexicon> </grammar> This grammar definition describes that the action call can be referenced with a verb phrase containing the verb call . It also contains a lexicon describing the grammar of call in English. We only need to specifiy the infinitive form for the verb; the other forms, such as imperative, are derived automatically. Let's build and test. tdm build tdm test eng On line 7 of basic_action/test/interaction_tests_eng.txt, expected: S> Who do you want to call? but got: S> The function is not implemented. TDM replies! It means we did something right but apparently we need to implement the functionality as well. We need to add a plan for calling. Step 5. Plan \u00b6 Plans group together what our users can talk about. The plan is executed in order to reach a goal, for example to perform an action. When talking about something in the plan, TDM infers which goal is being implied and puts it at the top of the agenda. Let's check the boilerplate, in basic_action/domain.xml . <?xml version=\"1.0\" encoding=\"utf-8\"?> <domain name= \"BasicActionDomain\" is_super_domain= \"true\" > <goal type= \"perform\" action= \"top\" > <plan> <forget_all/> <findout type= \"goal\" /> </plan> </goal> </domain> We get the top goal for free. This is the only goal on TDM's agenda at startup. It will make TDM ask us which goal we want to achieve. Remember the corresponding default interaction test. --- main menu S> What would you like to do? Anyway, let's add a new goal and plan, corresponding to our call action. Extend the domain. <?xml version=\"1.0\" encoding=\"utf-8\"?> <domain name= \"BasicActionDomain\" is_super_domain= \"true\" > <goal type= \"perform\" action= \"top\" > <plan> <forget_all/> <findout type= \"goal\" /> </plan> </goal> <goal type= \"perform\" action= \"call\" > <plan> <findout type= \"wh_question\" predicate= \"selected_contact\" /> <invoke_service_action name= \"Call\" postconfirm= \"true\" /> </plan> </goal> </domain> In ontology.xml , we also need to add the selected_contact predicate and its sort: <?xml version=\"1.0\" encoding=\"utf-8\"?> <ontology name= \"BasicActionOntology\" > <action name= \"call\" /> <sort name= \"contact\" dynamic= \"true\" /> <predicate name= \"selected_contact\" sort= \"contact\" /> </ontology> A dynamic sort means its individuals are decided during run time, through the service interface. Now build the DDD. tdm build Generating models for DDD 'basic_action'. [eng] Cleaning build directory 'build/eng'...Done. [eng] Generating grammar. Missing grammar entry: How does the system ask about 'selected_contact'? Example: <question speaker=\"system\" predicate=\"selected_contact\" type=\"wh_question\"> <utterance>what is selected contact</utterance> </question> [eng] Finished generating grammar. Finished generating models for DDD 'basic_action'. Training models for DDD 'basic_action'. [eng] Asserting that language grammar is lower case...Done. [eng] Compiling generated grammar. [eng] Finished compiling generated grammar. [eng] No ASR specified, will not build language model. [eng] Copying ASR language modules from '/private/tmp/ddd_root/basic_action/grammar/build/eng' to ddd directory...Done. [eng] Not using word list correction, will not generate word list. We got a new warning about a missing grammar entry. When referencing a predicate in a plan, we apparently need to specify its grammar entry. Since we're using a findout, the grammar entry is to define how TDM should speak the corresponding question . Let's extend basic_action/grammar/grammar_eng.xml with the following: <question speaker= \"system\" predicate= \"selected_contact\" type= \"wh_question\" > <utterance> who do you want to call </utterance> </question> Build and test. tdm build tdm test eng Ran 2 tests in 0.363s OK Everything works as expected. Step 6. Service interface \u00b6 In the next step, we want the user to be able to reply to the question about who to call. We thus extend basic_action/test/interaction_tests_eng.txt accordingly: --- call S> What would you like to do? U> call S> Who do you want to call? U> John S> Calling John. Test: tdm test eng On line 9 of basic_action/test/interaction_tests_eng.txt, expected: S> Calling John. but got: S> I heard you say John. I don't understand. So, Who do you want to call? As can be seen, the system doesn't understand John. We need to add an entity recognizer to our service interface. It needs to recognize entities of our contact sort. Our boilerplate service interface is basically empty, in basic_action/service_interface.xml , so let's just add it. <?xml version=\"1.0\" encoding=\"utf-8\"?> <service_interface> <entity_recognizer name= \"BasicActionRecognizer\" > <target> <http endpoint= \"http://127.0.0.1:10102/contact_recognizer\" /> </target> </entity_recognizer> </service_interface> Here, we use an HTTP target with an end-point that runs an HTTP service. An HTTP service can be hosted anywhere where TDM can reach it. In this tutorial, we assume that the service is hosted locally, i.e. on the same machine as TDM (127.0.0.1), but this is not required. Generally, the developer can choose any web development framework as long as it is within the constraints of the HTTP service API protocol . The entity recognizer is responsible for finding all dynamic entities in utterances. Its accuracy affects the behaviour of the dialogue system. Since the search is conducted during runtime, particular care should be taken to ensure that the method is accurate, robust and has sufficient performance. See the API documentation for details about request and response formats for entity recognizers. In this case, we are providing you with a ready-to-use HTTP service , which includes an entity recognizer. It uses Flask web framework and jinja2 templates in plain python. As the service is hosted locally in this case, we recommend to save it in the DDD folder basic_action . Then, spawn it with Flask: export FLASK_APP = basic_action/http_service_example.py flask run --port = 10102 And then, build and test. tdm build tdm test eng UnexpectedActionException: Expected one of the known actions [] but got 'Call' Great, TDM appears to understand John. It wants to execute the Call action using our service interface, but could not find it. Let's add it to basic_action/service_interface.xml . <?xml version=\"1.0\" encoding=\"utf-8\"?> <service_interface> <action name= \"Call\" > <parameters> <parameter predicate= \"selected_contact\" format= \"value\" /> </parameters> <failure_reasons/> <target> <http endpoint= \"http://127.0.0.1:10102/call\" /> </target> </action> <entity_recognizer name= \"BasicActionRecognizer\" > <target> <http endpoint= \"http://127.0.0.1:10102/contact_recognizer\" /> </target> </entity_recognizer> </service_interface> To implement the 'call' action, see the API documentation for details about request and response formats for actions. However, you can also find and use the 'call' action that has been already implemented in the example HTTP service. Build again. tdm build Generating models for DDD 'basic_action'. [eng] Cleaning build directory 'build/eng'...Done. [eng] Generating grammar. Missing grammar entry: How does the system report that the service action 'Call' ended? Example: <report action=\"Call\" status=\"ended\"> <utterance>performed Call</utterance> </report> [eng] Finished generating grammar. Finished generating models for DDD 'basic_action'. Training models for DDD 'basic_action'. [eng] Asserting that language grammar is lower case...Done. [eng] Compiling generated grammar. [eng] Finished compiling generated grammar. [eng] No ASR specified, will not build language model. [eng] Copying ASR language modules from '/private/tmp/ddd_root/basic_action/grammar/build/eng' to ddd directory...Done. [eng] Not using word list correction, will not generate word list. As can be seen, we need to add a grammar entry for the service action Call . This is required because we said so in the plan. Remember postconfirm=\"true\" in the invoke_service_action entry of the plan? Let's add a report grammar entry in basic_action/grammar/grammar_eng.xml . We can reference the selected_contact predicate since its part of the findout entries of the plan. <report action= \"Call\" status= \"ended\" > <utterance> calling <individual predicate= \"selected_contact\" /></utterance> </report> Build and test. tdm build tdm test eng Ran 2 tests in 0.363s OK Success! Step 7. One-shot utterances \u00b6 The DDD so far handles very simple dialogues where the user enters one piece of information at a time. In order to support one-shot utterances such as \"call John\" containing several pieces of information (in this case an action and an answer regarding who to call), we need to extend the grammar. First we add a failing interaction test in basic_action/test/interaction_tests_eng.txt : --- one-shot utterance U> call John S> Calling John. Run the tests to verify that the new one fails. tdm test eng On line 13 of basic_action/test/interaction_tests_eng.txt, expected: S> Calling John. but got: S> I heard you say call John. I don ' t understand. So, What would you like to do ? We now add the following lines to basic_action/grammar/grammar_eng.xml : <request action= \"call\" > <utterance> call <individual sort= \"contact\" /></utterance> </request> The element <request> is used when defining things that the user can say to request that an action is to be performed. In contrast to <action> , <request> is user-specific and deals with whole utterances, including potential references to individuals. The element <individual> acts as a slot, showing that a certain place in the utterance refers to an individual. Now build and test. tdm build tdm test eng Ran 3 tests in 0 .523s OK Step 8. Adding a language \u00b6 If you want to add support for a new language, the following steps are needed. First you need to modify the file backend.config.json . In the field supported_languages , add \"fre\" for French and/or \"dut\" for Dutch (separated by commas). Assuming we want to add support for French, the file contents are changed to { \"supported_languages\" : [ \"eng\" , \"fre\" ] } Second, we need to create interaction tests for the new language. For French, we add the file basic_action/test/interaction_tests_fre.txt with translated contents: --- main menu S> Que voulez-vous faire? --- call S> Que voulez-vous faire? U> appellez S> Qui voulez-vous appeler? U> Andr\u00e9 S> J 'appelle Andr\u00e9. --- one-shot utterance U> appellez Andr\u00e9 S> J' appelle Andr\u00e9. Make sure to save the interaction tests with UTF-8 encoding without byte-order mark (BOM) when using non-ASCII characters. Check our HTTP service to see that name of the contacts are already there translated in French (and even Dutch): CONTACTS_FRENCH = { \"Jean\" : JOHN , u \"\u00c9lise\" : LISA , \"Marie\" : MARY , u \"Andr\u00e9\" : ANDY , } CONTACTS_DUTCH = { \"Jan\" : JOHN , \"Lisa\" : LISA , \"Maria\" : MARY , \"Andreas\" : ANDY , } Finally, we need to create a grammar file for the new language. For French, we add the file basic_action/grammar/grammar_fre.xml with the following contents: <?xml version=\"1.0\" encoding=\"utf-8\"?> <grammar> <action name= \"call\" > <verb-phrase> <verb ref= \"call\" /> </verb-phrase> </action> <request action= \"call\" > <utterance> appellez <individual sort= \"contact\" /></utterance> </request> <lexicon> <verb id= \"call\" > <infinitive> appeller </infinitive> </verb> </lexicon> <question speaker= \"system\" predicate= \"selected_contact\" type= \"wh_question\" > <utterance> qui voulez-vous appeler </utterance> </question> <report action= \"Call\" status= \"ended\" > <utterance> j'appelle <individual predicate= \"selected_contact\" /></utterance> </report> </grammar> Build and test. Note the changed language parameter for interaction testing. tdm build tdm test fre Ran 3 tests in 0 .509s OK Step 9. How to continue \u00b6 This tutorial has illustrated how to implement the basic action example . The source code is available on Github . In order to continue, go to the examples section to find an example similar to your desired functionality. Steal the best ideas from there, adjusting them for yor domain. Remember to work test driven, adding a test first, then making it work.","title":"Step-by-step tutorial"},{"location":"for-dialog-designers/tutorial/#tutorial","text":"This tutorial covers the steps needed to design a basic dialog domain description (DDD).","title":"Tutorial"},{"location":"for-dialog-designers/tutorial/#step-1-create-the-boilerplate","text":"First we need to create the DDD boilerplate. mkdir ddd_root ; cd ddd_root tdm create-ddd basic_action Before your DDD can be used, it needs to be built. tdm build To make sure your DDD and all dependencies are working as intended, let's run interaction tests. tdm test eng Ran 1 test in 0 .386s OK The test reports OK. We're ready to start adding dialogue to our DDD.","title":"Step 1. Create the boilerplate"},{"location":"for-dialog-designers/tutorial/#step-2-interaction-test","text":"Since we're working test driven, let's add an interaction test first. Interaction tests verifiy the dialogue, providing user utterances and specifying the expected system responses. Modify basic_action/test/interaction_tests_eng.txt , add a test for the new dialogue that we want to support. We proceed one step at a time, starting with a very simple dialogue. --- call S> What would you like to do? U> call S> Who do you want to call? Let's run the tests again to verify that they fail. (We don't need to rebuild after only modifying tests.) tdm test eng TDM will complain that it does not understand instead the user. On line 7 of basic_action/test/interaction_tests_eng.txt, expected: S> Who do you want to call? but got: S> I heard you say call. I don't understand. So, What would you like to do? This happens because there's no notion of calling in the DDD.","title":"Step 2. Interaction test"},{"location":"for-dialog-designers/tutorial/#step-3-ontology","text":"The ontology declares what users can do and talk about, much like header files. In order to call someone we need to add the notion of calling, and the notion of people, to the ontology. Our boilerplate ontology is basically empty, in basic_action/ontology.xml . <?xml version=\"1.0\" encoding=\"utf-8\"?> <ontology name= \"BasicActionOntology\" > </ontology> We extend it with an action to make calls: <?xml version=\"1.0\" encoding=\"utf-8\"?> <ontology name= \"BasicActionOntology\" > <action name= \"call\" /> </ontology> Let's build and run the tests again to see if we missed something. tdm build We now receive a warning. Generating models for DDD 'basic_action'. [eng] Cleaning build directory 'build/eng'...Done. [eng] Generating grammar. Missing grammar entry: How do speakers talk about the action 'call'? Possible contents of the <action> element: <verb-phrase> <noun-phrase> <one-of> [eng] Finished generating grammar. Finished generating models for DDD 'basic_action'. Training models for DDD 'basic_action'. [eng] Asserting that language grammar is lower case...Done. [eng] Compiling generated grammar. [eng] Finished compiling generated grammar. [eng] No ASR specified, will not build language model. [eng] Copying ASR language modules from '/private/tmp/ddd_root/basic_action/grammar/build/eng' to ddd directory...Done. [eng] Not using word list correction, will not generate word list. Apparently, ontology entries require their corresponding grammar entries.","title":"Step 3. Ontology"},{"location":"for-dialog-designers/tutorial/#step-4-grammar","text":"The grammar defines what our users and system can say. Our previous build attempt told us to add an entry for the call action. Let's extend basic_action/grammar/grammar_eng.xml with the call action. <?xml version=\"1.0\" encoding=\"utf-8\"?> <grammar> <action name= \"call\" > <verb-phrase> <verb ref= \"call\" /> </verb-phrase> </action> <lexicon> <verb id= \"call\" > <infinitive> call </infinitive> </verb> </lexicon> </grammar> This grammar definition describes that the action call can be referenced with a verb phrase containing the verb call . It also contains a lexicon describing the grammar of call in English. We only need to specifiy the infinitive form for the verb; the other forms, such as imperative, are derived automatically. Let's build and test. tdm build tdm test eng On line 7 of basic_action/test/interaction_tests_eng.txt, expected: S> Who do you want to call? but got: S> The function is not implemented. TDM replies! It means we did something right but apparently we need to implement the functionality as well. We need to add a plan for calling.","title":"Step 4. Grammar"},{"location":"for-dialog-designers/tutorial/#step-5-plan","text":"Plans group together what our users can talk about. The plan is executed in order to reach a goal, for example to perform an action. When talking about something in the plan, TDM infers which goal is being implied and puts it at the top of the agenda. Let's check the boilerplate, in basic_action/domain.xml . <?xml version=\"1.0\" encoding=\"utf-8\"?> <domain name= \"BasicActionDomain\" is_super_domain= \"true\" > <goal type= \"perform\" action= \"top\" > <plan> <forget_all/> <findout type= \"goal\" /> </plan> </goal> </domain> We get the top goal for free. This is the only goal on TDM's agenda at startup. It will make TDM ask us which goal we want to achieve. Remember the corresponding default interaction test. --- main menu S> What would you like to do? Anyway, let's add a new goal and plan, corresponding to our call action. Extend the domain. <?xml version=\"1.0\" encoding=\"utf-8\"?> <domain name= \"BasicActionDomain\" is_super_domain= \"true\" > <goal type= \"perform\" action= \"top\" > <plan> <forget_all/> <findout type= \"goal\" /> </plan> </goal> <goal type= \"perform\" action= \"call\" > <plan> <findout type= \"wh_question\" predicate= \"selected_contact\" /> <invoke_service_action name= \"Call\" postconfirm= \"true\" /> </plan> </goal> </domain> In ontology.xml , we also need to add the selected_contact predicate and its sort: <?xml version=\"1.0\" encoding=\"utf-8\"?> <ontology name= \"BasicActionOntology\" > <action name= \"call\" /> <sort name= \"contact\" dynamic= \"true\" /> <predicate name= \"selected_contact\" sort= \"contact\" /> </ontology> A dynamic sort means its individuals are decided during run time, through the service interface. Now build the DDD. tdm build Generating models for DDD 'basic_action'. [eng] Cleaning build directory 'build/eng'...Done. [eng] Generating grammar. Missing grammar entry: How does the system ask about 'selected_contact'? Example: <question speaker=\"system\" predicate=\"selected_contact\" type=\"wh_question\"> <utterance>what is selected contact</utterance> </question> [eng] Finished generating grammar. Finished generating models for DDD 'basic_action'. Training models for DDD 'basic_action'. [eng] Asserting that language grammar is lower case...Done. [eng] Compiling generated grammar. [eng] Finished compiling generated grammar. [eng] No ASR specified, will not build language model. [eng] Copying ASR language modules from '/private/tmp/ddd_root/basic_action/grammar/build/eng' to ddd directory...Done. [eng] Not using word list correction, will not generate word list. We got a new warning about a missing grammar entry. When referencing a predicate in a plan, we apparently need to specify its grammar entry. Since we're using a findout, the grammar entry is to define how TDM should speak the corresponding question . Let's extend basic_action/grammar/grammar_eng.xml with the following: <question speaker= \"system\" predicate= \"selected_contact\" type= \"wh_question\" > <utterance> who do you want to call </utterance> </question> Build and test. tdm build tdm test eng Ran 2 tests in 0.363s OK Everything works as expected.","title":"Step 5. Plan"},{"location":"for-dialog-designers/tutorial/#step-6-service-interface","text":"In the next step, we want the user to be able to reply to the question about who to call. We thus extend basic_action/test/interaction_tests_eng.txt accordingly: --- call S> What would you like to do? U> call S> Who do you want to call? U> John S> Calling John. Test: tdm test eng On line 9 of basic_action/test/interaction_tests_eng.txt, expected: S> Calling John. but got: S> I heard you say John. I don't understand. So, Who do you want to call? As can be seen, the system doesn't understand John. We need to add an entity recognizer to our service interface. It needs to recognize entities of our contact sort. Our boilerplate service interface is basically empty, in basic_action/service_interface.xml , so let's just add it. <?xml version=\"1.0\" encoding=\"utf-8\"?> <service_interface> <entity_recognizer name= \"BasicActionRecognizer\" > <target> <http endpoint= \"http://127.0.0.1:10102/contact_recognizer\" /> </target> </entity_recognizer> </service_interface> Here, we use an HTTP target with an end-point that runs an HTTP service. An HTTP service can be hosted anywhere where TDM can reach it. In this tutorial, we assume that the service is hosted locally, i.e. on the same machine as TDM (127.0.0.1), but this is not required. Generally, the developer can choose any web development framework as long as it is within the constraints of the HTTP service API protocol . The entity recognizer is responsible for finding all dynamic entities in utterances. Its accuracy affects the behaviour of the dialogue system. Since the search is conducted during runtime, particular care should be taken to ensure that the method is accurate, robust and has sufficient performance. See the API documentation for details about request and response formats for entity recognizers. In this case, we are providing you with a ready-to-use HTTP service , which includes an entity recognizer. It uses Flask web framework and jinja2 templates in plain python. As the service is hosted locally in this case, we recommend to save it in the DDD folder basic_action . Then, spawn it with Flask: export FLASK_APP = basic_action/http_service_example.py flask run --port = 10102 And then, build and test. tdm build tdm test eng UnexpectedActionException: Expected one of the known actions [] but got 'Call' Great, TDM appears to understand John. It wants to execute the Call action using our service interface, but could not find it. Let's add it to basic_action/service_interface.xml . <?xml version=\"1.0\" encoding=\"utf-8\"?> <service_interface> <action name= \"Call\" > <parameters> <parameter predicate= \"selected_contact\" format= \"value\" /> </parameters> <failure_reasons/> <target> <http endpoint= \"http://127.0.0.1:10102/call\" /> </target> </action> <entity_recognizer name= \"BasicActionRecognizer\" > <target> <http endpoint= \"http://127.0.0.1:10102/contact_recognizer\" /> </target> </entity_recognizer> </service_interface> To implement the 'call' action, see the API documentation for details about request and response formats for actions. However, you can also find and use the 'call' action that has been already implemented in the example HTTP service. Build again. tdm build Generating models for DDD 'basic_action'. [eng] Cleaning build directory 'build/eng'...Done. [eng] Generating grammar. Missing grammar entry: How does the system report that the service action 'Call' ended? Example: <report action=\"Call\" status=\"ended\"> <utterance>performed Call</utterance> </report> [eng] Finished generating grammar. Finished generating models for DDD 'basic_action'. Training models for DDD 'basic_action'. [eng] Asserting that language grammar is lower case...Done. [eng] Compiling generated grammar. [eng] Finished compiling generated grammar. [eng] No ASR specified, will not build language model. [eng] Copying ASR language modules from '/private/tmp/ddd_root/basic_action/grammar/build/eng' to ddd directory...Done. [eng] Not using word list correction, will not generate word list. As can be seen, we need to add a grammar entry for the service action Call . This is required because we said so in the plan. Remember postconfirm=\"true\" in the invoke_service_action entry of the plan? Let's add a report grammar entry in basic_action/grammar/grammar_eng.xml . We can reference the selected_contact predicate since its part of the findout entries of the plan. <report action= \"Call\" status= \"ended\" > <utterance> calling <individual predicate= \"selected_contact\" /></utterance> </report> Build and test. tdm build tdm test eng Ran 2 tests in 0.363s OK Success!","title":"Step 6. Service interface"},{"location":"for-dialog-designers/tutorial/#step-7-one-shot-utterances","text":"The DDD so far handles very simple dialogues where the user enters one piece of information at a time. In order to support one-shot utterances such as \"call John\" containing several pieces of information (in this case an action and an answer regarding who to call), we need to extend the grammar. First we add a failing interaction test in basic_action/test/interaction_tests_eng.txt : --- one-shot utterance U> call John S> Calling John. Run the tests to verify that the new one fails. tdm test eng On line 13 of basic_action/test/interaction_tests_eng.txt, expected: S> Calling John. but got: S> I heard you say call John. I don ' t understand. So, What would you like to do ? We now add the following lines to basic_action/grammar/grammar_eng.xml : <request action= \"call\" > <utterance> call <individual sort= \"contact\" /></utterance> </request> The element <request> is used when defining things that the user can say to request that an action is to be performed. In contrast to <action> , <request> is user-specific and deals with whole utterances, including potential references to individuals. The element <individual> acts as a slot, showing that a certain place in the utterance refers to an individual. Now build and test. tdm build tdm test eng Ran 3 tests in 0 .523s OK","title":"Step 7. One-shot utterances"},{"location":"for-dialog-designers/tutorial/#step-8-adding-a-language","text":"If you want to add support for a new language, the following steps are needed. First you need to modify the file backend.config.json . In the field supported_languages , add \"fre\" for French and/or \"dut\" for Dutch (separated by commas). Assuming we want to add support for French, the file contents are changed to { \"supported_languages\" : [ \"eng\" , \"fre\" ] } Second, we need to create interaction tests for the new language. For French, we add the file basic_action/test/interaction_tests_fre.txt with translated contents: --- main menu S> Que voulez-vous faire? --- call S> Que voulez-vous faire? U> appellez S> Qui voulez-vous appeler? U> Andr\u00e9 S> J 'appelle Andr\u00e9. --- one-shot utterance U> appellez Andr\u00e9 S> J' appelle Andr\u00e9. Make sure to save the interaction tests with UTF-8 encoding without byte-order mark (BOM) when using non-ASCII characters. Check our HTTP service to see that name of the contacts are already there translated in French (and even Dutch): CONTACTS_FRENCH = { \"Jean\" : JOHN , u \"\u00c9lise\" : LISA , \"Marie\" : MARY , u \"Andr\u00e9\" : ANDY , } CONTACTS_DUTCH = { \"Jan\" : JOHN , \"Lisa\" : LISA , \"Maria\" : MARY , \"Andreas\" : ANDY , } Finally, we need to create a grammar file for the new language. For French, we add the file basic_action/grammar/grammar_fre.xml with the following contents: <?xml version=\"1.0\" encoding=\"utf-8\"?> <grammar> <action name= \"call\" > <verb-phrase> <verb ref= \"call\" /> </verb-phrase> </action> <request action= \"call\" > <utterance> appellez <individual sort= \"contact\" /></utterance> </request> <lexicon> <verb id= \"call\" > <infinitive> appeller </infinitive> </verb> </lexicon> <question speaker= \"system\" predicate= \"selected_contact\" type= \"wh_question\" > <utterance> qui voulez-vous appeler </utterance> </question> <report action= \"Call\" status= \"ended\" > <utterance> j'appelle <individual predicate= \"selected_contact\" /></utterance> </report> </grammar> Build and test. Note the changed language parameter for interaction testing. tdm build tdm test fre Ran 3 tests in 0 .509s OK","title":"Step 8. Adding a language"},{"location":"for-dialog-designers/tutorial/#step-9-how-to-continue","text":"This tutorial has illustrated how to implement the basic action example . The source code is available on Github . In order to continue, go to the examples section to find an example similar to your desired functionality. Steal the best ideas from there, adjusting them for yor domain. Remember to work test driven, adding a test first, then making it work.","title":"Step 9. How to continue"}]}